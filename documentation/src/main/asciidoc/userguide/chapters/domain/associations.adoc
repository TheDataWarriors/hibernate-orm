[[associations]]
=== Associations
:sourcedir: extras

Associations describe how two or more entities are form a relationship based on a relational database joining semantics.

==== `@ManyToOne`

`@ManyToOne` is the most common association, having a direct equivalent in the relational database as well (e.g. `FOREIGN KEY`),
and so it establishes a relationship between a child entity and a parent.

.`@ManyToOne` association
====
[source,java]
----
include::{sourcedir}/associations/ManyToOne.java[]
----

[source,sql]
----
include::{sourcedir}/associations/ManyToOne.sql[]
----
====

Each entity has a lifecycle of its own. Once the `@ManyToOne` association is set, Hibernate will set the associated `FOREIGN KEY`.

.`@ManyToOne` association lifecycle
====
[source,java]
----
include::{sourcedir}/associations/ManyToOneLifecycle.java[]
----

[source,sql]
----
include::{sourcedir}/associations/ManyToOneLifecycle.sql[]
----
====

==== `@OneToMany`

The `@OneToMany` association links a parent entity with a child one.
If the `@OneToMany` doesn't have a mirroring `@ManyToOne` association on the other end, then the association is unidirectional.
If the `@OneToMany` has a `@ManyToOne` association on the child side, the association is bidirectional, and the application developer can navigate this relationship from both ends.

===== Unidirectional `@OneToMany`

When using a unidirectional `@OneToMany` association, Hibernate resorts to using a link table between the joining entities.

.Unidirectional `@OneToMany` association
====
[source,java]
----
include::{sourcedir}/associations/UnidirectionalOneToMany.java[]
----

[source,sql]
----
include::{sourcedir}/associations/UnidirectionalOneToMany.sql[]
----
====

[NOTE]
====
Only the parent side of an association makes sense to cascade entity state transitions to its children.
The `@OneToMany` association is by definition a parent association, even if it's a unidirectional or a bidirectional one.
====

.Cascading `@OneToMany` association
====
[source,java]
----
include::{sourcedir}/associations/UnidirectionalOneToManyLifecycle.java[]
----

[source,sql]
----
include::{sourcedir}/associations/UnidirectionalOneToManyLifecycle.sql[]
----
====

When persisting the parent `Person` entity, the cascade will propagate the persist operation to the underlying `Phone` children as well.
Upon removing a `Phone` from the phones collection, the association row is deleted from the link table, and the `orphanRemoval` attribute will propagate a `Phone` removal as well.

[NOTE]
====
The unidirectional associations are not very efficient when it comes to removing child entities.
In this particular example, upon flushing the persistence context, Hibernate deletes all database child entries and reinserts the ones that are still found in the persistence context.

On the other hand, a bidirectional `@OneToMany` association is much more efficient when the child entity controls the association.
====

===== Bidirectional `@OneToMany`

The bidirectional `@OneToMany` association also requires a `@ManyToOne` association on the child side.
The database has only one side of this association, which is the `FOREIGN KEY`, but the persistent entities have two sides to navigate this association.

Every bidirectional association must have only one owning side (the child side), the other one being referred to as the _inverse_ side.

.`@OneToMany` association mappedBy the `@ManyToOne` side
====
[source,java]
----
include::{sourcedir}/associations/BidirectionalOneToMany.java[]
----

[source,sql]
----
include::{sourcedir}/associations/BidirectionalOneToMany.sql[]
----
====

[IMPORTANT]
====
Whenever a bidirectional association is formed, the application developer must make sure both side are in-sync at all times.
The `addPhone()` and `removePhone()` methods are utilities methods that synchronize both sides whenever an element is added or removed.
====

Because the `Phone` class has a `@NaturalId` columns since the phone number must be universally unique,
the `equals()` and the `hashCode()` can safely use this column, and so the `removePhone()` logic is greatly simplified.


.Bidirectional `@OneToMany` with an owner `@ManyToOne` side lifecycle
====
[source,java]
----
include::{sourcedir}/associations/BidirectionalOneToManyLifecycle.java[]
----

[source,sql]
----
include::{sourcedir}/associations/BidirectionalOneToManyLifecycle.sql[]
----
====

Unlike the unidirectional `@OneToMany`, the bidirectional association is much more efficient in managing the collection persistence state.
Every element removal only requires a single update, in which the `FOREIGN KEY` column is set to `NULL`.

If the child entity lifecycle is bound to its owning parent so that the child cannot exist without a parent,
then we can annotate the association with the `orphan-removal` attribute.

==== `@OneToOne`

The `@OneToOne` association can either be unidirectional or bidirectional.
A unidirectional association follows the relational database `FOREIGN KEY` semantics, and the client-side own this relationship.
A bidirectional association also features a `mappedBy` parent side too.

===== Unidirectional `@OneToOne`

.Unidirectional `@OneToOne`
====
[source,java]
----
include::{sourcedir}/associations/UnidirectionalOneToOne.java[]
----

[source,sql]
----
include::{sourcedir}/associations/UnidirectionalOneToOne.sql[]
----
====

From a relational database point of view, the underlying schema is identical to the unidirectional `@ManyToOne` case,
as the client-side controls the association based on the foreign key relationship.

But then, it's unusual to consider the `Phone` as a client-side and the `PhoneDetails` as the parent-side, because the details cannot exist without a phone.
A much more natural mapping would be if the `Phone` is the parent-side, therefore moving the `FOREIGN KEY` into the `PhoneDetails` table.
This mapping requires a bidirectional `@OneToOne` association, as you can see in the following example:

===== Bidirectional `@OneToOne`

.Bidirectional `@OneToOne`
====
[source,java]
----
include::{sourcedir}/associations/BidirectionalOneToOne.java[]
----

[source,sql]
----
include::{sourcedir}/associations/BidirectionalOneToOne.sql[]
----
====

This time, the `PhoneDetails` owns the association, and, like any bidirectional association, the parent-side propagates its lifecycle to the child-side, through cascading.

.Bidirectional `@OneToOne` lifecycle
====
[source,java]
----
include::{sourcedir}/associations/BidirectionalOneToOneLifecycle.java[]
----

[source,sql]
----
include::{sourcedir}/associations/BidirectionalOneToOneLifecycle.sql[]
----
====

When using a bidirectional `@OneToOne` association, Hibernate enforces the unique constraint upon fetching the child-side.
If there are more than one children associated to the same parent, Hibernate will throw the following exception:

.Bidirectional `@OneToOne` unique constraint
====
[source,java]
----
include::{sourcedir}/associations/BidirectionalOneToOneConstraint.java[]
----
====

==== `@ManyToMany`

The `@ManyToMany` requires a link table that joins two entities.
It's a rather exotic association, and most often it can be replaced by two bidirectional `@OneToMany` relationships.

Like the `@OneToMany` association, `@ManyToMany` can be a either unidirectional or bidirectional.

===== Unidirectional `@ManyToMany`

.Unidirectional `@ManyToMany`
====
[source,java]
----
include::{sourcedir}/associations/UnidirectionalManyToMany.java[]
----

[source,sql]
----
include::{sourcedir}/associations/UnidirectionalManyToMany.sql[]
----
====

Just like with unidirectional `@OneToMany` associations, the link table is controlled by the owning side.

When an entity is removed from the `@ManyToMany` collection, Hibernate simply deletes the joining record in the link table.
Unfortunately, this operation requires removing all entries associated to a given parent and recreating the ones that are listed in the current running persistent context.

.Unidirectional `@ManyToMany` lifecycle
====
[source,java]
----
include::{sourcedir}/associations/UnidirectionalManyToManyLifecycle.java[]
----

[source,sql]
----
include::{sourcedir}/associations/UnidirectionalManyToManyLifecycle.sql[]
----
====

[NOTE]
====
For `@ManyToMany` associations, the `REMOVE` entity state transitions doesn't make sense to be cascaded, because it will propagate beyond the link table.
Because the other side might be referenced by other entities on the parent-side, the automatic removal might end up in a `ConstraintViolationException`.

If `@ManyToMany(cascade = CascadeType.ALL)` was defined and the first person would be deleted,
Hibernate would throw an exception because another person is also associated to the address that's automatically deleted.

[source,java]
----
Person person1 = entityManager.find(Person.class, personId);
entityManager.remove(person1);

Caused by: javax.persistence.PersistenceException: org.hibernate.exception.ConstraintViolationException: could not execute statement
Caused by: org.hibernate.exception.ConstraintViolationException: could not execute statement
Caused by: java.sql.SQLIntegrityConstraintViolationException: integrity constraint violation: foreign key no action; FKM7J0BNABH2YR0PE99IL1D066U table: PERSON_ADDRESS
----
====

By simply removing the parent-side, Hibernate can safely remove the associated link records, as you can see in the following example:

.Unidirectional `@ManyToMany` entity removal
====
[source,java]
----
include::{sourcedir}/associations/UnidirectionalManyToManyRemove.java[]
----

[source,sql]
----
include::{sourcedir}/associations/UnidirectionalManyToManyRemove.sql[]
----
====

===== Bidirectional `@ManyToMany`