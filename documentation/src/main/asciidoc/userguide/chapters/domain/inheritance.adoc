[[entity-inheritance]]
=== Inheritance
:sourcedir: extras

Although relational database systems don't provide inheritance, Hibernate can leverage this object-oriented trait onto domain model entities.
There are several strategies to achieve inheritance:

MappedSuperclass:: Inheritance is implemented in domain model only and the database doesn't reflect it at all. See <<entity-inheritance-mapped-superclass>>.
Single table:: The domain model class hierarchy is materialized into a single table which contains entities belonging to different class types. See <<entity-inheritance-single-table>>.
Joined table:: The base class has a table of its own. Each subclasses goes to its own table too and fetching a subclass entity requires a join with the parent table as well. See <<entity-inheritance-joined-table>>.
Table per class:: Each subclass has a its own table containing both the subclass as well as the base class properties. See <<entity-inheritance-table-per-class>>.

[[entity-inheritance-mapped-superclass]]
==== MappedSuperclass

In the following domain model class hierarchy, a 'DebitAccount' and a 'CreditAccount' share the same 'Account' base class.

image:images/domain/inheritance/inheritance_class_diagram.svg[Inheritance class diagram]

When using `MappedSuperclass`, the inheritance is visible in the domain model only.
Each database table contains both the base class and the subclass properties.

.`@MappedSuperclass` inheritance
====
[source,java]
----
include::{sourcedir}/inheritance/MappedSuperclass.java[]
----

[source,sql]
----
include::{sourcedir}/inheritance/MappedSuperclass.sql[]
----
====

[NOTE]
====
Because the `@MappedSuperclass` inheritance model is not mirrored at database level,
it's not therefore possible to query entities by their base class (like it's the case with all the other inheritance strategies).
====

[[entity-inheritance-single-table]]
==== Single table

The single table inheritance strategy maps all subclasses to only one database table.
With this approach the properties of all the subclasses in a given mapped class hierarchy are stored in a single table.

Each subclass declares its own persistent properties and subclasses.
Version and id properties are assumed to be inherited from the root class.

[NOTE]
====
When omitting an explicit inheritance strategy (e.g. `@Inheritance`), JPA will choose the `SINGLE_TABLE` strategy by default.
====

.Single Table inheritance
====
[source,java]
----
include::{sourcedir}/inheritance/SingleTable.java[]
----

[source,sql]
----
include::{sourcedir}/inheritance/SingleTable.sql[]
----
====

Each subclass in a hierarchy must define a unique discriminator value, which is used to differentiate between rows belonging to any given subclass type.
If this is not specified, the `DTYPE` column is used as a discriminator, storing associated subclass name.

.Single Table inheritance discriminator column
====
[source,java]
----
include::{sourcedir}/inheritance/SingleTablePersist.java[]
----

[source,sql]
----
include::{sourcedir}/inheritance/SingleTablePersist.sql[]
----
====

===== Discriminator

Discriminators are required for polymorphic persistence using the table-per-class-hierarchy mapping strategy.
It declares a discriminator column of the table.
The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row.
Hibernate Core supports the following restricted set of types as discriminator column: `String`, `char`, `int`, `byte`, `short`, `boolean`(including `yes_no`, `true_false`).

Use the `@DiscriminatorColumn` to define the discriminator column as well as the discriminator type.

[NOTE]
====
The enum `DiscriminatorType` used in `javax.persitence.DiscriminatorColumn` only contains the values STRING, CHAR and INTEGER which means that not all Hibernate supported types are available via the `@DiscriminatorColumn` annotation.
You can also use `@DiscriminatorFormula` to express in SQL a virtual discriminator column.
This is particularly useful when the discriminator value can be extracted from one or more columns of the table.
Both `@DiscriminatorColumn` and `@DiscriminatorFormula` are to be set on the root entity (once per persisted hierarchy).

`@org.hibernate.annotations.DiscriminatorOptions` allows to optionally specify Hibernate specific discriminator options which are not standardized in JPA.
The available options are `force` and `insert`.

The `force` attribute is useful if the table contains rows with _extra_ discriminator values that are not mapped to a persistent class.
This could for example occur when working with a legacy database.
If `force` is set to true Hibernate will specify the allowed discriminator values in the SELECT query, even when retrieving all instances of the root class.

The second option - `insert` - tells Hibernate whether or not to include the discriminator column in SQL INSERTs.
Usually the column should be part of the INSERT statement, but if your discriminator column is also part of a mapped composite identifier you have to set this option to false.
====

[IMPORTANT]
====
There used to be `@org.hibernate.annotations.ForceDiscriminator` annotation which was deprecated in version 3.6 and later removed. Use `@DiscriminatorOptions` instead.
====

Assuming a legacy database schema where the discriminator is based on inspecting a certain column,
we can take advantage of the Hibernate specific `@DiscriminatorFormula` annotation and map the inheritance model as follows:

.Single Table discriminator formula
====
[source,java]
----
include::{sourcedir}/inheritance/SingleTableDiscriminatorFormula.java[]
----

[source,sql]
----
include::{sourcedir}/inheritance/SingleTableDiscriminatorFormula.sql[]
----
====

The `@DiscriminatorFormula` defines a custom SQL clause that can be used to identify a certain subclass type.
The `@DiscriminatorValue` defines the mapping between the result of the `@DiscriminatorFormula` and the inheritance subclass type.

[[entity-inheritance-joined-table]]
==== Joined table

Each subclass can also be mapped to its own table.
This is also called _table-per-subclass_ mapping strategy.
An inherited state is retrieved by joining with the table of the superclass.

A discriminator column is not required for this mapping strategy.
Each subclass must, however, declare a table column holding the object identifier.

.Join Table
====
[source,java]
----
include::{sourcedir}/inheritance/JoinTable.java[]
----

[source,sql]
----
include::{sourcedir}/inheritance/JoinTable.sql[]
----
====

[NOTE]
====
The primary key of this table is also a foreign key to the superclass table and described by the `@PrimaryKeyJoinColumns`.

The table name still defaults to the non qualified class name.
Also if `@PrimaryKeyJoinColumn` is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass.
====

.Join Table with `@PrimaryKeyJoinColumn`
====
[source,java]
----
include::{sourcedir}/inheritance/JoinTablePrimaryKeyJoinColumn.java[]
----

[source,sql]
----
include::{sourcedir}/inheritance/JoinTablePrimaryKeyJoinColumn.sql[]
----
====

[[entity-inheritance-table-per-class]]
==== Table per class

TODO