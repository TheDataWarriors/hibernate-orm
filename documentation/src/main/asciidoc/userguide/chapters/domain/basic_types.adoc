[[basic]]
=== Basic types
:modeldir: ../../../../../main/java/org/hibernate/userguide/model
:sourcedir: ../../../../../test/java/org/hibernate/userguide/mapping
:resourcedir: ../../../../../test/resources/org/hibernate/userguide/
:converter-sourcedir: ../../../../../../../hibernate-core/src/test/java/org/hibernate/orm/test/mapping/converted/converter
:extrasdir: extras

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Strictly speaking, a basic type is denoted by the `javax.persistence.Basic` annotation.

Generally, however, the `@Basic` annotation can be ignored as it is assumed by default.  Both of the following
examples are ultimately the same.

[[basic-annotation-explicit-example]]
.`@Basic` declared explicitly
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ExplicitBasicTypeTest.java[tags=basic-annotation-explicit-example]
----
====

[[basic-annotation-implicit-example]]
.`@Basic` implied
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ImplicitBasicTypeTest.java[tags=basic-annotation-implicit-example]
----
====

The `@Basic` annotation defines 2 attributes.

`optional` - boolean (defaults to true):: Defines whether this attribute allows nulls.
   JPA defines this as "a hint", which essentially means that its effect is specifically required.
   As long as the type is not primitive, Hibernate takes this to mean that the underlying column should be `NULLABLE`.
`fetch` - FetchType (defaults to EAGER):: Defines whether this attribute should be fetched eagerly or lazily.
   JPA says that EAGER is a requirement to the provider (Hibernate) that the value should be fetched when the owner
   is fetched, while LAZY is merely a hint that the value is fetched when the attribute is accessed.  Hibernate ignores
   this setting for basic types unless you are using bytecode enhancement.  See the
   <<chapters/pc/BytecodeEnhancement.adoc#BytecodeEnhancement,Bytecode Enhancement>> for additional information on
   fetching and on bytecode enhancement.


JPA defines rules for implicitly determining the name of tables and columns.
For a detailed discussion of implicit naming see <<chapters/domain/naming.adoc#naming,Naming strategies>>.

For basic type attributes, the implicit naming rule is that the column name is the same as the attribute name.
If that implicit naming rule does not meet your requirements, you can explicitly tell Hibernate (and other providers) the column name to use.

[[basic-annotation-explicit-column-example]]
.Explicit column naming
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ExplicitColumnNamingTest.java[tags=basic-annotation-explicit-column-example]
----
====

Here we use `@Column` to explicitly map the `description` attribute to the `NOTES` column, as opposed to the
implicit column name `description`.

The `@Column` annotation defines other mapping information as well. See its Javadocs for details.


While `@Column` maps to a physical column on the database, Hibernate also allows users to map
a computed value as a kind of virtual column called a formula.  Such mappings are implicitly
read-only.

[NOTE]
====
You should be aware that the `@Formula` annotation takes a native SQL clause which may affect database portability.
====

[[mapping-column-formula-example]]
.`@Formula` mapping usage
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FormulaTest.java[tags=mapping-column-formula-example]
----
====

When loading the `Account` entity, Hibernate is going to calculate the `interest` property using the configured `@Formula`:

[[mapping-column-formula-persistence-example]]
.Persisting an entity with a `@Formula` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FormulaTest.java[tags=mapping-column-formula-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-formula-persistence-example.sql[]
----
====

[NOTE]
====
The SQL fragment defined by the `@Formula` annotation can be as complex as you want, and it can even include subselects.
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-mapping]]
==== Data mapping basics

[NOTE]
====
The following sections focus on approaches introduced in version 6 to influence how Hibernate will
map basic value to the database.

The legacy approach relying on `BasicType` and `UserType` is only lightly covered here.  However,
both `BasicType` and `UserType` continue to be fully supported.  See <<basic-legacy>> for details.
====

Basic types map a Java type to a single database column.  To deal with values of basic type, Hibernate needs to
understand a few things about the mapping:

// todo (6.0) - flesh this out
* The capabilities of the Java type
* The JDBC type it should use
* Any conversion it should perform on the value to/from the database
* The mutability of the value - whether the internal state can change like `java.util.Date` or is immutable like `java.lang.String`


Hibernate is capable of implicitly mapping many Java types as basic type.  Some of these mappings come from
the JDBC specification and Hibernate generally follows the JDBC recommended mapping in those cases.
Still others are just widely used Java types that have a reasonable mapping to a JDBC type (e.g. `URL` to `VARCHAR`).
Worst case, if the Java type is `Serializable` Hibernate will try to handle it via binary serialization.

[TIP]
====
The JPA specification strictly limits the Java types that can be marked as basic to the following:

* Java primitive types (`boolean`, `int`, etc)
* wrappers for the primitive types (`java.lang.Boolean`, `java.lang.Integer`, etc)
* `java.lang.String`
* `java.math.BigInteger`
* `java.math.BigDecimal`
* `java.time.Instant`
* `java.time.LocalDate`
* `java.time.LocalTime`
* `java.time.LocalDateTime`
* `java.time.OffsetTime`
* `java.time.OffsetDateTime`
* `java.util.Date`
* `java.util.Calendar`
* `java.sql.Date`
* `java.sql.Time`
* `java.sql.Timestamp`
* `byte[]` or `Byte[]`
* `char[]` or `Character[]`
* enums
* any other type that implements `Serializable`footnote:[JPA's support for Serializable types is to directly serialize their state to the database]

If provider portability is a concern, you should stick to just these basic types.

JPA 2.1 introduced the `javax.persistence.AttributeConverter` providing support for handling
types beyond those defined in the specification. See <<basic-jpa-convert>> for more on this topic.
====


[[basic-mapping-implicit]]
===== Implicit resolution

Looking at <<basic-annotation-implicit-example, this example>>, how does Hibernate know how to handle the various attributes
in terms of reading from and writing to the database?  The mapping does not really provide much information for
what Hibernate should do.

This is an illustration of Hibernate's implicit basic-type resolution, which is a series of checks to determine
the appropriate mapping to use.  Describing the complete process for implicit resolution is beyond the scope
of this documentationfootnote:[For details see `org.hibernate.mapping.BasicValue#resolve()`].

This is primarily driven by the Java type defined for the basic type, which can generally
be determined through reflection.

Is the Java type an enum?  Is it temporal?  These answers can indicate certain mappings be
used.

The fallback is to map the value to the "recommended" JDBC type.



[[basic-mapping-explicit]]
===== Influencing resolution

For cases where the Java type is not a baseline type or if some specialized handling is desired, Hibernate
provides many ways to influence this mapping resolution.  Ultimately we want to influence the resolution of


* `JavaTypeDescriptor` which describes capabilities of the Java type beyond what is available from just `java.lang.Class`.
   `JavaTypeDescriptor` can be influenced through `@JavaType` and `@JavaTypeRegistration`.
   `@JavaTypeRegistration` is a "global" form of `@JavaType`.
   `@MapKeyJavaType` is also available to influence the `JavaTypeDescriptor` chosen for a Map key.
* `JdbcTypeDescriptor` which describes aspects of the JDBC type such as how to read and write values.
   `JdbcTypeDescriptor` can be influenced through `@JdbcType`, `@JdbcTypeCode` and `@JdbcTypeRegistration`.
   `@JdbcTypeRegistration` is a "global" form of `@JdbcType` / `@JdbcTypeCode`.
   `@MapKeyJdbcType` and `@MapKeyJdbcTypeCode` are also available to influence the `JdbcTypeDescriptor` chosen for a Map key.
* `BasicValueConverter` which describes the conversions that need to occur when reading from or writing to the database.
   `BasicValueConverter` can be influenced by `AttributeConverter`.
   An `AttributeConverter` can be applied "globally" (`@Converter( autoApply=true )`) or locally.
* `MutabilityPlan` which describes whether values of the type are mutable (e.g. `java.util.Date`) or immutable (e.g. `java.lang.String`) -
   whether its internal state can change.
   `MutabilityPlan` can be influenced by `@Mutability` or `@Immutable`

The legacy `@Type` and `@TypeDefs` can also be used as to indicate the `BasicType` or `UserType` to use.  Refer to <<basic-legacy>>
for more details.

Note that implementations of `org.hibernate.boot.model.TypeContributor` can also be defined as a Java service
(`java.util.ServiceLoader`) to contribute a types.  This approach might be more appropriate for libraries
extending the Hibernate type system.


See <<basic-bitset-java-type>> for an example of most of these approaches to map a `BitSet`



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-nationalized]]
==== Handling nationalized character data

JDBC 4 added the ability to explicitly handle nationalized character data and added specific nationalized
character data types:

* `NCHAR`
* `NVARCHAR`
* `LONGNVARCHAR`
* `NCLOB`

Considering we have the following database table:

[[basic-nationalized-sql-example]]
.`NVARCHAR` - SQL
====
[source, JAVA, indent=0]
----
include::{extrasdir}/basic/basic-nationalized-sql-example.sql[]
----
====

To map a specific attribute to a nationalized variant data type, Hibernate defines the `@Nationalized` annotation.

[[basic-nationalized-example]]
.`NVARCHAR` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NationalizedTest.java[tags=basic-nationalized-example]
----
====


[NOTE]
====
If your application and database use nationalization, you may instead want to enable nationalized character data as the default.

You can do this via the `hibernate.use_nationalized_character_data` setting or by calling
`MetadataBuilder#enableGlobalNationalizedCharacterDataSupport` during bootstrap.
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-lob]]
==== Handling LOB data

Mapping LOBs (database Large Objects) come in 2 forms, those using the JDBC locator types and those materializing the LOB data.

JDBC LOB locators exist to allow efficient access to the LOB data.
They allow the JDBC driver to stream parts of the LOB data as needed, potentially freeing up memory space.
However, they can be unnatural to deal with and have certain limitations.
For example, a LOB locator is only portably valid during the duration of the transaction in which it was obtained.

The idea of materialized LOBs is to trade-off the potential efficiency (not all drivers handle LOB data efficiently) for a more natural
programming paradigm using familiar Java types such as `String` or `byte[]`, etc for these LOBs.

Materialized deals with the entire LOB contents in memory, whereas LOB locators (in theory) allow streaming parts of the LOB contents into memory as needed.

The JDBC LOB locator types include:

* `java.sql.Blob`
* `java.sql.Clob`
* `java.sql.NClob`

Mapping materialized forms of these LOB values would use more familiar Java types such as `String`, `char[]`, `byte[]`, etc.
The trade-off for _more familiar_ is sometimes performance.

[NOTE]
====
How JDBC deals with `LOB` data varies from driver to driver, and Hibernate tries to handle all these variances on your behalf.

However, some drivers are trickier (e.g. PostgreSQL), and, in such cases, you may have to do some extra steps to get LOBs working.
Such discussions are beyond the scope of this guide.
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-temporal]]
==== Handling temporal data

Hibernate supports mapping temporal values in numerous ways, though ultimately these strategies
boil down to the 3 main Date/Time types defined by the SQL specification:

DATE:: Represents a calendar date by storing years, months and days. The JDBC equivalent is `java.sql.Date`
TIME:: Represents the time of a day by storing hours, minutes and seconds. The JDBC equivalent is `java.sql.Time`
TIMESTAMP:: Represents both a DATE and a TIME plus nanoseconds. The JDBC equivalent is `java.sql.Timestamp`

The mapping of `java.time` temporal types to the specific SQL Date/Time types is implied as follows:

DATE:: `java.time.LocalDate`
TIME:: `java.time.LocalTime`, `java.time.OffsetTime`
TIMESTAMP:: `java.time.Instant`, `java.time.LocalDateTime`, `java.time.OffsetDateTime` and `java.time.ZonedDateTime`

[IMPORTANT]
====
Applying `@Temporal` to a `java.time` value is considered an exception
====

Although Hibernate recommends the use of the `java.time` package for representing temporal values,
it does support using `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`, `java.util.Date` and
`java.util.Calendar`.

Like the `java.time` classes, the mapping for the `java.sql` classes is also implied.  The one
exception being `Timestamp` which can be mapped to `DATE` or `TIME` using `@Temporal(DATE)` or
`@Temporal(TIME)` if desired; the other part is simply ignored.

When using the `java.util` classes, Hibernate assumes `TIMESTAMP`.  To alter that, use `@Temporal`.


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-datetime-time-zone]]
===== Using a specific time zone

By default, Hibernate is going to use the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x)`] when saving a `java.sql.Timestamp` or a `java.sql.Time` property.

When the time zone is not specified, the JDBC driver is going to use the underlying JVM default time zone, which might not be suitable if the application is used from all across the globe.
For this reason, it is very common to use a single reference time zone (e.g. UTC) whenever saving/loading data from the database.

One alternative would be to configure all JVMs to use the reference time zone:

Declaratively::
+
[source,java]
----
java -Duser.timezone=UTC ...
----

Programmatically::
+
[source,java]
----
TimeZone.setDefault( TimeZone.getTimeZone( "UTC" ) );
----

However, as explained in https://in.relation.to/2016/09/12/jdbc-time-zone-configuration-property/[this article], this is not always practical, especially for front-end nodes.
For this reason, Hibernate offers the `hibernate.jdbc.time_zone` configuration property which can be configured:

Declaratively, at the `SessionFactory` level::
+
[source,java]
----
settings.put(
    AvailableSettings.JDBC_TIME_ZONE,
    TimeZone.getTimeZone( "UTC" )
);
----

Programmatically, on a per `Session` basis::
+
[source,java]
----
Session session = sessionFactory()
    .withOptions()
    .jdbcTimeZone( TimeZone.getTimeZone( "UTC" ) )
    .openSession();
----

With this configuration property in place, Hibernate is going to call the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-java.util.Calendar-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp, Calendar cal)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-java.util.Calendar-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x, Calendar cal)`], where the `java.util.Calendar` references the time zone provided via the `hibernate.jdbc.time_zone` property.






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Start the baseline type sections
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-boolean]]
==== Boolean

Boolean values in the domain model are generally mapped to BOOLEAN/BIT on the database side depending on the
database's capabilities.

[[basic-boolean-example-implicit]]
.Implicit boolean mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-implicit]
----
====

However, it is certainly reasonable to map booleans to other representations in the
database and Hibernate provides support for mapping booleans to the more well known
representations - 'Y' / 'N', 'T' / 'F' or 1 (true) / 0 (false).

[[basic-boolean-example-converted]]
.Using `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-yes-no]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-t-f]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-numeric]
----
====

Here the built-in `AttributeConverter` implementations provided by Hibernate are used.  A custom
`AttributeConverter` could be used also.


[[basic-boolean-example-annotated]]
.Using `@BooleanMapping`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-annotated-yes-no]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-annotated-t-f]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-annotated-numeric]
----
====

Here the Hibernate `@BooleanMapping` annotation is used to specify a conversion.


[[basic-boolean-example-legacy]]
.Using `@Type`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-legacy-yes-no]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-legacy-t-f]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-legacy-numeric]
----
====

Here the legacy approach is used.


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-byte]]
==== Byte

By default, Hibernate maps values of `Byte` / `byte` to the `TINYINT` JDBC type.

[[basic-byte-example-implicit]]
.Mapping Byte
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ByteMappingTests.java[tags=basic-byte-example-implicit]
----
====


See <<basic-bytearray>> for mapping arrays of bytes.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-short]]
==== Short

By default, Hibernate maps values of `Short` / `short` to the `SMALLINT` JDBC type.

[[basic-short-example-implicit]]
.Mapping Short
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ShortMappingTests.java[tags=basic-short-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-integer]]
==== Integer

By default, Hibernate maps values of `Integer` / `int` to the `INTEGER` JDBC type.

[[basic-integer-example-implicit]]
.Mapping Integer
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/IntegerMappingTests.java[tags=basic-integer-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-long]]
==== Long

By default, Hibernate maps values of `Long` / `long` to the `BIGINT` JDBC type.

[[basic-long-example-implicit]]
.Mapping Long
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LongMappingTests.java[tags=basic-long-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-biginteger]]
==== BigInteger

By default, Hibernate maps values of `BigInteger` to the `NUMERIC` JDBC type.

[[basic-bitinteger-example-implicit]]
.Mapping BigInteger
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BigIntegerMappingTests.java[tags=basic-biginteger-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-double]]
==== Double

By default, Hibernate maps values of `Double` to the `DOUBLE`, `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database

[[basic-double-example-implicit]]
.Mapping Double
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DoubleMappingTests.java[tags=basic-double-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping-explicit>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-float]]
==== Float

By default, Hibernate maps values of `Float` to the `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database.

[[basic-float-example-implicit]]
.Mapping Float
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FloatMappingTests.java[tags=basic-float-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping-explicit>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bigdecimal]]
==== BigDecimal

By default, Hibernate maps values of `BigDecimal` to the `NUMERIC` JDBC type.

[[basic-bigdecimal-example-implicit]]
.Mapping BigDecimal
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BigDecimalMappingTests.java[tags=basic-bigdecimal-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-character]]
==== Character




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-String]]
==== String




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-chararray]]
==== Character array



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-clob]]
==== Clob / NClob

[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling and <<basic-nationalized>> which covers basics
of nationalized data handling.
====

By default, Hibernate will map the `java.sql.Clob` Java type to `CLOB` and `java.sql.NClob` to `NCLOB`.

Considering we have the following database table:

[[basic-clob-sql-example]]
.CLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-clob-sql-example.sql[]
----
====

Let's first map this using the `@Lob` JPA annotation and the `java.sql.Clob` type:

[[basic-clob-example]]
.`CLOB` mapped to `java.sql.Clob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-example]
----
====

To persist such an entity, you have to create a `Clob` using the `ClobProxy` Hibernate utility:

[[basic-clob-persist-example]]
.Persisting a `java.sql.Clob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-persist-example]
----
====

To retrieve the `Clob` content, you need to transform the underlying `java.io.Reader`:

[[basic-clob-find-example]]
.Returning a `java.sql.Clob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-find-example]
----
====

We could also map the CLOB in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-clob-string-example]]
.`CLOB` mapped to `String`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobStringTest.java[tags=basic-clob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-clob-char-array-example]]
.CLOB - materialized `char[]` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobCharArrayTest.java[tags=basic-clob-char-array-example]
----
====

Just like with `CLOB`, Hibernate can also deal with `NCLOB` SQL data types:

[[basic-nclob-sql-example]]
.`NCLOB` - SQL
====
[source, JAVA, indent=0]
----
include::{extrasdir}/basic/basic-nclob-sql-example.sql[]
----
====

Hibernate can map the `NCLOB` to a `java.sql.NClob`

[[basic-nclob-example]]
.`NCLOB` mapped to `java.sql.NClob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-example]
----
====

To persist such an entity, you have to create an `NClob` using the `NClobProxy` Hibernate utility:

[[basic-nclob-persist-example]]
.Persisting a `java.sql.NClob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-persist-example]
----
====

To retrieve the `NClob` content, you need to transform the underlying `java.io.Reader`:

[[basic-nclob-find-example]]
.Returning a `java.sql.NClob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-find-example]
----
====

We could also map the `NCLOB` in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-nclob-string-example]]
.`NCLOB` mapped to `String`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobStringTest.java[tags=basic-nclob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-nclob-char-array-example]]
.NCLOB - materialized `char[]` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobCharArrayTest.java[tags=basic-nclob-char-array-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bytearray]]
==== Byte array




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-blob]]
==== Blob


[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling.
====

By default, Hibernate will map the `java.sql.Blob` Java type to `BLOB`.

Considering we have the following database table:

[[basic-blob-sql-example]]
.BLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-blob-sql-example.sql[]
----
====

Let's first map this using the JDBC `java.sql.Blob` type.

[[basic-blob-example]]
.`BLOB` mapped to `java.sql.Blob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-example]
----
====

To persist such an entity, you have to create a `Blob` using the `BlobProxy` Hibernate utility:

[[basic-blob-persist-example]]
.Persisting a `java.sql.Blob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-persist-example]
----
====

To retrieve the `Blob` content, you need to transform the underlying `java.io.InputStream`:

[[basic-blob-find-example]]
.Returning a `java.sql.Blob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-find-example]
----
====

We could also map the BLOB in a materialized form (e.g. `byte[]`).

[[basic-blob-byte-array-example]]
.`BLOB` mapped to `byte[]`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobByteArrayTest.java[tags=basic-blob-byte-array-example]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Duration



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Instant

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDate

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDateTime

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalTime

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetDateTime

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetTime

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== TimeZone






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZonedDateTime

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZoneOffset





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Calendar

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====








// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Date

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Time

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====








// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Timestamp

[NOTE]
====
See <<basic-temporal>> for basics of temporal mapping
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Class

==== Currency
==== Locale



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-uuid]]
==== UUID

Hibernate allows mapping UUID values in a number of ways.  By default, Hibernate will
store UUID values in their binary form.


[NOTE]
====
The default uses the binary representation because it uses a more efficient column storage.

However, many applications prefer the readability of the character-based column storage.

// todo (6.0) : develop a better way to expose this to users
To switch the default mapping, simply call `MetadataBuilder.applyBasicType( UUIDCharType.INSTANCE, UUID.class.getName() )`.
====

===== UUID as binary

As mentioned, the default mapping for UUID attributes.
Maps the UUID to a `byte[]` using `java.util.UUID#getMostSignificantBits` and `java.util.UUID#getLeastSignificantBits` and stores that as `BINARY` data.

Chosen as the default simply because it is generally more efficient from a storage perspective.

===== UUID as (var)char

Maps the UUID to a String using `java.util.UUID#toString` and `java.util.UUID#fromString` and stores that as `CHAR` or `VARCHAR` data.

===== PostgreSQL-specific UUID

[IMPORTANT]
====
When using one of the PostgreSQL Dialects, the PostgreSQL-specific UUID Hibernate type becomes the default UUID mapping.
====

Maps the UUID using the PostgreSQL-specific UUID data type.
The PostgreSQL JDBC driver chooses to map its UUID type to the `OTHER` code.
Note that this can cause difficulty as the driver chooses to map many different data types to `OTHER`.

===== UUID as identifier

Hibernate supports using UUID values as identifiers, and they can even be generated on the user's behalf.
For details, see the discussion of generators in <<chapters/domain/identifiers.adoc#identifiers,_Identifiers_>>.






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-enums]]
==== Mapping enums

Hibernate supports the mapping of Java enums as basic value types in a number of different ways.

[[basic-enums-Enumerated]]
===== `@Enumerated`

The original JPA-compliant way to map enums was via the `@Enumerated` or `@MapKeyEnumerated`  annotations, working on the principle that the enum values are stored according to one of 2 strategies indicated by `javax.persistence.EnumType`:

`ORDINAL`::
stored according to the enum value's ordinal position within the enum class, as indicated by `java.lang.Enum#ordinal`
`STRING`::
stored according to the enum value's name, as indicated by `java.lang.Enum#name`

Assuming the following enumeration:

.`PhoneType` enumeration
====
[source, JAVA, indent=0]
----
include::{modeldir}/PhoneType.java[tags=hql-examples-domain-model-example]
----
====

In the ORDINAL example, the `phone_type` column is defined as a (nullable) INTEGER type and would hold:

`NULL`:: For null values
`0`:: For the `LAND_LINE` enum
`1`:: For the `MOBILE` enum

[[basic-enums-Enumerated-ordinal-example]]
.`@Enumerated(ORDINAL)` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-example]
----
====

When persisting this entity, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-ordinal-persistence-example]]
.Persisting an entity with an `@Enumerated(ORDINAL)` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-ordinal-persistence-example.sql[]
----
====

In the STRING example, the `phone_type` column is defined as a (nullable) VARCHAR type and would hold:

`NULL`:: For null values
`LAND_LINE`:: For the `LAND_LINE` enum
`MOBILE`:: For the `MOBILE` enum

[[basic-enums-Enumerated-string-example]]
.`@Enumerated(STRING)` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedStringTest.java[tags=basic-enums-Enumerated-string-example]
----
====

Persisting the same entity as in the `@Enumerated(ORDINAL)` example, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-string-persistence-example]]
.Persisting an entity with an `@Enumerated(STRING)` mapping
====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-string-persistence-example.sql[]
----
====

[[basic-enums-attribute-converter]]
===== Using AttributeConverter

Let's consider the following `Gender` enum which stores its values using the `'M'` and `'F'` codes.

[[basic-enums-converter-example]]
.Enum with a custom constructor
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/Gender.java[tags=basic-enums-converter-example]
----
====

You can map enums in a JPA compliant way using a JPA 2.1 AttributeConverter.

[[basic-enums-attribute-converter-example]]
.Enum mapping with `AttributeConverter` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/EnumerationConverterTest.java[tags=basic-enums-attribute-converter-example]
----
====

Here, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using AttributeConverters, see <<basic-jpa-convert>> section.

[NOTE]
====
JPA explicitly disallows the use of an `AttributeConverter` with an attribute marked as `@Enumerated`.

So, when using the `AttributeConverter` approach, be sure not to mark the attribute as `@Enumerated`.
====



[[basic-enums-custom-type]]
===== Custom type

You can also map enums using a Hibernate custom type mapping.
Let's again revisit the Gender enum example, this time using a custom Type to store the more standardized `'M'` and `'F'` codes.

[[basic-enums-custom-type-example]]
.Enum mapping with custom Type example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/EnumerationCustomTypeTest.java[tags=basic-enums-custom-type-example, indent=0]

include::{sourcedir}/basic/GenderType.java[tags=basic-enums-custom-type-example, indent=0]

include::{sourcedir}/basic/GenderJavaTypeDescriptor.java[tags=basic-enums-custom-type-example, indent=0]
----
====

Again, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using custom types, see <<basic-custom-type>> section.



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-type-contributor]]
==== TypeContributor

// todo (6.0) : add doc

yadda yadda yadda




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bitset]]
==== Custom Java types

There are many ways to map Java types other than those covered so far.

In this section, we will use the `java.util.BitSet` type as an example and map that
using different approaches.

[[basic-bitset-example-implicit]]
.Implicit BitSet mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetImplicitTests.java[tags=basic-bitset-example-implicit]
----
====

As mentioned previously, the worst-case fallback for Hibernate mapping a basic type
which implements `Serializable` is to simply serialize it to the database.  BitSet
does implement `Serializable`, so by default Hibernate would handle this mapping by serialization

In the following sections we will look at approaches to change various aspects of how
the BitSet gets mapped to the database.


[[basic-bitset-converter]]
===== Using `AttributeConverter`

We've seen uses of `AttributeConverter` previously.

This works well in most cases and is portable across JPA providers.

[[basic-bitset-example-converter]]
.BitSet AttributeConverter
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetConverterTests.java[tags=basic-bitset-example-convert]

include::{sourcedir}/basic/BitSetConverterTests.java[tags=basic-bitset-example-converter]
----
====

The `@Convert` annotation was used for illustration.  Generally such a converter would be auto-applied instead

See <<basic-jpa-convert>> for details.

[NOTE]
====
The use of `AttributeConverter` can have drawbacks related to Hibernate being able
to appropriately handle the mutability aspects of the converted values. `AttributeConverter`
does not indicate whether the converted values are mutable or not, so Hibernate has to assume
they are (the safer assumption) which can lead to excessive conversions back and forth as part
of dirty-checking as well as second-level caching.

See <<basic-jpa-convert-mutability>> for additional details.
====


[[basic-bitset-java-type]]
===== Using a custom `JavaTypeDescriptor`

As covered in <<basic-mapping-explicit>>, any of the following can be used to specify
the `JavaTypeDescriptor` to use:

   * `@JavaTypeRegistration`
   * `@JavaType`
   * `@MapKeyJavaType`
   * `TypeContributor`

We will skip discussing `@MapKeyJavaType` because it is redundant with discussing `@JavaType`.  We will
also skip discussing using `TypeContributor` as it is discussed in <<basic-type-contributor>>.

First we will define a `JavaTypeDescriptor` for `BitSet` that maps values to `VARCHAR` for storage by default.

[[basic-bitset-example-java-type]]
.BitSet JavaTypeDescriptor
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaType.java[tags=basic-bitset-example-java-type]
----
====


We can either apply that type locally using `@JavaType`

[[basic-bitset-example-java-type-local]]
.@JavaType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaTypeTests.java[tags=basic-bitset-example-java-type-local,indent=0]
----
====

Or we can apply it globally using `@JavaTypeRegistration`

[[basic-bitset-example-java-type-global]]
.@JavaTypeRegistration
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaTypeRegistrationTests.java[tags=basic-bitset-example-java-type-global,indent=0]
----
====


[[basic-bitset-jdbc-type]]
===== Selecting different `JdbcTypeDescriptor`

As covered in <<basic-mapping-explicit>>, any of the following can be used to specify
the `JdbcTypeDescriptor` to use:

* `@JdbcTypeRegistration`
* `@JdbcType`
* `@JdbcTypeCode`
* `@MapKeyJdbcType`
* `@MapKeyJdbcTypeCode`
* `TypeContributor`

We will skip discussing `@MapKeyJdbcType` and `@MapKeyJdbcTypeCode` because they are redundant with
discussing `@JdbcType` and `@JdbcTypeCode`.  We will also skip discussing using `TypeContributor` as
it is discussed in <<basic-type-contributor>>.

Our custom `BitSetJavaType` class already has support for being able to map `BitSet` values as binary
data as well through its coercion support.

The following examples for specifying the `JdbcTypeDescriptor` assume our `BitSetJavaType`
is globally registered.

We will again store the values as `VARBINARY` in the database.  The difference now however is that
the coercion methods `#wrap` and `#unwrap` will be used to prepare the value rather than relying on
serialization.


[[basic-bitset-example-jdbc-type-code]]
.@JdbcTypeCode
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeCodeTests.java[tags=basic-bitset-example-jdbc-type-code,indent=0]
----
====

In this example, `@JdbcTypeCode` has been used to indicate that the `JdbcTypeDescriptor` registered for JDBC's
`VARBINARY` type should be used.

A specific `JdbcTypeDescriptor` implementation can be specified either locally using `@JdbcType` or
globally using `@JdbcTypeRegistration`


[[basic-bitset-example-jdbc-type-local]]
.@JdbcType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeTests.java[tags=basic-bitset-example-jdbc-type-local,indent=0]
----
====

In this example, `@JdbcType` has been used to specify our custom `BitSetJdbcType` descriptor locally for
this attribute.

We could instead replace how Hibernate deals with all `VARBINARY` handling with our custom impl using
`@JdbcTypeRegistration`

[[basic-bitset-example-jdbc-type-global]]
.@JdbcType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeRegistrationTests.java[tags=basic-bitset-example-jdbc-type-global,indent=0]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-jpa-convert]]
==== AttributeConverters

Although Hibernate has long been offering <<basic-custom-type,custom types>>, as a JPA 2.1 provider,
it also supports `AttributeConverter` as well.

With a custom `AttributeConverter`, the application developer can map a given JDBC type to an entity basic type.

In the following example, the `java.time.Period` is going to be mapped to a `VARCHAR` database column.

[[basic-jpa-convert-period-string-converter-example]]
.`java.time.Period` custom `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringConverter.java[tags=basic-jpa-convert-period-string-converter-example]
----
====

To make use of this custom converter, the `@Convert` annotation must decorate the entity attribute.

[[basic-jpa-convert-period-string-converter-mapping-example]]
.Entity using the custom `java.time.Period` `AttributeConverter` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----
====

When persisting such entity, Hibernate will do the type conversion based on the `AttributeConverter` logic:

[[basic-jpa-convert-period-string-converter-sql-example]]
.Persisting entity using the custom `AttributeConverter`
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-jpa-convert-period-string-converter-sql-example.sql[]
----
====

[[basic-jpa-convert-type]]
===== `AttributeConverter` Java and JDBC types

In cases when the Java type specified for the "database side" of the conversion (the second `AttributeConverter` bind parameter) is not known,
Hibernate will fallback to a `java.io.Serializable` type.

If the Java type is not known to Hibernate, you will encounter the following message:

> HHH000481: Encountered Java type for which we could not locate a JavaTypeDescriptor and which does not appear to implement equals and/or hashCode.
> This can lead to significant performance problems when performing equality/dirty checking involving this Java type.
> Consider registering a custom JavaTypeDescriptor or at least implementing equals/hashCode.

A Java type is "known" if it has an entry in the `JavaTypeDescriptorRegistry`.  While Hibernate does load many JDK types into
the `JavaTypeDescriptorRegistry`, an application can also expand the `JavaTypeDescriptorRegistry` by adding new `JavaTypeDescriptor`
entries.  This way, Hibernate will also know how to handle a specific Java Object type at the JDBC level.




[[basic-hbm-attribute-converter]]
===== Mapping an AttributeConverter using HBM mappings

When using HBM mappings, you can still make use of the JPA `AttributeConverter` because Hibernate supports
such mapping via the `type` attribute as demonstrated by the following example.

Let's consider we have an application-specific `Money` type:

[[basic-hbm-attribute-converter-mapping-money-example]]
.Application-specific `Money` type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/Money.java[tags=basic-hbm-attribute-converter-mapping-money-example]
----
====

Now, we want to use the `Money` type when mapping the `Account` entity:

[[basic-hbm-attribute-converter-mapping-account-example]]
.`Account` entity using the `Money` type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/Account.java[tags=basic-hbm-attribute-converter-mapping-account-example]
----
====

Since Hibernate has no knowledge how to persist the `Money` type, we could use a JPA `AttributeConverter`
to transform the `Money` type as a `Long`. For this purpose, we are going to use the following
`MoneyConverter` utility:

[[basic-hbm-attribute-converter-mapping-moneyconverter-example]]
.`MoneyConverter` implementing the JPA `AttributeConverter` interface
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/MoneyConverter.java[tags=basic-hbm-attribute-converter-mapping-moneyconverter-example]
----
====

To map the `MoneyConverter` using HBM configuration files you need to use the `converted::` prefix in the `type`
attribute of the `property` element.

[[basic-hbm-attribute-converter-mapping-xml-config-example]]
.HBM mapping for `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{resourcedir}/mapping/converter/hbm/MoneyConverterHbmTest.hbm.xml[]
----
====




[[basic-jpa-convert-mutability]]
===== `AttributeConverter` Mutability Plan

A basic type that's converted by a JPA `AttributeConverter` is immutable if the underlying Java type is immutable
and is mutable if the associated attribute type is mutable as well.

Therefore, mutability is given by the https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/type/descriptor/java/JavaTypeDescriptor.html#getMutabilityPlan--[`JavaTypeDescriptor#getMutabilityPlan`]
of the associated entity attribute type.

// todo (6.0) : discuss `@Immutable` and `@Mutability`


====== Immutable types

If the entity attribute is a `String`, a primitive wrapper (e.g. `Integer`, `Long`) an Enum type, or any other immutable `Object` type,
then you can only change the entity attribute value by reassigning it to a new value.

Considering we have the same `Period` entity attribute as illustrated in the <<basic-jpa-convert>> section:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----

The only way to change the `span` attribute is to reassign it to a different value:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-immutability-plan-example]
----

====== Mutable types

On the other hand, consider the following example where the `Money` type is a mutable.

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mapping-example]
----

A mutable `Object` allows you to modify its internal structure, and Hibernate dirty checking mechanism is going to propagate the change to the database:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mutability-plan-example]
----

[TIP]
====
Although the `AttributeConverter` types can be mutable so that dirty checking, deep copying, and second-level caching work properly,
treating these as immutable (when they really are) is more efficient.

For this reason, prefer immutable types over mutable ones whenever possible.
====



[[basic-attribute-converter-query-parameter]]
====== Using the AttributeConverter entity property as a query parameter

Assuming you have the following entity:

[[basic-attribute-converter-query-parameter-entity-example]]
.`Photo` entity with `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-entity-example]
----
====

And the `Caption` class looks as follows:

[[basic-attribute-converter-query-parameter-object-example]]
.`Caption` Java object
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-object-example]
----
====

And we have an `AttributeConverter` to handle the `Caption` Java object:

[[basic-attribute-converter-query-parameter-converter-example]]
.`Caption` Java object AttributeConverter
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-example]
----
====

Traditionally, you could only use the DB data `Caption` representation, which in our case is a `String`, when referencing the `caption` entity property.

[[basic-attribute-converter-query-parameter-converter-dbdata-example]]
.Filtering by the `Caption` property using the DB data representation
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-dbdata-example]
----
====

In order to use the Java object `Caption` representation, you have to get the associated Hibernate `Type`.

[[basic-attribute-converter-query-parameter-converter-object-example]]
.Filtering by the `Caption` property using the Java Object representation
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-object-example]
----
====

By passing the associated Hibernate `Type`, you can use the `Caption` object when binding the query parameter value.









// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[[mapping-quoted-identifiers]]
==== SQL quoted identifiers

You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document.
While traditionally, Hibernate used backticks for escaping SQL reserved keywords, JPA uses double quotes instead.

Once the reserved keywords are escaped, Hibernate will use the correct quotation style for the SQL `Dialect`.
This is usually double quotes, but SQL Server uses brackets and MySQL uses backticks.

[[basic-quoting-example]]
.Hibernate legacy quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/QuotingTest.java[tags=basic-quoting-example]
----
====

[[basic-jpa-quoting-example]]
.JPA quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/JpaQuotingTest.java[tags=basic-jpa-quoting-example]
----
====

Because `name` and `number` are reserved words, the `Product` entity mapping uses backticks to quote these column names.

When saving the following `Product entity`, Hibernate generates the following SQL insert statement:

[[basic-quoting-persistence-example]]
.Persisting a quoted column name
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/QuotingTest.java[tags=basic-quoting-persistence-example, indent=0]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-quoting-persistence-example.sql[indent=0]
----
====

[[mapping-global-quoted-identifiers]]
===== Global quoting

Hibernate can also quote all identifiers (e.g. table, columns) using the following configuration property:

====
[source,xml]
----
<property
    name="hibernate.globally_quoted_identifiers"
    value="true"
/>
----
====

This way, we don't need to manually quote any identifier:

[[basic-auto-quoting-example]]
.JPA quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/AutoQuotingTest.java[tags=basic-auto-quoting-example]
----
====

When persisting a `Product` entity, Hibernate is going to quote all identifiers as in the following example:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-auto-quoting-persistence-example.sql[indent=0]
----
====

As you can see, both the table name and all the column have been quoted.

For more about quoting-related configuration properties, check out the <<appendices/Configurations.adoc#configurations-mapping,Mapping configurations>> section as well.




















[[mapping-generated]]
==== Generated properties

Generated properties are properties that have their values generated by the database.
Typically, Hibernate applications needed to `refresh` objects that contain any properties for which the database was generating values.
Marking properties as generated, however, lets the application delegate this responsibility to Hibernate.
When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select to retrieve the generated values.

Properties marked as generated must additionally be _non-insertable_ and _non-updateable_.
Only `@Version` and `@Basic` types can be marked as generated.

`NEVER` (the default):: the given property value is not generated within the database.
`INSERT`:: the given property value is generated on insert but is not regenerated on subsequent updates. Properties like _creationTimestamp_ fall into this category.
`ALWAYS`:: the property value is generated both on insert and update.

To mark a property as generated, use The Hibernate specific `@Generated` annotation.

[[mapping-generated-Generated]]
===== `@Generated` annotation

The https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/Generated.html[`@Generated`] annotation is used so that Hibernate can fetch the currently annotated property after the entity has been persisted or updated.
For this reason, the `@Generated` annotation accepts a https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/GenerationTime.html[`GenerationTime`] enum value.

Considering the following entity:

[[mapping-generated-Generated-example]]
.`@Generated` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-Generated-example]
----
====

When the `Person` entity is persisted, Hibernate is going to fetch the calculated `fullName` column from the database,
which concatenates the first, middle, and last name.

[[mapping-generated-Generated-persist-example]]
.`@Generated` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-Generated-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-Generated-persist-example.sql[]
----
====

The same goes when the `Person` entity is updated.
Hibernate is going to fetch the calculated `fullName` column from the database after the entity is modified.

[[mapping-generated-Generated-update-example]]
.`@Generated` update example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-Generated-update-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-Generated-update-example.sql[]
----
====

[[mapping-generated-GeneratorType]]
===== `@GeneratorType` annotation

The https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/GeneratorType.html[`@GeneratorType`] annotation is used so that
you can provide a custom generator to set the value of the currently annotated property.

For this reason, the `@GeneratorType` annotation accepts a https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/GenerationTime.html[`GenerationTime`] enum value
and a custom https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/ValueGenerator.html[`ValueGenerator`] class type.

Considering the following entity:

[[mapping-generated-GeneratorType-example]]
.`@GeneratorType` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratorTypeTest.java[tags=mapping-generated-GeneratorType-example]
----
====

When the `Person` entity is persisted, Hibernate is going to populate the `createdBy` column with the currently logged user.

[[mapping-generated-GeneratorType-persist-example]]
.`@GeneratorType` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratorTypeTest.java[tags=mapping-generated-GeneratorType-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-GeneratorType-persist-example.sql[]
----
====

The same goes when the `Person` entity is updated.
Hibernate is going to populate the `updatedBy` column with the currently logged user.

[[mapping-generated-GeneratorType-update-example]]
.`@GeneratorType` update example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratorTypeTest.java[tags=mapping-generated-GeneratorType-update-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-GeneratorType-update-example.sql[]
----
====

[[mapping-generated-CreationTimestamp]]
===== `@CreationTimestamp` annotation

The `@CreationTimestamp` annotation instructs Hibernate to set the annotated entity attribute with the current timestamp value of the JVM
when the entity is being persisted.

The supported property types are:

- `java.util.Date`
- `java.util.Calendar`
- `java.sql.Date`
- `java.sql.Time`
- `java.sql.Timestamp`

[[mapping-generated-CreationTimestamp-example]]
.`@CreationTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/CreationTimestampTest.java[tags=mapping-generated-CreationTimestamp-example]
----
====

When the `Event` entity is persisted, Hibernate is going to populate the underlying `timestamp` column with the current JVM timestamp value:

[[mapping-generated-CreationTimestamp-persist-example]]
.`@CreationTimestamp` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/CreationTimestampTest.java[tags=mapping-generated-CreationTimestamp-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-CreationTimestamp-persist-example.sql[]
----
====

[[mapping-generated-UpdateTimestamp]]
===== `@UpdateTimestamp` annotation

The `@UpdateTimestamp` annotation instructs Hibernate to set the annotated entity attribute with the current timestamp value of the JVM
when the entity is being persisted.

The supported property types are:

- `java.util.Date`
- `java.util.Calendar`
- `java.sql.Date`
- `java.sql.Time`
- `java.sql.Timestamp`

[[mapping-generated-UpdateTimestamp-example]]
.`@UpdateTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-UpdateTimestamp-example]
----
====

When the `Bid` entity is persisted, Hibernate is going to populate the underlying `updated_on` column with the current JVM timestamp value:

[[mapping-generated-UpdateTimestamp-persist-example]]
.`@UpdateTimestamp` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-UpdateTimestamp-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-UpdateTimestamp-persist-example.sql[]
----
====

When updating the `Bid` entity, Hibernate is going to modify the `updated_on` column with the current JVM timestamp value:

[[mapping-generated-UpdateTimestamp-update-example]]
.`@UpdateTimestamp` update example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-UpdateTimestamp-update-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-UpdateTimestamp-update-example.sql[]
----
====

[[mapping-generated-ValueGenerationType]]
===== `@ValueGenerationType` meta-annotation

Hibernate 4.3 introduced the `@ValueGenerationType` meta-annotation, which is a new approach to declaring generated attributes or customizing generators.

`@Generated` has been retrofitted to use the `@ValueGenerationType` meta-annotation.
But `@ValueGenerationType` exposes more features than what `@Generated` currently supports, and,
to leverage some of those features, you'd simply wire up a new generator annotation.

As you'll see in the following examples, the `@ValueGenerationType` meta-annotation is used when declaring the custom annotation used to mark the entity properties that need a specific generation strategy.
The actual generation logic must be added to the class that implements the `AnnotationValueGeneration` interface.

[[mapping-database-generated-value]]
====== Database-generated values

For example, let's say we want the timestamps to be generated by calls to the standard ANSI SQL function `current_timestamp` (rather than triggers or DEFAULT values):

[[mapping-database-generated-value-example]]
.A `ValueGenerationType` mapping for database generation
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/DatabaseValueGenerationTest.java[tags=mapping-database-generated-value-example]
----
====

When persisting an `Event` entity, Hibernate generates the following SQL statement:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-database-generated-value-example.sql[]
----
====

As you can see, the `current_timestamp` value was used for assigning the `timestamp` column value.

[[mapping-in-memory-generated-value]]
====== In-memory-generated values

If the timestamp value needs to be generated in-memory, the following mapping must be used instead:

[[mapping-in-memory-generated-value-example]]
.A `ValueGenerationType` mapping for in-memory value generation
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/InMemoryValueGenerationTest.java[tags=mapping-in-memory-generated-value-example]
----
====

When persisting an `Event` entity, Hibernate generates the following SQL statement:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-in-memory-generated-value-example.sql[]
----
====

As you can see, the `new Date()` object value was used for assigning the `timestamp` column value.





























[[mapping-column-read-and-write]]
==== Column transformers: read and write expressions

Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to `@Basic` types.
For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like in the following example.

[[mapping-column-read-and-write-example]]
.`@ColumnTransformer` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/../fetching/FetchingTest.java[tags=mapping-column-read-and-write-example]
----
====

If a property uses more than one column, you must use the `forColumn` attribute to specify which column the `@ColumnTransformer` read and write expressions are targeting.

[[mapping-column-read-and-write-composite-type-example]]
.`@ColumnTransformer` `forColumn` attribute usage
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-example]
----
====

Hibernate applies the custom expressions automatically whenever the property is referenced in a query.
This functionality is similar to a derived-property <<mapping-column-formula>> with two differences:

* The property is backed by one or more columns that are exported as part of automatic schema generation.
* The property is read-write, not read-only.

The `write` expression, if specified, must contain exactly one '?' placeholder for the value.

[[mapping-column-read-and-write-composite-type-persistence-example]]
.Persisting an entity with a `@ColumnTransformer` and a composite type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-read-and-write-composite-type-persistence-example.sql[]
----
====






