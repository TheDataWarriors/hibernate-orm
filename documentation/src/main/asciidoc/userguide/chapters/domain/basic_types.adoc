[[basic]]
=== Basic types
:rootProjectDir: ../../../../../../..
:documentationProjectDir: {rootProjectDir}/documentation
:coreProjectDir: {rootProjectDir}/hibernate-core
:core-generated-test-dir: {coreProjectDir}/src/test/java/org/hibernate/orm/test/mapping/generated
:modeldir: {documentationProjectDir}/src/main/java/org/hibernate/userguide/model
:sourcedir: {documentationProjectDir}/src/test/java/org/hibernate/userguide/mapping
:resourcedir: {documentationProjectDir}/src/test/resources/org/hibernate/userguide/
:converter-sourcedir: {coreProjectDir}/src/test/java/org/hibernate/orm/test/mapping/converted/converter
:extrasdir: extras

A basic type is a mapping between a Java type and a single database column.

Hibernate can map many standard Java types (`Integer`, `String`, etc.) as basic
types.  The mapping for many come from tables B-3 and B-4 in the JDBC specification<<jdbc>>.
Others (`URL` as `VARCHAR`, e.g.) simply make sense.

Additionally, Hibernate provides multiple, flexible ways to indicate how the Java type
should be mapped to the database.


[TIP]
====
The Jakarta Persistence specification strictly limits the Java types that can be marked as basic to the following:

* Java primitive types (`boolean`, `int`, etc)
* wrappers for the primitive types (`java.lang.Boolean`, `java.lang.Integer`, etc)
* `java.lang.String`
* `java.math.BigInteger`
* `java.math.BigDecimal`
* `java.time.Instant`
* `java.time.LocalDate`
* `java.time.LocalTime`
* `java.time.LocalDateTime`
* `java.time.OffsetTime`
* `java.time.OffsetDateTime`
* `java.util.Date`
* `java.util.Calendar`
* `java.sql.Date`
* `java.sql.Time`
* `java.sql.Timestamp`
* `byte[]` or `Byte[]`
* `char[]` or `Character[]`
* enums
* any other type that implements `Serializable`footnote:[Jakarta Persistence's support for Serializable types is to directly serialize their state to the database]

If provider portability is a concern, you should stick to just these basic types.

Java Persistence 2.1 introduced the `jakarta.persistence.AttributeConverter` providing support for handling
types beyond those defined in the specification. See <<basic-jpa-convert>> for more on this topic.
====


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-basic-annotation]]
==== @Basic

Strictly speaking, a basic type is denoted by the `jakarta.persistence.Basic` annotation.

Generally, the `@Basic` annotation can be ignored as it is assumed by default.  Both of the following
examples are ultimately the same.

[[basic-annotation-explicit-example]]
.`@Basic` declared explicitly
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ExplicitBasicTypeTest.java[tags=basic-annotation-explicit-example]
----
====

[[basic-annotation-implicit-example]]
.`@Basic` implied
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ImplicitBasicTypeTest.java[tags=basic-annotation-implicit-example]
----
====

The `@Basic` annotation defines 2 attributes.

`optional` - boolean (defaults to true):: Defines whether this attribute allows nulls.  Jakarta Persistence defines
    this as "a hint", which means the provider is free to ignore it.  Jakarta Persistence also says that it will be
    ignored if the type is primitive.  As long as the type is not primitive, Hibernate will honor this
    value.  Works in conjunction with `@Column#nullable` - see <<basic-column-annotation>>.
`fetch` - FetchType (defaults to EAGER):: Defines whether this attribute should be fetched eagerly or lazily.
    `EAGER` indicates that the value will be fetched as part of loading the owner.  `LAZY` values are
    fetched only when the value is accessed.  Jakarta Persistence requires providers to support `EAGER`, while support for
    `LAZY` is optional meaning that a provider is free to not support it.  Hibernate supports lazy loading
    of basic values as long as you are using its <<chapters/pc/BytecodeEnhancement.adoc#BytecodeEnhancement,bytecode enhancement>>
    support.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-column-annotation]]
==== @Column

Jakarta Persistence defines rules for implicitly determining the name of tables and columns.
For a detailed discussion of implicit naming see <<chapters/domain/naming.adoc#naming,Naming strategies>>.

For basic type attributes, the implicit naming rule is that the column name is the same as the attribute name.
If that implicit naming rule does not meet your requirements, you can explicitly tell Hibernate (and other providers) the column name to use.

[[basic-annotation-explicit-column-example]]
.Explicit column naming
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ExplicitColumnNamingTest.java[tags=basic-annotation-explicit-column-example]
----
====

Here we use `@Column` to explicitly map the `description` attribute to the `NOTES` column, as opposed to the
implicit column name `description`.

The `@Column` annotation defines other mapping information as well. See its Javadocs for details.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-formula-annotation]]
==== @Formula

`@Formula` allows mapping any database computed value as a virtual read-only column.

[NOTE]
====
The `@Formula` annotation takes a native SQL clause which may affect database portability.
====

[[mapping-column-formula-example]]
.`@Formula` mapping usage
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FormulaTest.java[tags=mapping-column-formula-example]
----
====

When loading the `Account` entity, Hibernate is going to calculate the `interest` property using the configured `@Formula`:

[[mapping-column-formula-persistence-example]]
.Persisting an entity with a `@Formula` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FormulaTest.java[tags=mapping-column-formula-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-formula-persistence-example.sql[]
----
====

[NOTE]
====
The SQL fragment defined by the `@Formula` annotation can be as complex as you want, and it can even include subselects.
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-mapping]]
==== Mapping basic values

To deal with values of basic type, Hibernate needs to understand a few things about the mapping:

* The capabilities of the Java type.  For example:
** How to compare values
** How to calculate a hash-code
** How to coerce values of this type to another type
* The JDBC type it should use
** How to bind values to JDBC statements
** How to extract from JDBC results
* Any conversion it should perform on the value to/from the database
* The mutability of the value - whether the internal state can change like `java.util.Date` or is immutable like `java.lang.String`

This section covers how Hibernate determines these pieces and how to influence that determination process.

[NOTE]
====
The following sections focus on approaches introduced in version 6 to influence how Hibernate will
map basic value to the database.

This includes removal of the following deprecated legacy annotations:

* `@Type`
* `@TypeDef`
* `@TypeDefs`
* `@MapKeyType`
* `@CollectionId#type`
* `@AnyMetaDef#metaType`
* `@AnyMetaDef#idType`

See the 6.0 migration guide for discussions about migrating uses of these annotations
====


Looking at <<basic-annotation-implicit-example, this example>>, how does Hibernate know what mapping
to use for these attributes?  The annotations do not really provide much information.

This is an illustration of Hibernate's implicit basic-type resolution, which is a series of checks to determine
the appropriate mapping to use.  Describing the complete process for implicit resolution is beyond the scope
of this documentationfootnote:[For details see `org.hibernate.mapping.BasicValue#resolve()`].

This is primarily driven by the Java type defined for the basic type, which can generally
be determined through reflection.  Is the Java type an enum?  Is it temporal?  These answers
can indicate certain mappings be used.

The fallback is to map the value to the "recommended" JDBC type.

Worst case, if the Java type is `Serializable` Hibernate will try to handle it via binary serialization.

For cases where the Java type is not a standard type or if some specialized handling is desired, Hibernate
provides 2 main approaches to influence this mapping resolution:

* A compositional approach using a combination of one-or-more annotations to describe specific
    aspects of the mapping.  This approach is covered in <<basic-mapping-composition>>.
* The `UserType` contract, which is covered in <<basic-mapping-custom>>

These 2 approaches should be considered mutually exclusive.  A custom UserType will always
take precedence over compositional annotations.

See <<basic-type-contributor>> for an alternative to `@JavaTypeRegistration` and `@JdbcTypeRegistration`.

See <<basic-bitset-java-type>> for examples of most of these approaches, mapping `BitSet` as a basic type.


[[basic-mapping-composition]]
==== Compositional basic mapping

The compositional approach allows defining how the mapping should work in terms of influencing
individual, basic-valued parts of the model:


`JavaTypeDescriptor`:: Describes capabilities of the Java type as discussed in <<basic>>.  The descriptor
    used can be influenced through `@JavaType` and `@JavaTypeRegistration`.  `@JavaTypeRegistration` is a global
    form of `@JavaType`.
`JdbcTypeDescriptor`:: Describes aspects of the JDBC type such as how to bind and extract values.  The descriptor
    used can be influenced through `@JdbcType`, `@JdbcTypeCode` and `@JdbcTypeRegistration`.
    `@JdbcTypeRegistration` is a global form of `@JdbcType` / `@JdbcTypeCode`.
`BasicValueConverter`:: Describes the conversions that need to occur when reading from or writing to the database.
    Some Java types (enums, e.g.) have an implicit conversion.  Users can specify an explicit conversion using
    `AttributeConverter`.  See <<basic-jpa-convert>>.
`MutabilityPlan`:: Describes whether the internal state of values of the type are mutable or immutable.
    `MutabilityPlan` can be influenced by `@Mutability` or `@Immutable`

When using the compositional approach, there are other ways to influence the resolution are covered
in <<basic-enums>>, <<basic-temporal>>, <<basic-lob>> and <<basic-nationalized>>


[[basic-mapping-custom]]
==== Custom type mapping

Another approach is to supply the implementation of the `org.hibernate.usertype.UserType` contract using `@CustomType`.

There are also corresponding, specialized forms of `@CustomType` for specific model parts:

* When mapping a Map, `@CustomType` describes the Map value while `@MapKeyCustomType` describe the Map key
* When mapping a List or array, `@CustomType` describes the elements while `@ListIndexCustomType` describes the index
* When mapping an id-bag, `@CustomType` describes the elements while `@CollectionIdCustomType` describes the collection-id
* For other collection mappings, `@CustomType` describes the elements
* For discriminated association mappings (`@Any` and `@ManyToAny`), `@CustomType` describes the discriminator value


[[basic-nationalized]]
==== Handling nationalized character data

How nationalized character data is handled and stored depends on the underlying database.

Most databases support storing nationalized character data through the standardized SQL
NCHAR, NVARCHAR, LONGNVARCHAR and NCLOB variants.

Others support storing nationalized data as part of CHAR, VARCHAR, LONGVARCHAR
and CLOB.  Generally these databases do not support NCHAR, NVARCHAR, LONGNVARCHAR
and NCLOB, even as aliased types.

Ultimately Hibernate understands this through `Dialect#getNationalizationSupport()`

To ensure nationalized character data gets stored and accessed correctly, `@Nationalized` can be used
locally or `hibernate.use_nationalized_character_data` can be set globally.

[NOTE]
====
`@Nationalized` and `hibernate.use_nationalized_character_data` can be used regardless
of the specific database support for nationalized data and allows the application to
work portably across databases with varying support.
====

[IMPORTANT]
====
For databases that do not support `NCLOB` data-types, it is unsupported to map
the attribute using `java.sql.NClob`.  Use `java.sql.Clob` (which `NClob` extends)
or use a materialized mapping (`String`, `char[]`, ...) instead.

See also <<basic-lob>> regarding similar limitation for databases which do not support
explicit `CLOB` data-type.
====

Considering we have the following database table:

[[basic-nationalized-sql-example]]
.`NVARCHAR` - SQL
====
[source, JAVA, indent=0]
----
include::{extrasdir}/basic/basic-nationalized-sql-example.sql[]
----
====

To map a specific attribute to a nationalized variant data type, Hibernate defines the `@Nationalized` annotation.

[[basic-nationalized-example]]
.`NVARCHAR` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NationalizedTest.java[tags=basic-nationalized-example]
----
====




[[basic-lob]]
==== Handling LOB data

Mapping basic values to database LOB (Large OBject) types is handled using `@Lob`.

[NOTE]
====
How JDBC deals with `LOB` data varies from driver to driver.  Hibernate tries to handle all these
variances on your behalf.

However, some drivers (i.e. PostgreSQL) are trickier and, in such cases, you may have to do some
extra steps to get LOBs working.  Such discussions are beyond the scope of this guide.
====

[IMPORTANT]
====
For databases that do not support `CLOB` data-types, it is unsupported to map
the attribute using `java.sql.Clob`.  Use a materialized mapping (`String`,
`char[]`, ...) instead.
====

Mapping basic values to LOB types comes in 2 forms...

===== LOB Locator

The JDBC LOB locator types include:

* `java.sql.Blob`
* `java.sql.Clob`
* `java.sql.NClob`

Through references of these types, JDBC drivers can support more efficient access to the LOB data.
Some drivers stream parts of the LOB data as needed, potentially freeing up memory space.

However, they can be unnatural to deal with and have certain limitations.
For example, a LOB locator is only portably valid during the duration of the transaction in which it was obtained.

===== Materialized LOB

Hibernate allows mapping LOB data using familiar Java types such as `String`, `char[]`, `byte[]`, etc.  Materialization
handles the entire LOB contents in memory.

This trade-off for more familiar is sometimes performance, though this depends on the driver.





[[basic-temporal]]
==== Handling temporal data

Hibernate supports mapping temporal values in numerous ways, though ultimately these strategies
boil down to the 3 main Date/Time types defined by the SQL specification:

DATE:: Represents a calendar date by storing years, months and days.
TIME:: Represents the time of a day by storing hours, minutes and seconds.
TIMESTAMP:: Represents both a DATE and a TIME plus nanoseconds.

The mapping of `java.time` temporal types to the specific SQL Date/Time types is implied as follows:

DATE:: `java.time.LocalDate`
TIME:: `java.time.LocalTime`, `java.time.OffsetTime`
TIMESTAMP:: `java.time.Instant`, `java.time.LocalDateTime`, `java.time.OffsetDateTime` and `java.time.ZonedDateTime`

Although Hibernate recommends the use of the `java.time` package for representing temporal values,
it does support using `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`, `java.util.Date` and
`java.util.Calendar`.

The mappings for `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` are implicit:

DATE:: `java.sql.Date`
TIME:: `java.sql.Time`
TIMESTAMP:: `java.sql.Timestamp`


[IMPORTANT]
====
Applying `@Temporal` to `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` or any of the `java.time` types
is considered an exception
====

When using `java.util.Date` or `java.util.Calendar`, Hibernate assumes `TIMESTAMP`.  To alter that,
use `@Temporal`.

[[basic-temporal-java-util-example]]
.Mapping java.util.Date
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DatePrecisionTests.java[tags=basic-temporal-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-datetime-time-zone]]
===== Using a specific time zone

By default, Hibernate is going to use the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x)`] when saving a `java.sql.Timestamp` or a `java.sql.Time` property.

When the time zone is not specified, the JDBC driver is going to use the underlying JVM default time zone, which might not be suitable if the application is used from all across the globe.
For this reason, it is very common to use a single reference time zone (e.g. UTC) whenever saving/loading data from the database.

One alternative would be to configure all JVMs to use the reference time zone:

Declaratively::
+
[source,java]
----
java -Duser.timezone=UTC ...
----

Programmatically::
+
[source,java]
----
TimeZone.setDefault( TimeZone.getTimeZone( "UTC" ) );
----

However, as explained in https://in.relation.to/2016/09/12/jdbc-time-zone-configuration-property/[this article], this is not always practical, especially for front-end nodes.
For this reason, Hibernate offers the `hibernate.jdbc.time_zone` configuration property which can be configured:

Declaratively, at the `SessionFactory` level::
+
[source,java]
----
settings.put(
    AvailableSettings.JDBC_TIME_ZONE,
    TimeZone.getTimeZone( "UTC" )
);
----

Programmatically, on a per `Session` basis::
+
[source,java]
----
Session session = sessionFactory()
    .withOptions()
    .jdbcTimeZone( TimeZone.getTimeZone( "UTC" ) )
    .openSession();
----

With this configuration property in place, Hibernate is going to call the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-java.util.Calendar-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp, Calendar cal)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-java.util.Calendar-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x, Calendar cal)`], where the `java.util.Calendar` references the time zone provided via the `hibernate.jdbc.time_zone` property.



[[basic-enums]]
==== Enums

Hibernate supports the mapping of Java enums as basic value types in a number of different ways.

[[basic-enums-Enumerated]]
===== `@Enumerated`

The original Jakarta Persistence-compliant way to map enums was via the `@Enumerated` or `@MapKeyEnumerated`
annotations, working on the principle that the enum values are stored according to one of 2 strategies indicated
by `jakarta.persistence.EnumType`:

`ORDINAL`:: stored according to the enum value's ordinal position within the enum class, as indicated by `java.lang.Enum#ordinal`
`STRING`:: stored according to the enum value's name, as indicated by `java.lang.Enum#name`

Assuming the following enumeration:

.`PhoneType` enumeration
====
[source, JAVA, indent=0]
----
include::{modeldir}/PhoneType.java[tags=hql-examples-domain-model-example]
----
====

In the ORDINAL example, the `phone_type` column is defined as a (nullable) INTEGER type and would hold:

`NULL`:: For null values
`0`:: For the `LAND_LINE` enum
`1`:: For the `MOBILE` enum

[[basic-enums-Enumerated-ordinal-example]]
.`@Enumerated(ORDINAL)` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-example]
----
====

When persisting this entity, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-ordinal-persistence-example]]
.Persisting an entity with an `@Enumerated(ORDINAL)` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-ordinal-persistence-example.sql[]
----
====

In the STRING example, the `phone_type` column is defined as a (nullable) VARCHAR type and would hold:

`NULL`:: For null values
`LAND_LINE`:: For the `LAND_LINE` enum
`MOBILE`:: For the `MOBILE` enum

[[basic-enums-Enumerated-string-example]]
.`@Enumerated(STRING)` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedStringTest.java[tags=basic-enums-Enumerated-string-example]
----
====

Persisting the same entity as in the `@Enumerated(ORDINAL)` example, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-string-persistence-example]]
.Persisting an entity with an `@Enumerated(STRING)` mapping
====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-string-persistence-example.sql[]
----
====

[[basic-enums-attribute-converter]]
===== Using AttributeConverter

Let's consider the following `Gender` enum which stores its values using the `'M'` and `'F'` codes.

[[basic-enums-converter-example]]
.Enum with a custom constructor
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/Gender.java[tags=basic-enums-converter-example]
----
====

You can map enums in a Jakarta Persistence compliant way using a Jakarta Persistence AttributeConverter.

[[basic-enums-attribute-converter-example]]
.Enum mapping with `AttributeConverter` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/EnumerationConverterTest.java[tags=basic-enums-attribute-converter-example]
----
====

Here, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using AttributeConverters, see <<basic-jpa-convert>> section.

[NOTE]
====
Jakarta Persistence explicitly disallows the use of an `AttributeConverter` with an attribute marked as `@Enumerated`.

So, when using the `AttributeConverter` approach, be sure not to mark the attribute as `@Enumerated`.
====



[[basic-enums-custom-type]]
===== Custom type

You can also map enums using a Hibernate custom type mapping.
Let's again revisit the Gender enum example, this time using a custom Type to store the more standardized `'M'` and `'F'` codes.

[[basic-enums-custom-type-example]]
.Enum mapping with custom Type example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/EnumerationCustomTypeTest.java[tags=basic-enums-custom-type-example, indent=0]

include::{sourcedir}/basic/GenderType.java[tags=basic-enums-custom-type-example, indent=0]

include::{sourcedir}/basic/GenderJavaTypeDescriptor.java[tags=basic-enums-custom-type-example, indent=0]
----
====

Again, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using custom types, see <<basic-mapping-custom>> section.




[[basic-boolean]]
==== Boolean

Boolean values in the domain model are generally mapped to BOOLEAN/BIT on the database side depending on the
database's capabilities.

[[basic-boolean-example-implicit]]
.Implicit boolean mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-implicit]
----
====

However, it is certainly reasonable to map booleans to other representations in the
database and Hibernate provides support for mapping booleans to the more well known
representations - 'Y' / 'N', 'T' / 'F' or 1 (true) / 0 (false).

[[basic-boolean-example-converted]]
.Using `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-yes-no]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-t-f]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-numeric]
----
====

Here the built-in `AttributeConverter` implementations provided by Hibernate are used.  A custom
`AttributeConverter` could be used also.


Booleans can also be mapped using `UserType` and `@CustomType`


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-byte]]
==== Byte

By default, Hibernate maps values of `Byte` / `byte` to the `TINYINT` JDBC type.

[[basic-byte-example]]
.Mapping Byte
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ByteMappingTests.java[tags=basic-byte-example-implicit]
----
====


See <<basic-bytearray>> for mapping arrays of bytes.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-short]]
==== Short

By default, Hibernate maps values of `Short` / `short` to the `SMALLINT` JDBC type.

[[basic-short-example]]
.Mapping Short
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ShortMappingTests.java[tags=basic-short-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-integer]]
==== Integer

By default, Hibernate maps values of `Integer` / `int` to the `INTEGER` JDBC type.

[[basic-integer-example]]
.Mapping Integer
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/IntegerMappingTests.java[tags=basic-integer-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-long]]
==== Long

By default, Hibernate maps values of `Long` / `long` to the `BIGINT` JDBC type.

[[basic-long-example]]
.Mapping Long
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LongMappingTests.java[tags=basic-long-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-biginteger]]
==== BigInteger

By default, Hibernate maps values of `BigInteger` to the `NUMERIC` JDBC type.

[[basic-bitinteger-example]]
.Mapping BigInteger
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BigIntegerMappingTests.java[tags=basic-biginteger-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-double]]
==== Double

By default, Hibernate maps values of `Double` to the `DOUBLE`, `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database

[[basic-double-example]]
.Mapping Double
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DoubleMappingTests.java[tags=basic-double-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping-explicit>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-float]]
==== Float

By default, Hibernate maps values of `Float` to the `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database.

[[basic-float-example]]
.Mapping Float
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FloatMappingTests.java[tags=basic-float-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bigdecimal]]
==== BigDecimal

By default, Hibernate maps values of `BigDecimal` to the `NUMERIC` JDBC type.

[[basic-bigdecimal-example]]
.Mapping BigDecimal
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BigDecimalMappingTests.java[tags=basic-bigdecimal-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-character]]
==== Character

By default, Hibernate maps `Character` to the `CHAR` JDBC type.

[[basic-character-example]]
.Mapping Character
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CharacterMappingTests.java[tags=basic-character-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-String]]
==== String

By default, Hibernate maps `String` to the `VARCHAR` JDBC type.

[[basic-string-example]]
.Mapping String
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/StringMappingTests.java[tags=basic-string-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.


For databases which support nationalized character sets, you can also store strings as
nationalized data.

[[basic-nstring-example]]
.Mapping String as nationalized
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/StringNationalizedMappingTests.java[tags=basic-nstring-example]
----
====

See <<basic-nationalized>> for details on mapping strings using nationalized character sets.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-chararray]]
==== Character arrays

By default, Hibernate maps `Character[]` and `char[]` to the `VARCHAR` JDBC type.

[[basic-string-example-implicit]]
.Mapping Character
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CharacterArrayMappingTests.java[tags=basic-chararray-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.

For databases which support nationalized character sets, you can also store character arrays as
nationalized data.

[[basic-nchararray-example]]
.Mapping character arrays as nationalized
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CharacterArrayNationalizedMappingTests.java[tags=basic-nchararray-example]
----
====

See <<basic-nationalized>> for details on mapping strings using nationalized character sets.



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-clob]]
==== Clob / NClob

[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling and <<basic-nationalized>> which covers basics
of nationalized data handling.
====

By default, Hibernate will map the `java.sql.Clob` Java type to `CLOB` and `java.sql.NClob` to `NCLOB`.

Considering we have the following database table:

[[basic-clob-sql-example]]
.CLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-clob-sql-example.sql[]
----
====

Let's first map this using the `@Lob` Jakarta Persistence annotation and the `java.sql.Clob` type:

[[basic-clob-example]]
.`CLOB` mapped to `java.sql.Clob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-example]
----
====

To persist such an entity, you have to create a `Clob` using the `ClobProxy` Hibernate utility:

[[basic-clob-persist-example]]
.Persisting a `java.sql.Clob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-persist-example]
----
====

To retrieve the `Clob` content, you need to transform the underlying `java.io.Reader`:

[[basic-clob-find-example]]
.Returning a `java.sql.Clob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-find-example]
----
====

We could also map the CLOB in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-clob-string-example]]
.`CLOB` mapped to `String`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobStringTest.java[tags=basic-clob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-clob-char-array-example]]
.CLOB - materialized `char[]` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobCharArrayTest.java[tags=basic-clob-char-array-example]
----
====

Just like with `CLOB`, Hibernate can also deal with `NCLOB` SQL data types:

[[basic-nclob-sql-example]]
.`NCLOB` - SQL
====
[source, JAVA, indent=0]
----
include::{extrasdir}/basic/basic-nclob-sql-example.sql[]
----
====

Hibernate can map the `NCLOB` to a `java.sql.NClob`

[[basic-nclob-example]]
.`NCLOB` mapped to `java.sql.NClob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-example]
----
====

To persist such an entity, you have to create an `NClob` using the `NClobProxy` Hibernate utility:

[[basic-nclob-persist-example]]
.Persisting a `java.sql.NClob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-persist-example]
----
====

To retrieve the `NClob` content, you need to transform the underlying `java.io.Reader`:

[[basic-nclob-find-example]]
.Returning a `java.sql.NClob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-find-example]
----
====

We could also map the `NCLOB` in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-nclob-string-example]]
.`NCLOB` mapped to `String`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobStringTest.java[tags=basic-nclob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-nclob-char-array-example]]
.NCLOB - materialized `char[]` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobCharArrayTest.java[tags=basic-nclob-char-array-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bytearray]]
==== Byte array

By default, Hibernate maps values of type `byte[]` and `Byte[]` to the JDBC type
`VARBINARY`.

[[basic-bytearray-example]]
.Mapping arrays of bytes
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ByteArrayMappingTests.java[tags=basic-bytearray-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-blob]]
==== Blob


[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling.
====

By default, Hibernate will map the `java.sql.Blob` Java type to `BLOB`.

Considering we have the following database table:

[[basic-blob-sql-example]]
.BLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-blob-sql-example.sql[]
----
====

Let's first map this using the JDBC `java.sql.Blob` type.

[[basic-blob-example]]
.`BLOB` mapped to `java.sql.Blob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-example]
----
====

To persist such an entity, you have to create a `Blob` using the `BlobProxy` Hibernate utility:

[[basic-blob-persist-example]]
.Persisting a `java.sql.Blob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-persist-example]
----
====

To retrieve the `Blob` content, you need to transform the underlying `java.io.InputStream`:

[[basic-blob-find-example]]
.Returning a `java.sql.Blob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-find-example]
----
====

We could also map the BLOB in a materialized form (e.g. `byte[]`).

[[basic-blob-byte-array-example]]
.`BLOB` mapped to `byte[]`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobByteArrayTest.java[tags=basic-blob-byte-array-example]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Duration

By default, Hibernate will map `Duration` to the `NUMERIC` JDBC type.

[[basic-duration-example]]
.Mapping Duration
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DurationMappingTests.java[tags=basic-duration-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Instant

`Instant` is mapped to the `TIMESTAMP` JDBC type.


[[basic-instant-example]]
.Mapping Instant
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/InstantMappingTests.java[tags=basic-instant-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDate

`LocalDate` is mapped to the `DATE` JDBC type.

[[basic-localDate-example]]
.Mapping LocalDate
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocalDateMappingTests.java[tags=basic-localDate-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDateTime

`LocalDateTime` is mapped to the `TIMESTAMP` JDBC type.

[[basic-localDateTime-example]]
.Mapping LocalDateTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocalDateTimeMappingTests.java[tags=basic-localDateTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalTime

`LocalTime` is mapped to the `TIME` JDBC type.

[[basic-localTime-example]]
.Mapping LocalTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocalTimeMappingTests.java[tags=basic-localTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetDateTime

`OffsetDateTime` is mapped to the `TIMESTAMP` or `TIMESTAMP_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-OffsetDateTime-example]]
.Mapping OffsetDateTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/OffsetDateTimeMappingTests.java[tags=basic-OffsetDateTime-example]
----
====


See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetTime

`OffsetTime` is mapped to the `TIME` or `TIME_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-OffsetTime-example]]
.Mapping OffsetTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/OffsetTimeMappingTests.java[tags=basic-offsetTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== TimeZone

`TimeZone` is mapped to `VARCHAR` JDBC type.

[[basic-TimeZone-example]]
.Mapping OffsetTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/TimeZoneMappingTests.java[tags=basic-timeZone-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZonedDateTime


`ZonedDateTime` is mapped to the `TIMESTAMP` or `TIMESTAMP_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-ZonedDateTime-example]]
.Mapping ZonedDateTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ZonedDateTimeMappingTests.java[tags=basic-ZonedDateTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZoneOffset

`ZoneOffset` is mapped to `VARCHAR` JDBC type.

[[basic-ZoneOffset-example]]
.Mapping ZoneOffset
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ZoneOffsetMappingTests.java[tags=basic-ZoneOffset-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Calendar

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling








// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Date

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Time

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Timestamp

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Class

Hibernate maps `Class` references to `VARCHAR` JDBC type

[[basic-Class-example]]
.Mapping Class
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClassMappingTests.java[tags=basic-Class-example]
----
====



==== Currency

Hibernate maps `Currency` references to `VARCHAR` JDBC type

[[basic-Currency-example]]
.Mapping Currency
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CurrencyMappingTests.java[tags=basic-Currency-example]
----
====



==== Locale

Hibernate maps `Locale` references to `VARCHAR` JDBC type

[[basic-Locale-example]]
.Mapping Locale
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocaleMappingTests.java[tags=basic-Locale-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-uuid]]
==== UUID

Hibernate allows mapping UUID values in a number of ways.  By default, Hibernate will
store UUID values in their binary form.


[NOTE]
====
The default uses the binary representation because it uses a more efficient column storage.

However, many applications prefer the readability of the character-based column storage.

// todo (6.0) : develop a better way to expose this to users
To switch the default mapping, simply call `MetadataBuilder.applyBasicType( UUIDCharType.INSTANCE, UUID.class.getName() )`.
====

===== UUID as binary

As mentioned, the default mapping for UUID attributes.
Maps the UUID to a `byte[]` using `java.util.UUID#getMostSignificantBits` and `java.util.UUID#getLeastSignificantBits` and stores that as `BINARY` data.

Chosen as the default simply because it is generally more efficient from a storage perspective.

===== UUID as (var)char

Maps the UUID to a String using `java.util.UUID#toString` and `java.util.UUID#fromString` and stores that as `CHAR` or `VARCHAR` data.

===== PostgreSQL-specific UUID

[IMPORTANT]
====
When using one of the PostgreSQL Dialects, the PostgreSQL-specific UUID Hibernate type becomes the default UUID mapping.
====

Maps the UUID using the PostgreSQL-specific UUID data type.
The PostgreSQL JDBC driver chooses to map its UUID type to the `OTHER` code.
Note that this can cause difficulty as the driver chooses to map many different data types to `OTHER`.

===== UUID as identifier

Hibernate supports using UUID values as identifiers, and they can even be generated on the user's behalf.
For details, see the discussion of generators in <<chapters/domain/identifiers.adoc#identifiers,_Identifiers_>>.







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-type-contributor]]
==== TypeContributor

`org.hibernate.boot.model.TypeContributor` is a contract for overriding or extending parts of the Hibernate type
system.

There are many ways to integrate a `TypeContributor`.  The most common is to define the `TypeContributor` as
a Java service (see `java.util.ServiceLoader`).

`TypeContributor` is passed a `TypeContributions` reference, which allows registration of custom `JavaTypeDescriptor`,
`JdbcTypeDescriptor` and `BasicType` references.





[[basic-bitset]]
==== Case Study : BitSet

We've covered many ways to specify basic value mappings so far.  This section will look at mapping the
`java.util.BitSet` type by applying the different techniques covered so far.

[[basic-bitset-example-implicit]]
.Implicit BitSet mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetImplicitTests.java[tags=basic-bitset-example-implicit]
----
====

As mentioned previously, the worst-case fallback for Hibernate mapping a basic type
which implements `Serializable` is to simply serialize it to the database.  BitSet
does implement `Serializable`, so by default Hibernate would handle this mapping by serialization.

That is not an ideal mapping.  In the following sections we will look at approaches to change
various aspects of how the BitSet gets mapped to the database.


[[basic-bitset-converter]]
===== Using `AttributeConverter`

We've seen uses of `AttributeConverter` previously.

This works well in most cases and is portable across Jakarta Persistence providers.

[[basic-bitset-example-converter]]
.BitSet AttributeConverter
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetConverterTests.java[tags=basic-bitset-example-convert]

include::{sourcedir}/basic/BitSetConverterTests.java[tags=basic-bitset-example-converter]
----
====

The `@Convert` annotation was used for illustration.  Generally such a converter would be auto-applied instead

See <<basic-jpa-convert>> for details.

[NOTE]
====
The use of `AttributeConverter` can have drawbacks related to Hibernate being able
to appropriately handle the mutability aspects of the converted values. `AttributeConverter`
does not indicate whether the converted values are mutable or not, so Hibernate has to assume
they are (the safer assumption) which can lead to excessive conversions back and forth as part
of dirty-checking as well as second-level caching.

See <<basic-jpa-convert-mutability>> for additional details.
====


[[basic-bitset-java-type]]
===== Using a custom `JavaTypeDescriptor`

As covered in <<basic-mapping-explicit>>, we will define a `JavaTypeDescriptor`
for `BitSet` that maps values to `VARCHAR` for storage by default.

[[basic-bitset-example-java-type]]
.BitSet JavaTypeDescriptor
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaType.java[tags=basic-bitset-example-java-type]
----
====


We can either apply that type locally using `@JavaType`

[[basic-bitset-example-java-type-local]]
.@JavaType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaTypeTests.java[tags=basic-bitset-example-java-type-local,indent=0]
----
====

Or we can apply it globally using `@JavaTypeRegistration`.  This allows the registered `JavaTypeDescriptor`
to be used as the default whenever we encounter the `BitSet` type

[[basic-bitset-example-java-type-global]]
.@JavaTypeRegistration
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaTypeRegistrationTests.java[tags=basic-bitset-example-java-type-global,indent=0]
----
====


[[basic-bitset-jdbc-type]]
===== Selecting different `JdbcTypeDescriptor`

Our custom `BitSetJavaType` maps `BitSet` values to `VARCHAR` by default.  That was a better option
than direct serialization.  But as `BitSet` is ultimately binary data we would probably really want to
map this to `VARBINARY` type instead.  One way to do that would be to change `BitSetJavaType#getRecommendedJdbcType`
to instead return `VARBINARY` descriptor.  Another option would be to use a local `@JdbcType` or `@JdbcTypeCode`.

The following examples for specifying the `JdbcTypeDescriptor` assume our `BitSetJavaType`
is globally registered.

We will again store the values as `VARBINARY` in the database.  The difference now however is that
the coercion methods `#wrap` and `#unwrap` will be used to prepare the value rather than relying on
serialization.


[[basic-bitset-example-jdbc-type-code]]
.@JdbcTypeCode
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeCodeTests.java[tags=basic-bitset-example-jdbc-type-code,indent=0]
----
====

In this example, `@JdbcTypeCode` has been used to indicate that the `JdbcTypeDescriptor` registered for JDBC's
`VARBINARY` type should be used.


[[basic-bitset-example-jdbc-type-local]]
.@JdbcType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeTests.java[tags=basic-bitset-example-jdbc-type-local,indent=0]
----
====

In this example, `@JdbcType` has been used to specify our custom `BitSetJdbcType` descriptor locally for
this attribute.

We could instead replace how Hibernate deals with all `VARBINARY` handling with our custom impl using
`@JdbcTypeRegistration`

[[basic-bitset-example-jdbc-type-global]]
.@JdbcType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeRegistrationTests.java[tags=basic-bitset-example-jdbc-type-global,indent=0]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-jpa-convert]]
==== AttributeConverters

With a custom `AttributeConverter`, the application developer can map a given JDBC type to an entity basic type.

In the following example, the `java.time.Period` is going to be mapped to a `VARCHAR` database column.

[[basic-jpa-convert-period-string-converter-example]]
.`java.time.Period` custom `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringConverter.java[tags=basic-jpa-convert-period-string-converter-example]
----
====

To make use of this custom converter, the `@Convert` annotation must decorate the entity attribute.

[[basic-jpa-convert-period-string-converter-mapping-example]]
.Entity using the custom `java.time.Period` `AttributeConverter` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----
====

When persisting such entity, Hibernate will do the type conversion based on the `AttributeConverter` logic:

[[basic-jpa-convert-period-string-converter-sql-example]]
.Persisting entity using the custom `AttributeConverter`
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-jpa-convert-period-string-converter-sql-example.sql[]
----
====

An `AttributeConverter` can be applied globally for (`@Converter( autoApply=true )`) or locally.


[[basic-jpa-convert-type]]
===== `AttributeConverter` Java and JDBC types

In cases when the Java type specified for the "database side" of the conversion (the second `AttributeConverter` bind parameter) is not known,
Hibernate will fallback to a `java.io.Serializable` type.

If the Java type is not known to Hibernate, you will encounter the following message:

> HHH000481: Encountered Java type for which we could not locate a JavaTypeDescriptor and which does not appear to implement equals and/or hashCode.
> This can lead to significant performance problems when performing equality/dirty checking involving this Java type.
> Consider registering a custom JavaTypeDescriptor or at least implementing equals/hashCode.

A Java type is "known" if it has an entry in the `JavaTypeDescriptorRegistry`.  While Hibernate does load many JDK types into
the `JavaTypeDescriptorRegistry`, an application can also expand the `JavaTypeDescriptorRegistry` by adding new `JavaTypeDescriptor`
entries.  This way, Hibernate will also know how to handle a specific Java Object type at the JDBC level.




[[basic-hbm-attribute-converter]]
===== Mapping an AttributeConverter using HBM mappings

When using HBM mappings, you can still make use of the Jakarta Persistence `AttributeConverter` because Hibernate supports
such mapping via the `type` attribute as demonstrated by the following example.

Let's consider we have an application-specific `Money` type:

[[basic-hbm-attribute-converter-mapping-money-example]]
.Application-specific `Money` type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/Money.java[tags=basic-hbm-attribute-converter-mapping-money-example]
----
====

Now, we want to use the `Money` type when mapping the `Account` entity:

[[basic-hbm-attribute-converter-mapping-account-example]]
.`Account` entity using the `Money` type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/Account.java[tags=basic-hbm-attribute-converter-mapping-account-example]
----
====

Since Hibernate has no knowledge how to persist the `Money` type, we could use a Jakarta Persistence `AttributeConverter`
to transform the `Money` type as a `Long`. For this purpose, we are going to use the following
`MoneyConverter` utility:

[[basic-hbm-attribute-converter-mapping-moneyconverter-example]]
.`MoneyConverter` implementing the Jakarta Persistence `AttributeConverter` interface
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/MoneyConverter.java[tags=basic-hbm-attribute-converter-mapping-moneyconverter-example]
----
====

To map the `MoneyConverter` using HBM configuration files you need to use the `converted::` prefix in the `type`
attribute of the `property` element.

[[basic-hbm-attribute-converter-mapping-xml-config-example]]
.HBM mapping for `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{resourcedir}/mapping/converter/hbm/MoneyConverterHbmTest.hbm.xml[]
----
====




[[basic-jpa-convert-mutability]]
===== `AttributeConverter` Mutability Plan

A basic type that's converted by a Jakarta Persistence `AttributeConverter` is immutable if the underlying Java type is immutable
and is mutable if the associated attribute type is mutable as well.

Therefore, mutability is given by the https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/type/descriptor/java/JavaTypeDescriptor.html#getMutabilityPlan--[`JavaTypeDescriptor#getMutabilityPlan`]
of the associated entity attribute type.

This can be adjusted by using `@Immutable` or `@Mutability` on any of:

1. the basic value
2. the `AttributeConverter` class
3. the basic value type

See <<basic-mapping>> for additional details.


====== Immutable types

If the entity attribute is a `String`, a primitive wrapper (e.g. `Integer`, `Long`), an Enum type, or any other immutable `Object` type,
then you can only change the entity attribute value by reassigning it to a new value.

Considering we have the same `Period` entity attribute as illustrated in the <<basic-jpa-convert>> section:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----

The only way to change the `span` attribute is to reassign it to a different value:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-immutability-plan-example]
----

====== Mutable types

On the other hand, consider the following example where the `Money` type is a mutable.

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mapping-example]
----

A mutable `Object` allows you to modify its internal structure, and Hibernate dirty checking mechanism is going to propagate the change to the database:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mutability-plan-example]
----

[TIP]
====
Although the `AttributeConverter` types can be mutable so that dirty checking, deep copying, and second-level caching work properly,
treating these as immutable (when they really are) is more efficient.

For this reason, prefer immutable types over mutable ones whenever possible.
====



[[basic-attribute-converter-query-parameter]]
====== Using the AttributeConverter entity property as a query parameter

Assuming you have the following entity:

[[basic-attribute-converter-query-parameter-entity-example]]
.`Photo` entity with `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-entity-example]
----
====

And the `Caption` class looks as follows:

[[basic-attribute-converter-query-parameter-object-example]]
.`Caption` Java object
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-object-example]
----
====

And we have an `AttributeConverter` to handle the `Caption` Java object:

[[basic-attribute-converter-query-parameter-converter-example]]
.`Caption` Java object AttributeConverter
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-example]
----
====

Traditionally, you could only use the DB data `Caption` representation, which in our case is a `String`, when referencing the `caption` entity property.

[[basic-attribute-converter-query-parameter-converter-dbdata-example]]
.Filtering by the `Caption` property using the DB data representation
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-dbdata-example]
----
====

In order to use the Java object `Caption` representation, you have to get the associated Hibernate `Type`.

[[basic-attribute-converter-query-parameter-converter-object-example]]
.Filtering by the `Caption` property using the Java Object representation
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-object-example]
----
====

By passing the associated Hibernate `Type`, you can use the `Caption` object when binding the query parameter value.









// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[[mapping-quoted-identifiers]]
==== SQL quoted identifiers

You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document.
While traditionally, Hibernate used backticks for escaping SQL reserved keywords, Jakarta Persistence uses double quotes instead.

Once the reserved keywords are escaped, Hibernate will use the correct quotation style for the SQL `Dialect`.
This is usually double quotes, but SQL Server uses brackets and MySQL uses backticks.

[[basic-quoting-example]]
.Hibernate legacy quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/QuotingTest.java[tags=basic-quoting-example]
----
====

[[basic-jpa-quoting-example]]
.Jakarta Persistence quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/JpaQuotingTest.java[tags=basic-jpa-quoting-example]
----
====

Because `name` and `number` are reserved words, the `Product` entity mapping uses backticks to quote these column names.

When saving the following `Product entity`, Hibernate generates the following SQL insert statement:

[[basic-quoting-persistence-example]]
.Persisting a quoted column name
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/QuotingTest.java[tags=basic-quoting-persistence-example, indent=0]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-quoting-persistence-example.sql[indent=0]
----
====

[[mapping-global-quoted-identifiers]]
===== Global quoting

Hibernate can also quote all identifiers (e.g. table, columns) using the following configuration property:

====
[source,xml]
----
<property
    name="hibernate.globally_quoted_identifiers"
    value="true"
/>
----
====

This way, we don't need to manually quote any identifier:

[[basic-auto-quoting-example]]
.Jakarta Persistence quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/AutoQuotingTest.java[tags=basic-auto-quoting-example]
----
====

When persisting a `Product` entity, Hibernate is going to quote all identifiers as in the following example:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-auto-quoting-persistence-example.sql[indent=0]
----
====

As you can see, both the table name and all the column have been quoted.

For more about quoting-related configuration properties, check out the <<appendices/Configurations.adoc#configurations-mapping,Mapping configurations>> section as well.




















[[mapping-generated]]
==== Generated properties

NOTE:: This section talks about generating values for non-identifier attributes.  For discussion of generated identifier values, see <<identifiers-generators>>.

Generated attributes have their values generated as part of performing a SQL INSERT or UPDATE.  Applications can generate these
values in any number of ways (SQL DEFAULT value, trigger, etc).  Typically, the application needs to refresh objects that
contain any properties for which the database was generating values, which is a major drawback.

Applications can also delegate generation to Hibernate, in which case Hibernate will manage the value generation
and (potentialfootnote:[Only in-DB generation requires the refresh]) state refresh itself.

[IMPORTANT]
====
Only `@Basic` and `@Version` attributes can be marked as generated.

Generated attributes must additionally be _non-insertable_ and _non-updateable_.
====

Hibernate supports both in-VM and in-DB generation.  A generation that uses the current JVM timestamp as the
generated value is an example of an in-VM strategy.  A generation that uses the database's `current_timestamp`
function is an example of an in-DB strategy.

Hibernate supports the following timing (when) for generation:

`NEVER` (the default):: the given attribute value is not generated
`INSERT`:: the attribute value is generated on insert but is not regenerated on subsequent updates
`ALWAYS`:: the attribute value is generated both on insert and update.

Hibernate supports multiple ways to mark an attribute as generated:

* Using the dedicated generators provided by Hibernate
    * `@CurrentTimestamp` - <<mapping-generated-CurrentTimestamp>>
    * `@CreationTimestamp` - <<mapping-generated-CreationTimestamp>>
    * `@UpdateTimestamp` - <<mapping-generated-UpdateTimestamp>>
    * `@Generated` - <<mapping-generated-Generated>>
    * `@GeneratorType` - is deprecated and not covered here
* Using a custom generation strategy - <<mapping-generated-custom>>


[[mapping-generated-CurrentTimestamp]]
===== `@CurrentTimestamp`

The `@CurrentTimestamp` annotation is an in-DB strategy that can be configured for either INSERT or ALWAYS timing.
It uses the database's `current_timestamp` function as the generated value

[[mapping-generated-provided-CurrentTimestamp-ex1]]
.`@UpdateTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{core-generated-test-dir}/CurrentTimestampAnnotationTests.java[tags=mapping-generated-CurrentTimestamp-ex1]
----
====



[[mapping-generated-CreationTimestamp]]
===== `@CreationTimestamp`

The `@CreationTimestamp` annotation is an in-VM `INSERT` strategy.  Hibernate will use
the current timestamp of the JVM as the insert value for the attribute.

Supports most temporal types (`java.time.Instant`, `java.util.Date`, `java.util.Calendar`, etc)

[[mapping-generated-CreationTimestamp-example]]
.`@CreationTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/CreationTimestampTest.java[tags=mapping-generated-provided-creation-ex1]
----
====

While inserting the `Event`, Hibernate will populate the underlying `timestamp` column with the current JVM timestamp value


[[mapping-generated-UpdateTimestamp]]
===== `@UpdateTimestamp` annotation

The `@UpdateTimestamp` annotation is an in-VM `INSERT` strategy.  Hibernate will use
the current timestamp of the JVM as the insert and update value for the attribute.

Supports most temporal types (`java.time.Instant`, `java.util.Date`, `java.util.Calendar`, etc)


[[mapping-generated-provided-update-ex1]]
.`@UpdateTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-provided-update-ex1]
----
====



[[mapping-generated-Generated]]
===== `@Generated` annotation

The `@Generated` annotation is an in-DB strategy that can be configured for either INSERT or ALWAYS timing

This is the legacy mapping for in-DB generated values.


[[mapping-generated-provided-Generated]]
.`@Generated` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-provided-generated]
----
====



[[mapping-generated-custom]]
===== Custom generation strategy

Hibernate also supports value generation via a pluggable API using `@ValueGenerationType` and `AnnotationValueGeneration`
allowing users to define any generation strategy they wish.

Let's look at an example of generating UUID values.  First the attribute mapping

[[mapping-generated-custom-ex1]]
.Custom generation mapping example
====
[source, JAVA, indent=0]
----
include::{core-generated-test-dir}/temporals/GeneratedUuidTests.java[tags=mapping-generated-custom-ex1]
----
====

This example makes use of an annotation named `@GeneratedUuidValue` - but where is that annotation defined?  This is a custom
annotations provided by the application.

[[mapping-generated-custom-ex2]]
.Custom generation mapping example
====
[source, JAVA, indent=0]
----
include::{core-generated-test-dir}/temporals/GeneratedUuidTests.java[tags=mapping-generated-custom-ex2]
----
====

The `@ValueGenerationType( generatedBy = UuidValueGeneration.class )` here is the important piece; it tells
Hibernate how to generate values for the attribute - here it will use the specified `UuidValueGeneration` class

[[mapping-generated-custom-ex3]]
.Custom generation mapping example
====
[source, JAVA, indent=0]
----
include::{core-generated-test-dir}/temporals/GeneratedUuidTests.java[tags=mapping-generated-custom-ex3]
----
====

See https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/ValueGenerationType.html[`@ValueGenerationType`]
and https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/tuple/AnnotationValueGeneration.html[`AnnotationValueGeneration`]
for details of each contract




[[mapping-column-read-and-write]]
==== Column transformers: read and write expressions

Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to `@Basic` types.
For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like in the following example.

[[mapping-column-read-and-write-example]]
.`@ColumnTransformer` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/../fetching/FetchingTest.java[tags=mapping-column-read-and-write-example]
----
====

If a property uses more than one column, you must use the `forColumn` attribute to specify which column the `@ColumnTransformer` read and write expressions are targeting.

[[mapping-column-read-and-write-composite-type-example]]
.`@ColumnTransformer` `forColumn` attribute usage
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-example]
----
====

Hibernate applies the custom expressions automatically whenever the property is referenced in a query.
This functionality is similar to a derived-property <<mapping-column-formula>> with two differences:

* The property is backed by one or more columns that are exported as part of automatic schema generation.
* The property is read-write, not read-only.

The `write` expression, if specified, must contain exactly one '?' placeholder for the value.

[[mapping-column-read-and-write-composite-type-persistence-example]]
.Persisting an entity with a `@ColumnTransformer` and a composite type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-read-and-write-composite-type-persistence-example.sql[]
----
====






