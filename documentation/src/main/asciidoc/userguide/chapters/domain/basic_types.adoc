[[basic]]
=== Basic types
:modeldir: ../../../../../main/java/org/hibernate/userguide/model
:sourcedir: ../../../../../test/java/org/hibernate/userguide/mapping
:resourcedir: ../../../../../test/resources/org/hibernate/userguide/
:converter-sourcedir: ../../../../../../../hibernate-core/src/test/java/org/hibernate/orm/test/mapping/converted/converter
:extrasdir: extras

A basic type is a mapping between a Java type and a single database column.

Hibernate can map many standard Java types (`Integer`, `String`, etc) as basic
types.  The mapping for many come from tables B-3 and B-4 in the JDBC specification<<jdbc>>.
Others (`URL` as `VARCHAR`, e.g.) simply make sense.

Additionally, Hibernate provides multiple, flexible ways to indicate how the Java type
should be mapped to the database.


[TIP]
====
The JPA specification strictly limits the Java types that can be marked as basic to the following:

* Java primitive types (`boolean`, `int`, etc)
* wrappers for the primitive types (`java.lang.Boolean`, `java.lang.Integer`, etc)
* `java.lang.String`
* `java.math.BigInteger`
* `java.math.BigDecimal`
* `java.time.Instant`
* `java.time.LocalDate`
* `java.time.LocalTime`
* `java.time.LocalDateTime`
* `java.time.OffsetTime`
* `java.time.OffsetDateTime`
* `java.util.Date`
* `java.util.Calendar`
* `java.sql.Date`
* `java.sql.Time`
* `java.sql.Timestamp`
* `byte[]` or `Byte[]`
* `char[]` or `Character[]`
* enums
* any other type that implements `Serializable`footnote:[JPA's support for Serializable types is to directly serialize their state to the database]

If provider portability is a concern, you should stick to just these basic types.

JPA 2.1 introduced the `javax.persistence.AttributeConverter` providing support for handling
types beyond those defined in the specification. See <<basic-jpa-convert>> for more on this topic.
====

To deal with values of basic type, Hibernate needs to understand a few things about the mapping:

* The capabilities of the Java type
   ** How to compare values
   ** How to calculate a hash-code
   ** How to coerce values of this type to another type
* The JDBC type it should use
* Any conversion it should perform on the value to/from the database
* The mutability of the value - whether the internal state can change like `java.util.Date` or is immutable like `java.lang.String`

This chapter covers how Hibernate determines these pieces and how to influence that determination process.


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-basic-annotation]]
==== @Basic

Strictly speaking, a basic type is denoted by the `javax.persistence.Basic` annotation.

Generally, the `@Basic` annotation can be ignored as it is assumed by default.  Both of the following
examples are ultimately the same.

[[basic-annotation-explicit-example]]
.`@Basic` declared explicitly
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ExplicitBasicTypeTest.java[tags=basic-annotation-explicit-example]
----
====

[[basic-annotation-implicit-example]]
.`@Basic` implied
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ImplicitBasicTypeTest.java[tags=basic-annotation-implicit-example]
----
====

The `@Basic` annotation defines 2 attributes.

`optional` - boolean (defaults to true):: Defines whether this attribute allows nulls.  JPA defines
    this as "a hint", which means the provider is free to ignore it.  JPA also says that it will be
    ignored if the type is primitive.  As long as the type is not primitive, Hibernate will honor this
    value.  Works in conjunction with `@Column#nullable` - see <<basic-column-annotation>>.
`fetch` - FetchType (defaults to EAGER):: Defines whether this attribute should be fetched eagerly or lazily.
    `EAGER` indicates that the value will be fetched as part of loading the owner.  `LAZY` values are
    fetched only when the value is accessed.  JPA requires providers to support `EAGER`, while support for
    `LAZY` is optional meaning that a provider is free to not support it.  Hibernate supports lazy loading
    of basic values as long as you are using its <<chapters/pc/BytecodeEnhancement.adoc#BytecodeEnhancement,bytecode enhancement>>
    support.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-column-annotation]]
==== @Column

JPA defines rules for implicitly determining the name of tables and columns.
For a detailed discussion of implicit naming see <<chapters/domain/naming.adoc#naming,Naming strategies>>.

For basic type attributes, the implicit naming rule is that the column name is the same as the attribute name.
If that implicit naming rule does not meet your requirements, you can explicitly tell Hibernate (and other providers) the column name to use.

[[basic-annotation-explicit-column-example]]
.Explicit column naming
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ExplicitColumnNamingTest.java[tags=basic-annotation-explicit-column-example]
----
====

Here we use `@Column` to explicitly map the `description` attribute to the `NOTES` column, as opposed to the
implicit column name `description`.

The `@Column` annotation defines other mapping information as well. See its Javadocs for details.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-formula-annotation]]
==== @Formula

`@Formula` allows mapping any database computed value as a virtual read-only column.

[NOTE]
====
The `@Formula` annotation takes a native SQL clause which may affect database portability.
====

[[mapping-column-formula-example]]
.`@Formula` mapping usage
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FormulaTest.java[tags=mapping-column-formula-example]
----
====

When loading the `Account` entity, Hibernate is going to calculate the `interest` property using the configured `@Formula`:

[[mapping-column-formula-persistence-example]]
.Persisting an entity with a `@Formula` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FormulaTest.java[tags=mapping-column-formula-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-formula-persistence-example.sql[]
----
====

[NOTE]
====
The SQL fragment defined by the `@Formula` annotation can be as complex as you want, and it can even include subselects.
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-mapping]]
==== Data mapping basics

[NOTE]
====
The following sections focus on approaches introduced in version 6 to influence how Hibernate will
map basic value to the database.

The legacy approach relying on `BasicType` and `UserType` is only lightly covered here.  Both `BasicType`
and `UserType` continue to be fully supported, however.  See <<basic-legacy>> for details.
====


Looking at <<basic-annotation-implicit-example, this example>>, how does Hibernate know what mapping
to use for these attributes?  The mapping does not really provide much information.

This is an illustration of Hibernate's implicit basic-type resolution, which is a series of checks to determine
the appropriate mapping to use.  Describing the complete process for implicit resolution is beyond the scope
of this documentationfootnote:[For details see `org.hibernate.mapping.BasicValue#resolve()`].

This is primarily driven by the Java type defined for the basic type, which can generally
be determined through reflection.  Is the Java type an enum?  Is it temporal?  These answers
can indicate certain mappings be used.

The fallback is to map the value to the "recommended" JDBC type.

Worst case, if the Java type is `Serializable` Hibernate will try to handle it via binary serialization.

For cases where the Java type is not a standard type or if some specialized handling is desired, Hibernate
provides many ways to influence this mapping resolution.  Ultimately we want to influence the resolution of

`JavaTypeDescriptor`:: Describes capabilities of the Java type as discussed in <<basic>>.  The descriptor
      used can be influenced through `@JavaType` and `@JavaTypeRegistration`.  `@JavaTypeRegistration` is a global
      form of `@JavaType`.  `@MapKeyJavaType` is used to influence the descriptor chosen for a `Map` key.
`JdbcTypeDescriptor`:: Describes aspects of the JDBC type such as how to bind and extract values.  The descriptor
      used can be influenced through `@JdbcType`, `@JdbcTypeCode` and `@JdbcTypeRegistration`.
      `@JdbcTypeRegistration` is a global form of `@JdbcType` / `@JdbcTypeCode`. `@MapKeyJdbcType` and
      `@MapKeyJdbcTypeCode` are also available to influence the descriptor chosen for a Map key.
`BasicValueConverter`:: Describes the conversions that need to occur when reading from or writing to the database.
        Some Java types (enums, e.g.) have an implicit conversion.  Users can specify an explicit conversion using
        `AttributeConverter`.  See <<basic-jpa-convert>>.
`MutabilityPlan`:: Describes whether the internal state of values of the type are mutable or immutable.
   `MutabilityPlan` can be influenced by `@Mutability` or `@Immutable`

The legacy `@Type` and `@TypeDefs` can also be used as to indicate the `BasicType` or `UserType` to use.  Refer to <<basic-legacy>>
for more details.

See <<basic-type-contributor>> for an alternative to `@JavaTypeRegistration` and `@JdbcTypeRegistration`.

See <<basic-bitset-java-type>> for examples of most of these approaches, mapping `BitSet` as a basic type.



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-nationalized]]
==== Handling nationalized character data

How nationalized character is handled and stored depends on the underlying database.

Some databases support storing nationalized data as part of CHAR, VARCHAR, LONGVARCHAR
and CLOB.

Others support storing nationalized data only through the specialized, standard SQL NCHAR,
NVARCHAR, LONGNVARCHAR and NCLOB variants.

Ultimately Hibernate understands this through `Dialect#getNationalizationSupport()`

To ensure nationalized gets stored and accessed correctly, `@Nationalized` can be used
locally or `hibernate.use_nationalized_character_data` can be set globally.

Considering we have the following database table:

[[basic-nationalized-sql-example]]
.`NVARCHAR` - SQL
====
[source, JAVA, indent=0]
----
include::{extrasdir}/basic/basic-nationalized-sql-example.sql[]
----
====

To map a specific attribute to a nationalized variant data type, Hibernate defines the `@Nationalized` annotation.

[[basic-nationalized-example]]
.`NVARCHAR` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NationalizedTest.java[tags=basic-nationalized-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-lob]]
==== Handling LOB data

Mapping basic values to database LOB (Large OBject) types is handled using `@Lob`.

[NOTE]
====
How JDBC deals with `LOB` data varies from driver to driver, and Hibernate tries to handle all these variances on your behalf.

However, some drivers are trickier (e.g. PostgreSQL), and, in such cases, you may have to do some extra steps to get LOBs working.
Such discussions are beyond the scope of this guide.
====

Mapping basic values to LOB types comes in 2 forms...

===== LOB Locator

The JDBC LOB locator types include:

* `java.sql.Blob`
* `java.sql.Clob`
* `java.sql.NClob`

Through references of these types, JDBC drivers can support more efficient access to the LOB data.
Some drivers stream parts of the LOB data as needed, potentially freeing up memory space.

However, they can be unnatural to deal with and have certain limitations.
For example, a LOB locator is only portably valid during the duration of the transaction in which it was obtained.

===== Materialized LOB

Hibernate allows mapping LOB data using familiar Java types such as `String`, `char[]`, `byte[]`, etc.  Materialization
handles the entire LOB contents in memory.

This trade-off for more familiar is sometimes performance, though this depends on the driver.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-temporal]]
==== Handling temporal data

Hibernate supports mapping temporal values in numerous ways, though ultimately these strategies
boil down to the 3 main Date/Time types defined by the SQL specification:

DATE:: Represents a calendar date by storing years, months and days.
TIME:: Represents the time of a day by storing hours, minutes and seconds.
TIMESTAMP:: Represents both a DATE and a TIME plus nanoseconds.

The mapping of `java.time` temporal types to the specific SQL Date/Time types is implied as follows:

DATE:: `java.time.LocalDate`
TIME:: `java.time.LocalTime`, `java.time.OffsetTime`
TIMESTAMP:: `java.time.Instant`, `java.time.LocalDateTime`, `java.time.OffsetDateTime` and `java.time.ZonedDateTime`

Although Hibernate recommends the use of the `java.time` package for representing temporal values,
it does support using `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`, `java.util.Date` and
`java.util.Calendar`.

The mappings for `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` are implicit:

DATE:: `java.sql.Date`
TIME:: `java.sql.Time`
TIMESTAMP:: `java.sql.Timestamp`


[IMPORTANT]
====
Applying `@Temporal` to `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` or any of the `java.time` types
is considered an exception
====

When using `java.util.Date` or `java.util.Calendar`, Hibernate assumes `TIMESTAMP`.  To alter that,
use `@Temporal`.

[[basic-temporal-java-util-example]]
.Mapping java.util.Date
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DatePrecisionTests.java[tags=basic-temporal-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-datetime-time-zone]]
===== Using a specific time zone

By default, Hibernate is going to use the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x)`] when saving a `java.sql.Timestamp` or a `java.sql.Time` property.

When the time zone is not specified, the JDBC driver is going to use the underlying JVM default time zone, which might not be suitable if the application is used from all across the globe.
For this reason, it is very common to use a single reference time zone (e.g. UTC) whenever saving/loading data from the database.

One alternative would be to configure all JVMs to use the reference time zone:

Declaratively::
+
[source,java]
----
java -Duser.timezone=UTC ...
----

Programmatically::
+
[source,java]
----
TimeZone.setDefault( TimeZone.getTimeZone( "UTC" ) );
----

However, as explained in https://in.relation.to/2016/09/12/jdbc-time-zone-configuration-property/[this article], this is not always practical, especially for front-end nodes.
For this reason, Hibernate offers the `hibernate.jdbc.time_zone` configuration property which can be configured:

Declaratively, at the `SessionFactory` level::
+
[source,java]
----
settings.put(
    AvailableSettings.JDBC_TIME_ZONE,
    TimeZone.getTimeZone( "UTC" )
);
----

Programmatically, on a per `Session` basis::
+
[source,java]
----
Session session = sessionFactory()
    .withOptions()
    .jdbcTimeZone( TimeZone.getTimeZone( "UTC" ) )
    .openSession();
----

With this configuration property in place, Hibernate is going to call the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-java.util.Calendar-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp, Calendar cal)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-java.util.Calendar-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x, Calendar cal)`], where the `java.util.Calendar` references the time zone provided via the `hibernate.jdbc.time_zone` property.






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Start the baseline type sections
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-boolean]]
==== Boolean

Boolean values in the domain model are generally mapped to BOOLEAN/BIT on the database side depending on the
database's capabilities.

[[basic-boolean-example-implicit]]
.Implicit boolean mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-implicit]
----
====

However, it is certainly reasonable to map booleans to other representations in the
database and Hibernate provides support for mapping booleans to the more well known
representations - 'Y' / 'N', 'T' / 'F' or 1 (true) / 0 (false).

[[basic-boolean-example-converted]]
.Using `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-yes-no]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-t-f]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-numeric]
----
====

Here the built-in `AttributeConverter` implementations provided by Hibernate are used.  A custom
`AttributeConverter` could be used also.


[[basic-boolean-example-legacy]]
.Using `@Type`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-legacy-yes-no]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-legacy-t-f]

include::{sourcedir}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-legacy-numeric]
----
====

Here the legacy approach is used.


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-byte]]
==== Byte

By default, Hibernate maps values of `Byte` / `byte` to the `TINYINT` JDBC type.

[[basic-byte-example]]
.Mapping Byte
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ByteMappingTests.java[tags=basic-byte-example-implicit]
----
====


See <<basic-bytearray>> for mapping arrays of bytes.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-short]]
==== Short

By default, Hibernate maps values of `Short` / `short` to the `SMALLINT` JDBC type.

[[basic-short-example]]
.Mapping Short
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ShortMappingTests.java[tags=basic-short-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-integer]]
==== Integer

By default, Hibernate maps values of `Integer` / `int` to the `INTEGER` JDBC type.

[[basic-integer-example]]
.Mapping Integer
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/IntegerMappingTests.java[tags=basic-integer-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-long]]
==== Long

By default, Hibernate maps values of `Long` / `long` to the `BIGINT` JDBC type.

[[basic-long-example]]
.Mapping Long
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LongMappingTests.java[tags=basic-long-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-biginteger]]
==== BigInteger

By default, Hibernate maps values of `BigInteger` to the `NUMERIC` JDBC type.

[[basic-bitinteger-example]]
.Mapping BigInteger
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BigIntegerMappingTests.java[tags=basic-biginteger-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-double]]
==== Double

By default, Hibernate maps values of `Double` to the `DOUBLE`, `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database

[[basic-double-example]]
.Mapping Double
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DoubleMappingTests.java[tags=basic-double-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping-explicit>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-float]]
==== Float

By default, Hibernate maps values of `Float` to the `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database.

[[basic-float-example]]
.Mapping Float
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/FloatMappingTests.java[tags=basic-float-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bigdecimal]]
==== BigDecimal

By default, Hibernate maps values of `BigDecimal` to the `NUMERIC` JDBC type.

[[basic-bigdecimal-example]]
.Mapping BigDecimal
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BigDecimalMappingTests.java[tags=basic-bigdecimal-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-character]]
==== Character

By default, Hibernate maps `Character` to the `CHAR` JDBC type.

[[basic-character-example]]
.Mapping Character
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CharacterMappingTests.java[tags=basic-character-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-String]]
==== String

By default, Hibernate maps `String` to the `VARCHAR` JDBC type.

[[basic-string-example]]
.Mapping String
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/StringMappingTests.java[tags=basic-string-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.


For databases which support nationalized character sets, you can also store strings as
nationalized data.

[[basic-nstring-example]]
.Mapping String as nationalized
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/StringNationalizedMappingTests.java[tags=basic-nstring-example]
----
====

See <<basic-nationalized>> for details on mapping strings using nationalized character sets.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-chararray]]
==== Character arrays

By default, Hibernate maps `Character[]` and `char[]` to the `VARCHAR` JDBC type.

[[basic-string-example-implicit]]
.Mapping Character
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CharacterArrayMappingTests.java[tags=basic-chararray-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.

For databases which support nationalized character sets, you can also store character arrays as
nationalized data.

[[basic-nchararray-example]]
.Mapping character arrays as nationalized
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CharacterArrayNationalizedMappingTests.java[tags=basic-nchararray-example]
----
====

See <<basic-nationalized>> for details on mapping strings using nationalized character sets.



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-clob]]
==== Clob / NClob

[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling and <<basic-nationalized>> which covers basics
of nationalized data handling.
====

By default, Hibernate will map the `java.sql.Clob` Java type to `CLOB` and `java.sql.NClob` to `NCLOB`.

Considering we have the following database table:

[[basic-clob-sql-example]]
.CLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-clob-sql-example.sql[]
----
====

Let's first map this using the `@Lob` JPA annotation and the `java.sql.Clob` type:

[[basic-clob-example]]
.`CLOB` mapped to `java.sql.Clob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-example]
----
====

To persist such an entity, you have to create a `Clob` using the `ClobProxy` Hibernate utility:

[[basic-clob-persist-example]]
.Persisting a `java.sql.Clob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-persist-example]
----
====

To retrieve the `Clob` content, you need to transform the underlying `java.io.Reader`:

[[basic-clob-find-example]]
.Returning a `java.sql.Clob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobTest.java[tags=basic-clob-find-example]
----
====

We could also map the CLOB in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-clob-string-example]]
.`CLOB` mapped to `String`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobStringTest.java[tags=basic-clob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-clob-char-array-example]]
.CLOB - materialized `char[]` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClobCharArrayTest.java[tags=basic-clob-char-array-example]
----
====

Just like with `CLOB`, Hibernate can also deal with `NCLOB` SQL data types:

[[basic-nclob-sql-example]]
.`NCLOB` - SQL
====
[source, JAVA, indent=0]
----
include::{extrasdir}/basic/basic-nclob-sql-example.sql[]
----
====

Hibernate can map the `NCLOB` to a `java.sql.NClob`

[[basic-nclob-example]]
.`NCLOB` mapped to `java.sql.NClob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-example]
----
====

To persist such an entity, you have to create an `NClob` using the `NClobProxy` Hibernate utility:

[[basic-nclob-persist-example]]
.Persisting a `java.sql.NClob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-persist-example]
----
====

To retrieve the `NClob` content, you need to transform the underlying `java.io.Reader`:

[[basic-nclob-find-example]]
.Returning a `java.sql.NClob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobTest.java[tags=basic-nclob-find-example]
----
====

We could also map the `NCLOB` in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-nclob-string-example]]
.`NCLOB` mapped to `String`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobStringTest.java[tags=basic-nclob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-nclob-char-array-example]]
.NCLOB - materialized `char[]` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/NClobCharArrayTest.java[tags=basic-nclob-char-array-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bytearray]]
==== Byte array

By default, Hibernate maps values of type `byte[]` and `Byte[]` to the JDBC type
`VARBINARY`.

[[basic-bytearray-example]]
.Mapping arrays of bytes
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ByteArrayMappingTests.java[tags=basic-bytearray-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-blob]]
==== Blob


[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling.
====

By default, Hibernate will map the `java.sql.Blob` Java type to `BLOB`.

Considering we have the following database table:

[[basic-blob-sql-example]]
.BLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-blob-sql-example.sql[]
----
====

Let's first map this using the JDBC `java.sql.Blob` type.

[[basic-blob-example]]
.`BLOB` mapped to `java.sql.Blob`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-example]
----
====

To persist such an entity, you have to create a `Blob` using the `BlobProxy` Hibernate utility:

[[basic-blob-persist-example]]
.Persisting a `java.sql.Blob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-persist-example]
----
====

To retrieve the `Blob` content, you need to transform the underlying `java.io.InputStream`:

[[basic-blob-find-example]]
.Returning a `java.sql.Blob` entity
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobTest.java[tags=basic-blob-find-example]
----
====

We could also map the BLOB in a materialized form (e.g. `byte[]`).

[[basic-blob-byte-array-example]]
.`BLOB` mapped to `byte[]`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BlobByteArrayTest.java[tags=basic-blob-byte-array-example]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Duration

By default, Hibernate will map `Duration` to the `NUMERIC` JDBC type.

[[basic-duration-example]]
.Mapping Duration
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/DurationMappingTests.java[tags=basic-duration-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Instant

`Instant` is mapped to the `TIMESTAMP` JDBC type.


[[basic-instant-example]]
.Mapping Instant
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/InstantMappingTests.java[tags=basic-instant-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDate

`LocalDate` is mapped to the `DATE` JDBC type.

[[basic-localDate-example]]
.Mapping LocalDate
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocalDateMappingTests.java[tags=basic-localDate-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDateTime

`LocalDateTime` is mapped to the `TIMESTAMP` JDBC type.

[[basic-localDateTime-example]]
.Mapping LocalDateTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocalDateTimeMappingTests.java[tags=basic-localDateTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalTime

`LocalTime` is mapped to the `TIME` JDBC type.

[[basic-localTime-example]]
.Mapping LocalTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocalTimeMappingTests.java[tags=basic-localTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetDateTime

`OffsetDateTime` is mapped to the `TIMESTAMP` or `TIMESTAMP_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-OffsetDateTime-example]]
.Mapping OffsetDateTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/OffsetDateTimeMappingTests.java[tags=basic-OffsetDateTime-example]
----
====


See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetTime

`OffsetTime` is mapped to the `TIME` or `TIME_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-OffsetTime-example]]
.Mapping OffsetTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/OffsetTimeMappingTests.java[tags=basic-offsetTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== TimeZone

`TimeZone` is mapped to `VARCHAR` JDBC type.

[[basic-TimeZone-example]]
.Mapping OffsetTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/TimeZoneMappingTests.java[tags=basic-timeZone-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZonedDateTime


`ZonedDateTime` is mapped to the `TIMESTAMP` or `TIMESTAMP_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-ZonedDateTime-example]]
.Mapping ZonedDateTime
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ZonedDateTimeMappingTests.java[tags=basic-ZonedDateTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZoneOffset

`ZoneOffset` is mapped to `VARCHAR` JDBC type.

[[basic-ZoneOffset-example]]
.Mapping ZoneOffset
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ZoneOffsetMappingTests.java[tags=basic-ZoneOffset-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Calendar

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling








// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Date

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Time

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Timestamp

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Class

Hibernate maps `Class` references to `VARCHAR` JDBC type

[[basic-Class-example]]
.Mapping Class
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ClassMappingTests.java[tags=basic-Class-example]
----
====



==== Currency

Hibernate maps `Currency` references to `VARCHAR` JDBC type

[[basic-Currency-example]]
.Mapping Currency
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/CurrencyMappingTests.java[tags=basic-Currency-example]
----
====



==== Locale

Hibernate maps `Locale` references to `VARCHAR` JDBC type

[[basic-Locale-example]]
.Mapping Locale
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/LocaleMappingTests.java[tags=basic-Locale-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-uuid]]
==== UUID

Hibernate allows mapping UUID values in a number of ways.  By default, Hibernate will
store UUID values in their binary form.


[NOTE]
====
The default uses the binary representation because it uses a more efficient column storage.

However, many applications prefer the readability of the character-based column storage.

// todo (6.0) : develop a better way to expose this to users
To switch the default mapping, simply call `MetadataBuilder.applyBasicType( UUIDCharType.INSTANCE, UUID.class.getName() )`.
====

===== UUID as binary

As mentioned, the default mapping for UUID attributes.
Maps the UUID to a `byte[]` using `java.util.UUID#getMostSignificantBits` and `java.util.UUID#getLeastSignificantBits` and stores that as `BINARY` data.

Chosen as the default simply because it is generally more efficient from a storage perspective.

===== UUID as (var)char

Maps the UUID to a String using `java.util.UUID#toString` and `java.util.UUID#fromString` and stores that as `CHAR` or `VARCHAR` data.

===== PostgreSQL-specific UUID

[IMPORTANT]
====
When using one of the PostgreSQL Dialects, the PostgreSQL-specific UUID Hibernate type becomes the default UUID mapping.
====

Maps the UUID using the PostgreSQL-specific UUID data type.
The PostgreSQL JDBC driver chooses to map its UUID type to the `OTHER` code.
Note that this can cause difficulty as the driver chooses to map many different data types to `OTHER`.

===== UUID as identifier

Hibernate supports using UUID values as identifiers, and they can even be generated on the user's behalf.
For details, see the discussion of generators in <<chapters/domain/identifiers.adoc#identifiers,_Identifiers_>>.






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-enums]]
==== Mapping enums

Hibernate supports the mapping of Java enums as basic value types in a number of different ways.

[[basic-enums-Enumerated]]
===== `@Enumerated`

The original JPA-compliant way to map enums was via the `@Enumerated` or `@MapKeyEnumerated`  annotations, working on the principle that the enum values are stored according to one of 2 strategies indicated by `javax.persistence.EnumType`:

`ORDINAL`::
stored according to the enum value's ordinal position within the enum class, as indicated by `java.lang.Enum#ordinal`
`STRING`::
stored according to the enum value's name, as indicated by `java.lang.Enum#name`

Assuming the following enumeration:

.`PhoneType` enumeration
====
[source, JAVA, indent=0]
----
include::{modeldir}/PhoneType.java[tags=hql-examples-domain-model-example]
----
====

In the ORDINAL example, the `phone_type` column is defined as a (nullable) INTEGER type and would hold:

`NULL`:: For null values
`0`:: For the `LAND_LINE` enum
`1`:: For the `MOBILE` enum

[[basic-enums-Enumerated-ordinal-example]]
.`@Enumerated(ORDINAL)` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-example]
----
====

When persisting this entity, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-ordinal-persistence-example]]
.Persisting an entity with an `@Enumerated(ORDINAL)` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-ordinal-persistence-example.sql[]
----
====

In the STRING example, the `phone_type` column is defined as a (nullable) VARCHAR type and would hold:

`NULL`:: For null values
`LAND_LINE`:: For the `LAND_LINE` enum
`MOBILE`:: For the `MOBILE` enum

[[basic-enums-Enumerated-string-example]]
.`@Enumerated(STRING)` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/PhoneTypeEnumeratedStringTest.java[tags=basic-enums-Enumerated-string-example]
----
====

Persisting the same entity as in the `@Enumerated(ORDINAL)` example, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-string-persistence-example]]
.Persisting an entity with an `@Enumerated(STRING)` mapping
====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-string-persistence-example.sql[]
----
====

[[basic-enums-attribute-converter]]
===== Using AttributeConverter

Let's consider the following `Gender` enum which stores its values using the `'M'` and `'F'` codes.

[[basic-enums-converter-example]]
.Enum with a custom constructor
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/Gender.java[tags=basic-enums-converter-example]
----
====

You can map enums in a JPA compliant way using a JPA 2.1 AttributeConverter.

[[basic-enums-attribute-converter-example]]
.Enum mapping with `AttributeConverter` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/EnumerationConverterTest.java[tags=basic-enums-attribute-converter-example]
----
====

Here, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using AttributeConverters, see <<basic-jpa-convert>> section.

[NOTE]
====
JPA explicitly disallows the use of an `AttributeConverter` with an attribute marked as `@Enumerated`.

So, when using the `AttributeConverter` approach, be sure not to mark the attribute as `@Enumerated`.
====



[[basic-enums-custom-type]]
===== Custom type

You can also map enums using a Hibernate custom type mapping.
Let's again revisit the Gender enum example, this time using a custom Type to store the more standardized `'M'` and `'F'` codes.

[[basic-enums-custom-type-example]]
.Enum mapping with custom Type example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/EnumerationCustomTypeTest.java[tags=basic-enums-custom-type-example, indent=0]

include::{sourcedir}/basic/GenderType.java[tags=basic-enums-custom-type-example, indent=0]

include::{sourcedir}/basic/GenderJavaTypeDescriptor.java[tags=basic-enums-custom-type-example, indent=0]
----
====

Again, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using custom types, see <<basic-custom-type>> section.



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-type-contributor]]
==== TypeContributor

`org.hibernate.boot.model.TypeContributor` is a contract for overriding or extending parts of the Hibernate type
system.

There are many ways to integrate a `TypeContributor`.  The most common is to define the `TypeContributor` as
a Java service (see `java.util.ServiceLoader`).

`TypeContributor` is passed a `TypeContributions` reference, which allows registration of custom `JavaTypeDescriptor`,
`JdbcTypeDescriptor` and `BasicType` references.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bitset]]
==== Custom Java types

There are many ways to map Java types other than those covered so far.

In this section, we will use the `java.util.BitSet` type as an example and map that
using different approaches.

[[basic-bitset-example-implicit]]
.Implicit BitSet mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetImplicitTests.java[tags=basic-bitset-example-implicit]
----
====

As mentioned previously, the worst-case fallback for Hibernate mapping a basic type
which implements `Serializable` is to simply serialize it to the database.  BitSet
does implement `Serializable`, so by default Hibernate would handle this mapping by serialization

In the following sections we will look at approaches to change various aspects of how
the BitSet gets mapped to the database.


[[basic-bitset-converter]]
===== Using `AttributeConverter`

We've seen uses of `AttributeConverter` previously.

This works well in most cases and is portable across JPA providers.

[[basic-bitset-example-converter]]
.BitSet AttributeConverter
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetConverterTests.java[tags=basic-bitset-example-convert]

include::{sourcedir}/basic/BitSetConverterTests.java[tags=basic-bitset-example-converter]
----
====

The `@Convert` annotation was used for illustration.  Generally such a converter would be auto-applied instead

See <<basic-jpa-convert>> for details.

[NOTE]
====
The use of `AttributeConverter` can have drawbacks related to Hibernate being able
to appropriately handle the mutability aspects of the converted values. `AttributeConverter`
does not indicate whether the converted values are mutable or not, so Hibernate has to assume
they are (the safer assumption) which can lead to excessive conversions back and forth as part
of dirty-checking as well as second-level caching.

See <<basic-jpa-convert-mutability>> for additional details.
====


[[basic-bitset-java-type]]
===== Using a custom `JavaTypeDescriptor`

As covered in <<basic-mapping-explicit>>, any of the following can be used to specify
the `JavaTypeDescriptor` to use:

   * `@JavaTypeRegistration`
   * `@JavaType`
   * `@MapKeyJavaType`
   * `TypeContributor`

We will skip discussing `@MapKeyJavaType` because it is redundant with discussing `@JavaType`.  We will
also skip discussing using `TypeContributor` as it is discussed in <<basic-type-contributor>>.

First we will define a `JavaTypeDescriptor` for `BitSet` that maps values to `VARCHAR` for storage by default.

[[basic-bitset-example-java-type]]
.BitSet JavaTypeDescriptor
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaType.java[tags=basic-bitset-example-java-type]
----
====


We can either apply that type locally using `@JavaType`

[[basic-bitset-example-java-type-local]]
.@JavaType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaTypeTests.java[tags=basic-bitset-example-java-type-local,indent=0]
----
====

Or we can apply it globally using `@JavaTypeRegistration`

[[basic-bitset-example-java-type-global]]
.@JavaTypeRegistration
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJavaTypeRegistrationTests.java[tags=basic-bitset-example-java-type-global,indent=0]
----
====


[[basic-bitset-jdbc-type]]
===== Selecting different `JdbcTypeDescriptor`

As covered in <<basic-mapping-explicit>>, any of the following can be used to specify
the `JdbcTypeDescriptor` to use:

* `@JdbcTypeRegistration`
* `@JdbcType`
* `@JdbcTypeCode`
* `@MapKeyJdbcType`
* `@MapKeyJdbcTypeCode`
* `TypeContributor`

We will skip discussing `@MapKeyJdbcType` and `@MapKeyJdbcTypeCode` because they are redundant with
discussing `@JdbcType` and `@JdbcTypeCode`.  We will also skip discussing using `TypeContributor` as
it is discussed in <<basic-type-contributor>>.

Our custom `BitSetJavaType` class already has support for being able to map `BitSet` values as binary
data as well through its coercion support.

The following examples for specifying the `JdbcTypeDescriptor` assume our `BitSetJavaType`
is globally registered.

We will again store the values as `VARBINARY` in the database.  The difference now however is that
the coercion methods `#wrap` and `#unwrap` will be used to prepare the value rather than relying on
serialization.


[[basic-bitset-example-jdbc-type-code]]
.@JdbcTypeCode
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeCodeTests.java[tags=basic-bitset-example-jdbc-type-code,indent=0]
----
====

In this example, `@JdbcTypeCode` has been used to indicate that the `JdbcTypeDescriptor` registered for JDBC's
`VARBINARY` type should be used.

A specific `JdbcTypeDescriptor` implementation can be specified either locally using `@JdbcType` or
globally using `@JdbcTypeRegistration`


[[basic-bitset-example-jdbc-type-local]]
.@JdbcType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeTests.java[tags=basic-bitset-example-jdbc-type-local,indent=0]
----
====

In this example, `@JdbcType` has been used to specify our custom `BitSetJdbcType` descriptor locally for
this attribute.

We could instead replace how Hibernate deals with all `VARBINARY` handling with our custom impl using
`@JdbcTypeRegistration`

[[basic-bitset-example-jdbc-type-global]]
.@JdbcType
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/BitSetJdbcTypeRegistrationTests.java[tags=basic-bitset-example-jdbc-type-global,indent=0]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-jpa-convert]]
==== AttributeConverters

Although Hibernate has long been offering <<basic-custom-type,custom types>>, as a JPA 2.1 provider,
it also supports `AttributeConverter` as well.

With a custom `AttributeConverter`, the application developer can map a given JDBC type to an entity basic type.

In the following example, the `java.time.Period` is going to be mapped to a `VARCHAR` database column.

[[basic-jpa-convert-period-string-converter-example]]
.`java.time.Period` custom `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringConverter.java[tags=basic-jpa-convert-period-string-converter-example]
----
====

To make use of this custom converter, the `@Convert` annotation must decorate the entity attribute.

[[basic-jpa-convert-period-string-converter-mapping-example]]
.Entity using the custom `java.time.Period` `AttributeConverter` mapping
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----
====

When persisting such entity, Hibernate will do the type conversion based on the `AttributeConverter` logic:

[[basic-jpa-convert-period-string-converter-sql-example]]
.Persisting entity using the custom `AttributeConverter`
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-jpa-convert-period-string-converter-sql-example.sql[]
----
====

An `AttributeConverter` can be applied globally for (`@Converter( autoApply=true )`) or locally.


[[basic-jpa-convert-type]]
===== `AttributeConverter` Java and JDBC types

In cases when the Java type specified for the "database side" of the conversion (the second `AttributeConverter` bind parameter) is not known,
Hibernate will fallback to a `java.io.Serializable` type.

If the Java type is not known to Hibernate, you will encounter the following message:

> HHH000481: Encountered Java type for which we could not locate a JavaTypeDescriptor and which does not appear to implement equals and/or hashCode.
> This can lead to significant performance problems when performing equality/dirty checking involving this Java type.
> Consider registering a custom JavaTypeDescriptor or at least implementing equals/hashCode.

A Java type is "known" if it has an entry in the `JavaTypeDescriptorRegistry`.  While Hibernate does load many JDK types into
the `JavaTypeDescriptorRegistry`, an application can also expand the `JavaTypeDescriptorRegistry` by adding new `JavaTypeDescriptor`
entries.  This way, Hibernate will also know how to handle a specific Java Object type at the JDBC level.




[[basic-hbm-attribute-converter]]
===== Mapping an AttributeConverter using HBM mappings

When using HBM mappings, you can still make use of the JPA `AttributeConverter` because Hibernate supports
such mapping via the `type` attribute as demonstrated by the following example.

Let's consider we have an application-specific `Money` type:

[[basic-hbm-attribute-converter-mapping-money-example]]
.Application-specific `Money` type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/Money.java[tags=basic-hbm-attribute-converter-mapping-money-example]
----
====

Now, we want to use the `Money` type when mapping the `Account` entity:

[[basic-hbm-attribute-converter-mapping-account-example]]
.`Account` entity using the `Money` type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/Account.java[tags=basic-hbm-attribute-converter-mapping-account-example]
----
====

Since Hibernate has no knowledge how to persist the `Money` type, we could use a JPA `AttributeConverter`
to transform the `Money` type as a `Long`. For this purpose, we are going to use the following
`MoneyConverter` utility:

[[basic-hbm-attribute-converter-mapping-moneyconverter-example]]
.`MoneyConverter` implementing the JPA `AttributeConverter` interface
====
[source, JAVA, indent=0]
----
include::{sourcedir}/converter/hbm/MoneyConverter.java[tags=basic-hbm-attribute-converter-mapping-moneyconverter-example]
----
====

To map the `MoneyConverter` using HBM configuration files you need to use the `converted::` prefix in the `type`
attribute of the `property` element.

[[basic-hbm-attribute-converter-mapping-xml-config-example]]
.HBM mapping for `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{resourcedir}/mapping/converter/hbm/MoneyConverterHbmTest.hbm.xml[]
----
====




[[basic-jpa-convert-mutability]]
===== `AttributeConverter` Mutability Plan

A basic type that's converted by a JPA `AttributeConverter` is immutable if the underlying Java type is immutable
and is mutable if the associated attribute type is mutable as well.

Therefore, mutability is given by the https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/type/descriptor/java/JavaTypeDescriptor.html#getMutabilityPlan--[`JavaTypeDescriptor#getMutabilityPlan`]
of the associated entity attribute type.

// todo (6.0) : discuss `@Immutable` and `@Mutability`


====== Immutable types

If the entity attribute is a `String`, a primitive wrapper (e.g. `Integer`, `Long`), an Enum type, or any other immutable `Object` type,
then you can only change the entity attribute value by reassigning it to a new value.

Considering we have the same `Period` entity attribute as illustrated in the <<basic-jpa-convert>> section:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----

The only way to change the `span` attribute is to reassign it to a different value:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-immutability-plan-example]
----

====== Mutable types

On the other hand, consider the following example where the `Money` type is a mutable.

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mapping-example]
----

A mutable `Object` allows you to modify its internal structure, and Hibernate dirty checking mechanism is going to propagate the change to the database:

[source, JAVA, indent=0]
----
include::{sourcedir}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mutability-plan-example]
----

[TIP]
====
Although the `AttributeConverter` types can be mutable so that dirty checking, deep copying, and second-level caching work properly,
treating these as immutable (when they really are) is more efficient.

For this reason, prefer immutable types over mutable ones whenever possible.
====



[[basic-attribute-converter-query-parameter]]
====== Using the AttributeConverter entity property as a query parameter

Assuming you have the following entity:

[[basic-attribute-converter-query-parameter-entity-example]]
.`Photo` entity with `AttributeConverter`
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-entity-example]
----
====

And the `Caption` class looks as follows:

[[basic-attribute-converter-query-parameter-object-example]]
.`Caption` Java object
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-object-example]
----
====

And we have an `AttributeConverter` to handle the `Caption` Java object:

[[basic-attribute-converter-query-parameter-converter-example]]
.`Caption` Java object AttributeConverter
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-example]
----
====

Traditionally, you could only use the DB data `Caption` representation, which in our case is a `String`, when referencing the `caption` entity property.

[[basic-attribute-converter-query-parameter-converter-dbdata-example]]
.Filtering by the `Caption` property using the DB data representation
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-dbdata-example]
----
====

In order to use the Java object `Caption` representation, you have to get the associated Hibernate `Type`.

[[basic-attribute-converter-query-parameter-converter-object-example]]
.Filtering by the `Caption` property using the Java Object representation
====
[source, JAVA, indent=0]
----
include::{converter-sourcedir}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-object-example]
----
====

By passing the associated Hibernate `Type`, you can use the `Caption` object when binding the query parameter value.









// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[[mapping-quoted-identifiers]]
==== SQL quoted identifiers

You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document.
While traditionally, Hibernate used backticks for escaping SQL reserved keywords, JPA uses double quotes instead.

Once the reserved keywords are escaped, Hibernate will use the correct quotation style for the SQL `Dialect`.
This is usually double quotes, but SQL Server uses brackets and MySQL uses backticks.

[[basic-quoting-example]]
.Hibernate legacy quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/QuotingTest.java[tags=basic-quoting-example]
----
====

[[basic-jpa-quoting-example]]
.JPA quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/JpaQuotingTest.java[tags=basic-jpa-quoting-example]
----
====

Because `name` and `number` are reserved words, the `Product` entity mapping uses backticks to quote these column names.

When saving the following `Product entity`, Hibernate generates the following SQL insert statement:

[[basic-quoting-persistence-example]]
.Persisting a quoted column name
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/QuotingTest.java[tags=basic-quoting-persistence-example, indent=0]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-quoting-persistence-example.sql[indent=0]
----
====

[[mapping-global-quoted-identifiers]]
===== Global quoting

Hibernate can also quote all identifiers (e.g. table, columns) using the following configuration property:

====
[source,xml]
----
<property
    name="hibernate.globally_quoted_identifiers"
    value="true"
/>
----
====

This way, we don't need to manually quote any identifier:

[[basic-auto-quoting-example]]
.JPA quoting
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/AutoQuotingTest.java[tags=basic-auto-quoting-example]
----
====

When persisting a `Product` entity, Hibernate is going to quote all identifiers as in the following example:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-auto-quoting-persistence-example.sql[indent=0]
----
====

As you can see, both the table name and all the column have been quoted.

For more about quoting-related configuration properties, check out the <<appendices/Configurations.adoc#configurations-mapping,Mapping configurations>> section as well.




















[[mapping-generated]]
==== Generated properties

Generated properties are properties that have their values generated by the database.
Typically, Hibernate applications needed to `refresh` objects that contain any properties for which the database was generating values.
Marking properties as generated, however, lets the application delegate this responsibility to Hibernate.
When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select to retrieve the generated values.

Properties marked as generated must additionally be _non-insertable_ and _non-updateable_.
Only `@Version` and `@Basic` types can be marked as generated.

`NEVER` (the default):: the given property value is not generated within the database.
`INSERT`:: the given property value is generated on insert but is not regenerated on subsequent updates. Properties like _creationTimestamp_ fall into this category.
`ALWAYS`:: the property value is generated both on insert and update.

To mark a property as generated, use The Hibernate specific `@Generated` annotation.

[[mapping-generated-Generated]]
===== `@Generated` annotation

The https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/Generated.html[`@Generated`] annotation is used so that Hibernate can fetch the currently annotated property after the entity has been persisted or updated.
For this reason, the `@Generated` annotation accepts a https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/GenerationTime.html[`GenerationTime`] enum value.

Considering the following entity:

[[mapping-generated-Generated-example]]
.`@Generated` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-Generated-example]
----
====

When the `Person` entity is persisted, Hibernate is going to fetch the calculated `fullName` column from the database,
which concatenates the first, middle, and last name.

[[mapping-generated-Generated-persist-example]]
.`@Generated` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-Generated-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-Generated-persist-example.sql[]
----
====

The same goes when the `Person` entity is updated.
Hibernate is going to fetch the calculated `fullName` column from the database after the entity is modified.

[[mapping-generated-Generated-update-example]]
.`@Generated` update example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratedTest.java[tags=mapping-generated-Generated-update-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-Generated-update-example.sql[]
----
====

[[mapping-generated-GeneratorType]]
===== `@GeneratorType` annotation

The https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/GeneratorType.html[`@GeneratorType`] annotation is used so that
you can provide a custom generator to set the value of the currently annotated property.

For this reason, the `@GeneratorType` annotation accepts a https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/GenerationTime.html[`GenerationTime`] enum value
and a custom https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/ValueGenerator.html[`ValueGenerator`] class type.

Considering the following entity:

[[mapping-generated-GeneratorType-example]]
.`@GeneratorType` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratorTypeTest.java[tags=mapping-generated-GeneratorType-example]
----
====

When the `Person` entity is persisted, Hibernate is going to populate the `createdBy` column with the currently logged user.

[[mapping-generated-GeneratorType-persist-example]]
.`@GeneratorType` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratorTypeTest.java[tags=mapping-generated-GeneratorType-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-GeneratorType-persist-example.sql[]
----
====

The same goes when the `Person` entity is updated.
Hibernate is going to populate the `updatedBy` column with the currently logged user.

[[mapping-generated-GeneratorType-update-example]]
.`@GeneratorType` update example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/GeneratorTypeTest.java[tags=mapping-generated-GeneratorType-update-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-GeneratorType-update-example.sql[]
----
====

[[mapping-generated-CreationTimestamp]]
===== `@CreationTimestamp` annotation

The `@CreationTimestamp` annotation instructs Hibernate to set the annotated entity attribute with the current timestamp value of the JVM
when the entity is being persisted.

The supported property types are:

- `java.util.Date`
- `java.util.Calendar`
- `java.sql.Date`
- `java.sql.Time`
- `java.sql.Timestamp`

[[mapping-generated-CreationTimestamp-example]]
.`@CreationTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/CreationTimestampTest.java[tags=mapping-generated-CreationTimestamp-example]
----
====

When the `Event` entity is persisted, Hibernate is going to populate the underlying `timestamp` column with the current JVM timestamp value:

[[mapping-generated-CreationTimestamp-persist-example]]
.`@CreationTimestamp` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/CreationTimestampTest.java[tags=mapping-generated-CreationTimestamp-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-CreationTimestamp-persist-example.sql[]
----
====

[[mapping-generated-UpdateTimestamp]]
===== `@UpdateTimestamp` annotation

The `@UpdateTimestamp` annotation instructs Hibernate to set the annotated entity attribute with the current timestamp value of the JVM
when the entity is being persisted.

The supported property types are:

- `java.util.Date`
- `java.util.Calendar`
- `java.sql.Date`
- `java.sql.Time`
- `java.sql.Timestamp`

[[mapping-generated-UpdateTimestamp-example]]
.`@UpdateTimestamp` mapping example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-UpdateTimestamp-example]
----
====

When the `Bid` entity is persisted, Hibernate is going to populate the underlying `updated_on` column with the current JVM timestamp value:

[[mapping-generated-UpdateTimestamp-persist-example]]
.`@UpdateTimestamp` persist example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-UpdateTimestamp-persist-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-UpdateTimestamp-persist-example.sql[]
----
====

When updating the `Bid` entity, Hibernate is going to modify the `updated_on` column with the current JVM timestamp value:

[[mapping-generated-UpdateTimestamp-update-example]]
.`@UpdateTimestamp` update example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/UpdateTimestampTest.java[tags=mapping-generated-UpdateTimestamp-update-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-generated-UpdateTimestamp-update-example.sql[]
----
====

[[mapping-generated-ValueGenerationType]]
===== `@ValueGenerationType` meta-annotation

Hibernate 4.3 introduced the `@ValueGenerationType` meta-annotation, which is a new approach to declaring generated attributes or customizing generators.

`@Generated` has been retrofitted to use the `@ValueGenerationType` meta-annotation.
But `@ValueGenerationType` exposes more features than what `@Generated` currently supports, and,
to leverage some of those features, you'd simply wire up a new generator annotation.

As you'll see in the following examples, the `@ValueGenerationType` meta-annotation is used when declaring the custom annotation used to mark the entity properties that need a specific generation strategy.
The actual generation logic must be added to the class that implements the `AnnotationValueGeneration` interface.

[[mapping-database-generated-value]]
====== Database-generated values

For example, let's say we want the timestamps to be generated by calls to the standard ANSI SQL function `current_timestamp` (rather than triggers or DEFAULT values):

[[mapping-database-generated-value-example]]
.A `ValueGenerationType` mapping for database generation
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/DatabaseValueGenerationTest.java[tags=mapping-database-generated-value-example]
----
====

When persisting an `Event` entity, Hibernate generates the following SQL statement:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-database-generated-value-example.sql[]
----
====

As you can see, the `current_timestamp` value was used for assigning the `timestamp` column value.

[[mapping-in-memory-generated-value]]
====== In-memory-generated values

If the timestamp value needs to be generated in-memory, the following mapping must be used instead:

[[mapping-in-memory-generated-value-example]]
.A `ValueGenerationType` mapping for in-memory value generation
====
[source, JAVA, indent=0]
----
include::{sourcedir}/generated/InMemoryValueGenerationTest.java[tags=mapping-in-memory-generated-value-example]
----
====

When persisting an `Event` entity, Hibernate generates the following SQL statement:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-in-memory-generated-value-example.sql[]
----
====

As you can see, the `new Date()` object value was used for assigning the `timestamp` column value.





























[[mapping-column-read-and-write]]
==== Column transformers: read and write expressions

Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to `@Basic` types.
For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like in the following example.

[[mapping-column-read-and-write-example]]
.`@ColumnTransformer` example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/../fetching/FetchingTest.java[tags=mapping-column-read-and-write-example]
----
====

If a property uses more than one column, you must use the `forColumn` attribute to specify which column the `@ColumnTransformer` read and write expressions are targeting.

[[mapping-column-read-and-write-composite-type-example]]
.`@ColumnTransformer` `forColumn` attribute usage
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-example]
----
====

Hibernate applies the custom expressions automatically whenever the property is referenced in a query.
This functionality is similar to a derived-property <<mapping-column-formula>> with two differences:

* The property is backed by one or more columns that are exported as part of automatic schema generation.
* The property is read-write, not read-only.

The `write` expression, if specified, must contain exactly one '?' placeholder for the value.

[[mapping-column-read-and-write-composite-type-persistence-example]]
.Persisting an entity with a `@ColumnTransformer` and a composite type
====
[source, JAVA, indent=0]
----
include::{sourcedir}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-read-and-write-composite-type-persistence-example.sql[]
----
====






