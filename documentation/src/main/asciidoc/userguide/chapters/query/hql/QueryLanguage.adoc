[[query-language]]
== Hibernate Query Language
:modeldir: ../../../../../../main/java/org/hibernate/userguide/model
:sourcedir: ../../../../../../test/java/org/hibernate/userguide/hql
:extrasdir: extras

This chapter describes Hibernate Query Language (HQL) and Jakarta Persistence Query Language (JPQL).

[NOTE]
====
JPQL was inspired by early versions of HQL, and is a subset of modern HQL.
Here we focus on describing the complete, more powerful HQL language as it exists today.

If strict Jakarta Persistence compliance is desired, use the setting `hibernate.jpa.compliance.query=true`.
With this configuration, any attempt to use HQL features beyond the JPQL subset will result in an exception.
We don't recommend the use of this setting.
====

HQL (and JPQL) are loosely based on SQL and are easy to learn for anyone familiar with SQL.

[[hql-case-sensitivity]]
=== Case Sensitivity

Case sensitivity depends on the language element:

- keywords, identification variable names, and function names are case-insensitive, but
- Java class names, and the names of attributes of Java classes, are case-sensitive.

So `SeLeCT` is the same as `sELEct` is the same as `select`, but `org.hibernate.eg.FOO` and `org.hibernate.eg.Foo` are different, as are `foo.barSet` and `foo.BARSET`.

[NOTE]
====
It is standard practice to use lowercase keywords in HQL and JPQL.

The use of uppercase keywords indicates an endearing but unhealthy attachment to the culture of the 1970's.
====

[[hql-statement-types]]
=== Statement types

HQL features four different kinds of statement:

* `select` queries,
* `update` statements,
* `delete` statements, and
* `insert ... values` and `insert ... select` statements.

[IMPORTANT]
====
The effect of an `update` and `delete` statement is not reflected in the persistence context, nor in the state of entity objects held in memory at the time the statement is executed.

It is the responsibility of the application maintain synchronization of state held in memory with the database after execution of an `update` or `delete` statement.
====

[[hql-select]]
==== Select statements

The full https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form[BNF] for a `select` query is quite complicated.

[[hql-select-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_select_bnf.txt[]
----
====

Most of the complexity here arises from the interplay of set operators (`union`, `intersect`, and `except`) with ordering.

We'll describe the various clauses of a query later in this chapter, but to summarize, a query might have:

* a `select` list, specifying a projection (the things to return from the query),
* a `from` clause and joins, specifying the entities involved in the query,
* a `where` clause, specifying a restriction,
* a `group by` clause, for aggregation,
* a `having` clause, specifying a restriction to apply _after_ aggregation,
* set operators applied to the results of multiple subqueries,
* an `order by` clause, for ordering the results, and even
* a `limit`/`offset` clause, for limiting the results.

Every one of these clauses is optional!

For example, the simplest query in HQL has no `select` clause at all:

[[hql-select-simplest-example]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-example]
----
====

[NOTE]
====
JPQL requires a `select` clause, whereas HQL does not.
Naturally, the previous query may be written with a `select` clause:

[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-jpql-example]
----

For complicated queries, it's probably best to explicitly specify a `select` list.
====

An alternative "simplest" query has _only_ a `select` list:

[[hql-select-simplest-example-alt]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-example-alt]
----
====

This results in a SQL `from dual` query (or equivalent).

[TIP]
====
Looking carefully at the BNF given above, you might notice that the `select` list may occur either at the beginning of a query, or near the end, right before `order by`.

Of course, standard SQL, and JPQL, require that the `select` list comes at the beginning.
But it's more natural to put it last:

[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-last-example]
----

This form of the query is more readable, because the alias is declared _before_ it's used, just as God and nature intended.
====

[[hql-update]]
==== Update statements

The BNF for an `update` statement is much easier to understand:

[[hql-update-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_update_bnf.txt[]
----
====

For example:

[[hql-update-example]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-update-example]
----
====

[IMPORTANT]
====
No `update` or `delete` statement may have an implicit (or explicit) join.
====

An `update` statement must be executed using `Query#executeUpdate()`.
A single HQL `update` statement might result in multiple SQL update statements executed against the database.

[NOTE]
====
The integer value returned by `executeUpdate()` indicates the number of entity instances affected by the operation.
In a `JOINED` inheritance hierarchy, multiple rows are required to store a single entity instance.
In this case, the update count returned by Hibernate might not be exactly the same as the number of rows affected in the database.
====

An `update` statement, by default, does not affect the `@Version` column of the affected entities.

Adding the keyword `versioned`&mdash;writing `update versioned`&mdash;specifies that Hibernate should update the version or update timestamp.

[NOTE]
====
`update versioned` does not work with custom version types defined by implementing `UserVersionType`, and is not available in JPQL.
====

[[hql-update-examples]]
//.Example update queries
====
[source, SQL, indent=0]
----
include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-jpql-update-example]

include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-hql-update-example]

include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-hql-update-version-example]
----
====

[[hql-delete]]
==== Delete statements

The BNF for a `delete` statement is also quite simple:

[[hql-delete-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_delete_bnf.txt[]
----
====

A `delete` statement is executed by calling `Query#executeUpdate()`.

[[hql-insert]]
==== Insert statements

There are two kinds of `insert` statement:

- `insert ... values`, where the attribute values to insert are given directly, and
- `insert ... select`, where the inserted attribute values are sourced from a subquery.

The first form inserts a single row in the database.
The second form may insert many new rows, or none at all.

[TIP]
====
The first sort of `insert` statement is not very useful.
It's better to just use `persist()`.
====

The BNF for an `insert` statement is:

[[hql-insert-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_insert_bnf.txt[]
----
====

For example:

[[hql-insert-example]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-insert-example]
----

[source, SQL, indent=0]
----
include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-hql-insert-example]
----
====

An `insert` statement must be executed by calling `Query#executeUpdate()`.

[IMPORTANT]
====
`insert` statements are inherently _not_ polymorphic!
The `targetFields` list is of fixed length, whereas each subclass of an entity class might declare additional fields.
If the entity is involved in a mapped inheritance hierarchy, only attributes declared directly by the named entity and its superclasses may occur in the list of target fields.
Attributes declared by subclasses may not occur.
====

The `queryExpression` may be any valid `select` query, with the caveat that the types of the values in the `select` list must match the types of the target fields.

[NOTE]
====
This is checked during query compilation rather than allowing the type check to delegate to the database.
This may cause problems when two Java types map to the same database type.
For example, an attribute of type `LocalDateTime` and an attribute or type `Timestamp` both map to the SQL type `timestamp`, but are not considered assignable by the query compiler.
====

There are two ways to assign a value to the `@Id` attribute:

- explicitly specify the id attribute in the list of target fields, and its value in the values assigned to the target fields, or
- omit it, in which case a generated value is used.

Of course, the second option is only available for entities with database-level id generation (sequences or identity/autoincrement columns).
It's not available for entities whose id generator is implemented in Java, nor for entities whose id is assigned by the application.

The same two options are available for a `@Version` attribute.
When no version is explicitly specified, the version for a new entity instance is used.

[NOTE]
====
`insert ... select` statements are not available in JPQL.
====

[[hql-literals]]
=== Literals

We now switch gears, and begin describing the language from the bottom up.
The very bottom of a programming language is its syntax for literal values.

The most important literal value in this language is `null`. It's assignable to any other type.

[[hql-boolean-literals]]
==== Boolean literals

The boolean literal values are the (case-insensitive) keywords `true` and `false`.

[[hql-string-literals]]
==== String literals

String literals are enclosed in single quotes.

To escape a single quote within a string literal, use a doubled single quote: `''`.

[[hql-string-literals-example]]
//.String literals examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-string-literals-example]
----
====

==== Numeric literals

Numeric literals come in several different forms.

[[hql-numeric-literals-example]]
//.Numeric literal examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-numeric-literals-example]
----
====

The type of a numeric literal may be specified using a Java-style postfix:
|===
| Postfix | Type | Java type

| `L` or `l` | long integer | `long`
| `D` or `d` | double precision | `double`
| `F` or `f` | single precision | `float`
| `BI` or `bi` | large integer | `BigInteger`
| `BD` or `bd` | exact decimal | `BigDecimal`
|===

It's not usually necessary to specify the precision explicitly.

[NOTE]
====
In a literal with an exponent, the `E` is case-insensitive.
Similarly, the Java-style postfix is case-insensitive.
====

Hexadecimal literals may be written using the same syntax as Java: `0X1A2B` or `0x1a2b`.

[[hql-datetime-literals]]
==== Date and time literals

According to the JPQL specification, date and time literals may be specified using the JDBC escape syntax.
Since this syntax is rather unpleasant to look at, HQL provides not one, but two alternatives.

|===
| Date/time type | Recommended Java type | JDBC escape syntax | Braced literal syntax | Explicitly typed literal syntax

| Date | `LocalDate` | `{d 'yyyy-mm-dd'}` | `{yyyy-mm-dd}` | `date yyyy-mm-dd`
| Time | `LocalTime` | `{t 'hh:mm'}` | `{hh:mm}` | `time hh:mm`
| Time with seconds | `LocalTime` | `{t 'hh:mm:ss'}` | `{hh:mm:ss}` | `time hh:mm:ss`
| Datetime | `LocalDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss'}` | `{yyyy-mm-dd hh:mm:ss}` | `datetime yyyy-mm-dd hh:mm:ss`
| Datetime with milliseconds | `LocalDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss.millis'}` | `{yyyy-mm-dd hh:mm:ss.millis}` | `datetime yyyy-mm-dd hh:mm:ss.millis`
| Datetime with an offset | `OffsetDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss+hh:mm'}` | `{yyyy-mm-dd hh:mm:ss +hh:mm}` | `datetime yyyy-mm-dd hh:mm:ss +hh:mm`
| Datetime with a time zone | `OffsetDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss GMT'}` | `{yyyy-mm-dd hh:mm:ss GMT}` | `datetime yyyy-mm-dd hh:mm:ss GMT`
|===

Literals referring to the current date and time are also provided.
Again there is some flexibility.

|===
| Date/time type | Java type | Underscore syntax | Spaced syntax

| Date | `java.time.LocalDate` | `local_date` | `local date`
| Time | `java.time.LocalTime` | `local_time` | `local time`
| Datetime | `java.time.LocalDateTime` | `local_datetime` | `local datetime`
| Offset datetime | `java.time.OffsetDateTime`| `offset_datetime` | `offset datetime`
| Instant | `java.time.Instant` | `instant` | `instant`
| Date | `java.sql.Date` | `current_date` | `current date`
| Time | `java.sql.Time` | `current_time` | `current time`
| Datetime | `java.sql.Timestamp` | `current_timestamp` | `current timestamp`
|===

[IMPORTANT]
====
Of these, only `current_date`, `current_time`, and `current_timestamp` are defined by the JPQL specification.

However, the use of date and time types from the `java.sql` package is strongly discouraged, so we encourage the use of the HQL extensions.
====

[[hql-duration-literals]]
==== Duration literals

There are two sorts of duration in HQL:

* year/quarter/month/week/day durations, and
* week/day/hour/minute/second/nanosecond durations.

Literal duration expressions are of form `n unit`, for example `1 day` or `10 year` or `100 nanosecond`.

[NOTE]
====
A HQL duration is considered to map to a Java `java.time.Duration`, but semantically they're perhaps more similar to an ANSI SQL `INTERVAL` type.
====

[[hql-binary-literals]]
==== Binary string literals

HQL also provides a choice of formats for binary strings:

* the braced syntax `{0xDE, 0xAD, 0xBE, 0xEF}`, a list of Java-style hexadecimal byte literals, or
* the quoted syntax `X'DEADBEEF'` or `x'deadbeef'`, similar to SQL.

[[hql-enum-literals]]
==== Enum literals

Literal values of a Java enumerated type may be written without needing to specify the enum class name:

[[hql-enum-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-enum-example]
----
====

Here, the enum class is inferred from the type of the expression on the left of the relational operator.

[[hql-java-constants]]
==== Java constants

HQL allows any Java `static` constant to be used in HQL, but it must be referenced by its fully-qualified name:

[[hql-java-constant-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-java-constant-example]
----
====

[[hql-entity-name-literals]]
==== Literal entity names

Entity names may also occur as a literal value. They do not need to be qualified. See <<hql-treat-type>>.

[[hql-expressions]]
=== Expressions

Essentially, expressions are references that resolve to basic or tuple values.

[[hql-concatenation]]
==== String concatenation

HQL defines two ways to concatenate strings:

* the SQL-style concatenation operator, `||`, and
* the JPQL-standard `concat()` function.

See <<jpql-standardized-functions,below>> for details of the `concat()` function.

[[hql-concatenation-example]]
//.Concatenation operation example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-concatenation-example]
----
====

Many more operations on strings are defined below, in <<hql-exp-functions>>.

[[hql-numeric-arithmetic]]
==== Numeric arithmetic

The basic SQL arithmetic operators, `+`,`-`,`*`, and `/` are joined by the remainder operator `%`.

[[hql-numeric-arithmetic-example]]
//.Numeric arithmetic examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-numeric-arithmetic-example]
----
====

The following rules apply to the result of arithmetic operations:

* If either of the operands is `Double`/`double`, the result is a `Double`
* else, if either of the operands is `Float`/`float`, the result is a `Float`
* else, if either operand is `BigDecimal`, the result is `BigDecimal`
* else, if either operand is `BigInteger`, the result is `BigInteger` (except for division, in which case the result type is not further defined)
* else, if either operand is `Long`/`long`, the result is `Long` (except for division, in which case the result type is not further defined)
* else, (the assumption being that both operands are of integral type) the result is `Integer` (except for division, in which case the result type is not further defined)

Many more numeric operations are defined below, in <<hql-exp-functions>>.

[[hql-Datetime-arithmetic]]
==== Datetime arithmetic

Arithmetic involving dates, datetimes, and durations is quite subtle.
Here we list the basic operations.

|===
| Operator | Expression type | Example | Resulting type

| `-` | Difference between two dates | `your.birthday - local date` | year/quarter/month/week/day duration
| `-` | Difference between two datetimes | `local datetime - record.lastUpdated` | week/day/hour/minute/second/nanosecond duration
| `+` | Sum of a date and a year/quarter/month/week/day duration | `local date + 1 week` | date
| `+` | Sum of a datetime and a week/day/hour/minute/second/nanosecond duration | `record.lastUpdated + 1 second` | datetime
| `*` | Product of an integer and a duration | `billing.cycles * 30 day` | duration
| `by unit` | Convert a duration to an integer | `(1 year) by day` | integer
|===

The `by unit` operator converts a duration to an integer, for example: `(local date - your.birthday) by day` evaluates to the number of days you still have to wait.

The function `extract(unit from ...)` extracts a field from a date, time, or datetime type, for example, `extract(year from your.birthday)` produces the year in which you were born, and throws away important information about your birthday.

[IMPORTANT]
====
Please carefully note the difference between these two operations: `by` and `extract()` both evaluate to an integer, but they have very different uses.
====

Additional datetime operations, including the useful `format()` function, are defined below, in <<hql-exp-functions>>.

[[hql-path-expressions]]
==== Identification variables and path expressions

Identification variables, and path expressions beginning with an identification variable are legal expression in almost every context.

See <<hql-from-clause>>.

[[hql-case-expressions]]
==== Case expressions

Just like in standard SQL, there are two forms of case expression:

* the _simple_ case expression, and
* the so-called _searched_ case expression.

[TIP]
====
Case expressions are verbose.
It's often simpler to use the `coalesce()`, `nullif()`, or `ifnull()` functions.
====

[[hql-simple-case-expressions]]
===== Simple case expressions

The syntax of the simple form is defined by:

[[hql-simple-case-expressions-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/simple_case_bnf.txt[]
----

For example:

[[hql-simple-case-expressions-example]]
//.Simple case expression example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-simple-case-expressions-example]
----
====

[[hql-searched-case-expressions]]
===== Searched case expressions

The searched form has the following syntax:

[[hql-searched-case-expressions-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/searched_case_bnf.txt[]
----

For example:

[[hql-searched-case-expressions-example]]
//.Searched case expression example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-searched-case-expressions-example]
----
====

[[hql-case-arithmetic-expressions]]
===== Case expressions with arithmetic operations

Any arithmetic operation in the `case` expression must be enclosed in parentheses, as illustrated by the following example:

[[hql-case-arithmetic-expressions-example]]
//.Case expression with arithmetic operation example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-case-arithmetic-expressions-example]
----
====

[IMPORTANT]
====
If the arithmetic expression was not enclosed in parentheses, the parser would be unable to parse the expression.
====


[[hql-exp-functions]]
=== Functions

Both HQL and JPQL define some standard functions that are portable between databases.

In some cases, the syntax of these functions looks a bit funny at first, for example, `cast(number as String)`, or `extract(year from date)`, or even `trim(leading '.' from string)`.
This syntax is inspired by standard ANSI SQL, and we promise you'll get used to it.


[IMPORTANT]
====
HQL abstracts away from the actual database-native SQL functions, letting you write queries which are portable between databases.

For some functions, and always depending on the database, a HQL function invocation translates to a quite complicated SQL expression!
====

In addition, there are several ways to use a database function that's not known to Hibernate.

[[hql-treat-type]]
==== Types and typecasts

The special function `type()`, applied to an identification variable, evaluates to the entity name of the referenced entity.
This is mainly useful when dealing with entity inheritance hierarchies.

[[hql-entity-type-exp-example]]
//.Entity type expression examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-entity-type-exp-example]
----
====

The special function `treat()` may be used to narrow the type of an identification variable.
This is useful when dealing with entity inheritance hierarchies.

[[hql-treat-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-treat-example]
----
====

The type of the expression `treat(p as CreditCardPayment)` is the narrowed type, `CreditCardPayment`, instead of the declared type `Payment` of `p`.
This allows the attribute `cardNumber` declared by the subtype `CreditCardPayment` to be referenced.

The `treat()` function may even occur in a <<hql-join-treat,join>>.

[[jpql-standardized-functions]]
==== JPQL standard functions

Here we present the list of functions defined by JPQL.

[TIP]
====
A program that wishes to remain portable between Jakarta Persistence providers should in principle limit itself to the use of these functions.

On the other hand, this is an extremely short list. Any nontrivial program will probably need to look beyond it.
====

===== `nullif()`

An abbreviated `case` expression that evaluates to null if its operands are equal.

[[hql-nullif-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-nullif-example]
----
====

===== `coalesce()`

An abbreviated `case` expression that returns the first non-null operand.

[[hql-coalesce-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-coalesce-example]
----
====

TIP: HQL allows `ifnull()` as a synonym for `coalesce()` in the case of exactly two arguments.

===== `concat()`
Produces a string by concatenating its arguments.

Accepts a variable number of arguments.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-concat-function-example]
----
====

===== `substring()`
A substring of the given string.

The second argument specifies the starting position, where position 1 is the first character of the string.
The third (optional) argument specified the maximum length of the resulting string.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-substring-function-example]
----
====

===== `upper()`
The given string, with lowercase characters converted to uppercase.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-upper-function-example]
----
====

===== `lower()`
The given string, with uppercase characters converted to lowercase.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-lower-function-example]
----
====

===== `trim()`
Follows the semantics of the SQL `trim()` function.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-trim-function-example]
----
====

===== `length()`
The length of a string.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-length-function-example]
----
====

===== `locate()`
Locates a string within another string.

The third argument (optional) is used to specify a position at which to start the search.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-locate-function-example]
----
====

===== `abs()`
The magnitude of a numeric value.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-abs-function-example]
----
====

===== `mod()`
Calculates the remainder of dividing the first argument by the second.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-mod-function-example]
----
====

===== `sqrt()`
The square root of a numeric value.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-sqrt-function-example]
----
====
//
//CURRENT_DATE::
//Returns the database current date.
//
//====
//[source, JAVA, indent=0]
//----
//include::{sourcedir}/HQLTest.java[tags=hql-current-date-function-example]
//----
//====
//
//CURRENT_TIME::
//Returns the database current time.
//
//====
//[source, JAVA, indent=0]
//----
//include::{sourcedir}/HQLTest.java[tags=hql-current-time-function-example]
//----
//====
//
//CURRENT_TIMESTAMP::
//Returns the database current timestamp.
//
//====
//[source, JAVA, indent=0]
//----
//include::{sourcedir}/HQLTest.java[tags=hql-current-timestamp-function-example]
//----
//====

We have not included <<hql-aggregate-functions,aggregate functions>> in this list, because their purpose is more specialized.

[[hql-functions]]
==== Important HQL functions

Beyond the JPQL standardized functions, HQL makes some additional functions available, and ensures that they are as portable as possible across all supported databases.

[[hql-function-cast]]
===== `cast()`
A typecast for basic-typed values.

The target type is an unqualified Java class name:
`String`, `Long`, `Integer`, `Double`, `Float`, `Character`, `Byte`, `BigInteger`, `BigDecimal`, `LocalDate`, `LocalTime`, `LocalDateTime`, etc.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-cast-function-example]
----
====

The function `str(x)` is a synonym for `cast(x as String)`.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-str-function-example]
----
====

[[hql-function-extract]]
===== `extract()`
Extracts a field of a datetime.

Field types include: `day`, `month`, `year`, `second`, `minute`, `hour`, `day of week`, `day of month`, `week of year`, `date`, `time` and more.
For a full list of field types, see the Javadoc for https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/query/TemporalUnit.html[`TemporalUnit`].

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-extract-function-example]
----
====

The following synonyms for `extract()` are also provided:

|===
| `year(x)` | `extract(year from x)`
| `month(x)` | `extract(month from x)`
| `day(x)` | `extract(day from x)`
| `hour(x)` | `hour(year from x)`
| `minute(x)` | `minute(year from x)`
| `second(x)` | `second(year from x)`
|===

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-year-function-example]
----
====

===== `collate()`

Selects a collation to be used for its string-valued argument.
Collations are useful for <<hql-relational-comparisons,binary comparisons>> with `<` or `>`, and in the <<hql-order-by,order by clause>>.

For example, `collate(p.name as ucs_basic)` specifies the SQL standard collation `ucs_basic`.

IMPORTANT: Collations aren't very portable between databases.

[[hql-function-format]]
===== `format()`

Formats a date, time, or datetime according to a pattern.

The syntax is `format(datetime as pattern)`, and the pattern must be written in a subset of the pattern language defined by Java's `java.time.format.DateTimeFormatter`.

For a full list of `format()` pattern elements, see the Javadoc for https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/dialect/Dialect.html#appendDatetimeFormat[`Dialect#appendDatetimeFormat`].

[[hql-more-functions]]
==== More HQL functions

Here we summarize the remaining standard functions defined by HQL.

First, functions for working with strings:

|===
| HQL Function | Purpose | Syntax | Notes on syntax

| `position()` | Similar to `locate()` | `position(pattern in string)` | Standard ANSI SQL
| `substring()` | An alternative syntax for JPQL's `substring()`
| `substring(string from start)`, `substring(string from start for length)` | Standard ANSI SQL
| `overlay()` | For replacing a substring
| `overlay(string placing replacement from start)`, `overlay(string placing replacement from start for length)` | Standard ANSI SQL
| `pad()` | Pads a string with whitespace, or with a specified character
| `pad(string with length)`, `pad(string with length leading)`, `pad(string with length trailing)`, or `pad(string with length leading character)`
| Designed to look like `trim()`
| `left()` | The leftmost characters of a string | `left(string, length)` | Common in SQL dialects
| `right()` | The rightmost characters of a string | `right(string, length)`  | Common in SQL dialects
| `replace()` | Replace every occurrence of a pattern in a string | `replace(string, pattern, replacement)` | Common in SQL dialects
|===

Next, functions for working with numeric values:

|===
| HQL Function | Purpose | Signature | Notes on naming

| `sign()` | The sign of a number | `sign(x)` | Universal in SQL dialects
| `exp()` | Exponential function | `exp(x)` | Universal in SQL dialects
| `power()` | Exponentiation | `power(x,y)` | Universal in SQL dialects
| `ln()` | Natural logarithm | `ln(x)` | Very common in SQL dialects
| `log10()` | Base-10 logarithm | `log10(x)` | Very common in SQL dialects
| `sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()`, `atan2()` | Basic trigonometric functions | `sin(theta)`, `cos(theta)`, `atan2(opposite, adjacent)` | Very common in SQL dialects
| `round()` | Numeric rounding | As usual: `round(number, places)` | Very common in SQL dialects
| `floor()` | Floor function | `floor(x)` | Universal in SQL dialects
| `ceiling()` | Ceiling function | `ceiling(x)` | Very common in SQL dialects
| `least()` | Return the smallest of the given arguments | `least(x, y, z)` | Very common in SQL dialects
| `greatest()` | Return the largest of the given arguments | `greatest(x, y, z)` | Very common in SQL dialects
|===

Finally, specialized functions for working with collection-valued attributes and to-many associations:

|===
| HQL Function | Applies to | Purpose

| `size()` | Any collection | The size of the collection.
| `maxelement()` | Collections of basic type | The maximum element as determined by applying the `max()` SQL aggregation.
| `minelement()` | Collections of basic type | The minimum element as determined by applying the `min()` SQL aggregation.
| `maxindex()` | Indexed collections (lists and maps) | The maximum index (key/position) as determined by applying the `max()` SQL aggregation.
| `minindex()` | Indexed collections (lists and maps) | The minimum index (key/position) as determined by applying the `min()` SQL aggregation.
|===

We've intentionally left two functions off this list, so we can come back to them <<hql-elements-indices,later>>.

[[hql-collection-expressions-example]]
//.Collection-related expressions examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-example]
----
====

[TIP]
====
These operations can almost always be written in another way, without the use of these convenience functions.
====

See also <<hql-collection-qualification>>.

[[hql-user-defined-functions]]
==== Native and user-defined functions

There are several ways to call native or user-defined SQL functions.

- A native or user-defined function may be called using JPQL's `function` syntax, for example, ``function('sinh', phi)``.
- A user-written `FunctionContributor` may register user-defined functions.
- A custom `Dialect` may register additional native functions be overriding `initializeFunctionRegistry()`.

Registering a function isn't hard, but is beyond the scope of this chapter.

[[hql-conditional-expressions]]
=== Predicates

A predicate is an operator which, when applied to some argument, evaluates to `true` or `false`.
In the world of SQL-style ternary logic, we must expand this definition to encompass the possibility that the predicate evaluates to `null`.
Typically, a predicate evaluates to `null` when one of its arguments is `null`.

Predicates occur in the `where` clause, the `having` clause and in searched case expressions.

[[hql-relational-comparisons]]
==== Relational operators

The binary comparison operators are borrowed from SQL: `=`, `>`, `>=`, `<`, `\<=`, `<>`.

TIP: If you prefer, HQL treats `!=` as a synonym for `<>`.

The operands should be of the same type.

[[hql-relational-comparisons-example]]
//.Relational comparison examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-relational-comparisons-example]
----
====

[[hql-between-predicate]]
==== `between`

The ternary `between` operator, and its negation, `not between`, determine if a value falls within a range.

Of course, all three operands must be of compatible type.

[[hql-between-predicate-example]]
//.Between examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-between-predicate-example]
----
====

[[hql-null-predicate]]
==== Operators for dealing with null

The following operators make it easier to deal with null values.

|===
| Operator | Negation | Type | Semantics

| `is null` | `is not null` | Unary postfix | `true` if the value to the left is null
| `is distinct from` | `is not distinct from` | Binary | `true` if the value on the left is equal to the value on the right, or if both are null
|===

[[hql-null-predicate-example]]
//.Nullness checking examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-null-predicate-example]
----
====

[[hql-like-predicate]]
==== String pattern matching

The `like` operator performs pattern matching on strings.
Its friend `ilike` performs case-insensitive matching.

Their syntax is defined by:

[[hql-like-predicate-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/predicate_like_bnf.txt[]
----

The expression on the right is a pattern, where:

* `_` matches any single character,
* `%` matches any number of characters, and
* if an escape character is specified, it may be used to escape either of these wildcards.

[[hql-like-predicate-example]]
//.Like predicate examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-like-predicate-example]
----
====

The optional `escape` character allows a pattern to include a literal `_` or `%` character.

For example, to match all stored procedures prefixed with `Dr_`, the like criteria could be `'Dr|_%' escape '|'`:

[[hql-like-predicate-escape-example]]
//.Like with escape symbol
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-like-predicate-escape-example]
----
====

As you can guess, `not like` and `not ilike` are the enemies of `like` and `ilike`, and evaluate to the exact opposite boolean values.

[[hql-elements-indices]]
==== Elements and indices

There's two special HQL functions that we didn't mention <<hql-more-functions,earlier>>, since they're only useful in conjunction with the predicate operators we're about to meet.

These functions are only allowed in the `where` clause, and result in a subquery in the generated SQL.
Indeed, you can think of them as just a shortcut way to write a subquery.

//They are usually used in conjunction with either:
//
//* one of the qualifiers `every`, `all`, `any` or `some`, as defined below in <<hql-relational-comparisons-subqueries>>,
//* `in`, defined in <<hql-in-predicate>>, or
//* `exists`, defined in <<hql-exists-predicate>>.

|===
| HQL Function | Applies to | Purpose

| `elements()` |  Any collection | Refers to the elements of a collection as a whole.

| `indices()` | Indexed collections (lists and maps) | Similar to `elements()` but refers to the collections indices (keys/positions) as a whole.
|===

In the next three sections, we'll see how these two functions are useful.

[[hql-in-predicate]]
==== `in`

The `in` predicates evaluates to true if the value to its left is in ... well, whatever it finds to its right.

Its syntax is unexpectedly complicated:

[[hql-in-predicate-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/predicate_in_bnf.txt[]
----

This less-than-lovely fragment of the HQL ANTLR grammar tells is that the thing to the right might be:

* a list of values enclosed in parentheses,
* a query parameter,
* a subquery, or
* one the the functions `elements()` or `indices()`  defined <<hql-elements-indices,above>>.

The type of the expression on the left, and the types of all the values on the right must be compatible.

[NOTE]
====
JPQL limits the legal types to string, numeric, date/time, and enum types, and in JPQL the left expression must be either:

* a "state field", which means a simple attribute, excluding associations and embedded attributes, or
* an entity type expression (see <<hql-treat-type>>).

HQL is far more permissive. HQL itself does not restrict the type any way, though the database itself might.
Even embedded attributes are allowed, although that feature depends on the level of support for tuple or "row value constructors" in the underlying database.
====

[[hql-in-predicate-example]]
//.In predicate examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-in-predicate-example]
----
====

[[hql-collection-expressions-in-example]]
//.In indices example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-in-example]
----
====

[[hql-relational-comparisons-subqueries]]
==== Relational operators and subqueries

The binary comparisons we met above in <<hql-relational-comparisons>> may involve a qualifier:

* a qualified subquery, or
* a qualifier applied to one of the functions `elements()` or `indices()`  defined <<hql-elements-indices,above>>.

The qualifiers are unary prefix operators: `all`, `every`, `any`, and `some`.

|===
| Subquery operator | Synonym | Semantics

| `every` | `all` | Evaluates to true of the comparison is true for every value in the result set of the subquery.
| `any` | `some` | Evaluates to true of the comparison is true for at least one value in the result set of the subquery.
|===

[[hql-all-subquery-comparison-qualifier-example]]
//.Subquery comparison example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-all-subquery-comparison-qualifier-example]
----
====

[[hql-collection-expressions-all-some-example]]
//.All elements and some elements
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-all-example]
----

[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-some-example]
----
====

[[hql-exists-predicate]]
==== Exists operator

The unary prefix `exists` operator evaluates to true if the thing to its right is nonempty.

The thing to its right might be:

* a subquery, or
* one of the functions `elements()` or `indices()`  defined <<hql-elements-indices,above>>.

As you can surely guess, `not exists` evaluates to true if the thing to the right _is_ empty.

[[hql-collection-expressions-exists-example]]
//.Exists elements example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-exists-example]
----
====

[[hql-collection-operators]]
==== Collection operators

The following operators apply to collection-valued attributes and to-many associations.

|===
| Operator | Negation | Type | Semantics

| `is empty` | `is not empty` | Unary postfix | `true` if the collection or association on the left has no elements
| `member of` | `not member of` | Binary | `true` if the value on the left is a member of the collection or association on the right
|===

[[hql-empty-collection-predicate-example]]
//.Empty collection expression examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-empty-collection-predicate-example]
----
====

[[hql-member-of-collection-predicate-example]]
//.Member-of collection expression examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-member-of-collection-predicate-example]
----
====

[[hql-logical-operators]]
==== Logical operators

The logical operators are `and`, `or`, and `not`.

Just like SQL, logical expressions are based on ternary logic.

[[hql-from-clause]]
=== The `from` clause

The `from` clause is responsible for defining the entities available in the rest of the query, and assigning them aliases, or, in the language of the JPQL specification, _identification variables_.

[[hql-identification-variables]]
==== Identification variables

An identification variable is just a name we can use to refer to an entity and its attributes from expressions in the query.
It may be any legal Java identifier.
According to the JPQL specification, identification variables must be treated as case-insensitive language elements.

[TIP]
====
The identification variable is actually optional, but for queries involving more than one entity it's almost always a good idea to declare one.
====

Identification variables may be declared with the `as` keyword, but this is optional.

[[hql-root-reference]]
==== Root entity references

A root entity reference, or what the JPQL specification calls a _range variable declaration_, is a direct reference to a mapped `@Entity` type by its entity name.

[TIP]
====
Remember, the _entity name_ is the value of the `name` member of the `@Entity` annotation, or the unqualified Java class name by default.
====

[[hql-root-reference-jpql-example]]
//.Entity name for root entity reference
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-jpql-example]
----
====

In this example, `Person` is the entity name, and `p` is the identification variable.

Alternatively, a fully-qualified Java class name may be specified.
Then Hibernate will query every entity which inherits the named type.

[[hql-root-reference-jpql-fqn-example]]
//.Class name for root entity reference
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-jpql-fqn-example]
----
====

Of course, there may be multiple root entities.

[[hql-multiple-root-reference-jpql-example]]
//.Simple query using multiple root entity references
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-multiple-root-reference-jpql-example]
----

[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-multiple-same-root-reference-jpql-example]
----
====

The previous queries may even be written using the syntax `cross join` in place of the comma:

[[hql-cross-join-jpql-example]]
//.Simple query using cross join
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-cross-join-jpql-example]
----
====

[[hql-polymorphism]]
==== Polymorphism

HQL and JPQL queries are inherently polymorphic.
Consider:

[[hql-polymorphism-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-polymorphism-example, indent=0]
----
====

This query names the `Payment` entity explicitly.
But the `CreditCardPayment` and `WireTransferPayment` entities inherit `Payment`, and so `p` ranges over all three types.
Instances of all these entities are returned by the query.

[NOTE]
====
The query `from java.lang.Object` is completely legal. (But not very useful!)

It returns every object of every mapped entity type.
====

This behavior may be slightly adjusted using the `@Polymorphism` annotation.

See <<chapters/domain/inheritance.adoc#entity-inheritance-polymorphism>> for more.

[[hql-join]]
=== Joins

Joins allow us to navigate from one entity to another, via its associations, or via explicit join conditions.

[[hql-explicit-join]]
==== Explicit joins

An explicit association join is declared using the `join` keyword.
An explicit join may be either:

* an inner join, written as `join` or `inner join`, or
* a left outer join, written as `left join` or `left outer join`.

Every explicit join specifies an entity attribute to be joined.
The specified attribute:

* is usually a `@OneToMany`, `@ManyToMany`, `@OneToOne`, or `@ManyToOne` association, but
* it could be an `@ElementCollection`, and
* it might even be an attribute of embeddable type.

In the case of an association or collection, the generated SQL will have a join of the same type.
(For a many-to-many association it will have _two_ joins.)
In the case of an embedded attribute, the join is purely logical and does not result in a join in the generated SQL.

An explicit join may assign an identification variable to the joined entity.

[[hql-explicit-inner-join-example]]
//.Explicit inner join examples
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-inner-join-example]
----
====

[[hql-explicit-outer-join-example]]
//.Explicit left (outer) join examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-outer-join-example]
----
====

For further information about collection-valued association references, see <<hql-collection-valued-associations>>.

[[hql-explicit-join-conditions]]
==== Explicit joins with join conditions

The `with` or `on` clause allows explicit qualification of the join conditions.

[NOTE]
====
The specified join conditions are _added_ to the join conditions specified by the foreign key association.
That's why, historically, HQL uses the keword `with` here:
"with" emphasizes that the new condition doesn't _replace_ the original join conditions.

The `with` keyword is specific to Hibernate. JPQL uses `on`.
====

Join conditions occurring in the `with` or `on` clause are added to the `on` clause in the generated SQL.

[[hql-explicit-join-with-example]]
//.HQL `with` clause join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-join-with-example]
----
====

The following query is arguably less clear, but semantically equivalent:

[[hql-explicit-join-jpql-on-example]]
//.JPQL `on` clause join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-join-jpql-on-example]
----
====

[[hql-explicit-fetch-join]]
==== `fetch join` for association fetching

A ``fetch join``  overrides the laziness of a given association, specifying that the association should be fetched with a SQL join.

[IMPORTANT]
====
This is one of the most important features of Hibernate.
To achieve acceptable performance with HQL, you'll need to use `fetch join` quite often.
Without it, you'll quickly run into the dreaded "n+1 selects" problem.
====

[NOTE]
====
Fetch joins are disallowed in subqueries.
====

For example, if `Person` has a one-to-many association named `phones`, the use of `join fetch` in the following query specifies that the collection elements should be fetched in the same SQL query:

[[hql-explicit-fetch-join-example]]
//.Fetch join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-fetch-join-example]
----
====

In this example, we used a left outer join because we also wanted to obtain customers with no orders.

* A `join fetch`, or, more explicitly, `inner join fetch`, only returns base entities with an associated entity.
* A `left join fetch`, or&mdash;for lovers of verbosity&mdash;``left outer join fetch``, returns all the base entities, including those which have no associated joined entity.

It's usually a bad idea to apply any restriction to a ``fetch join``ed entity, since then the elements of the fetched collection will be incomplete.
Therefore, avoid assigning an identification variable to fetched joins except for the purpose of specifying nested fetch joins.

[IMPORTANT]
====
Fetch joins should not be used in paged queries (`setFirstResult()` or `setMaxResults()`).

Nor should they be used with the `scroll()` or `stream()` methods.
====

[[hql-join-treat]]
==== Joins with typecasts

An explicit join may narrow the type of the joined entity using `treat()`.

[[hql-join-treat-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-join-treat-example]
----
====

Here, the identification variable `ccp` declared to the right of `treat()` has the narrowed type `CreditCardPayment`, instead of the declared type `Payment`.
This allows the attribute `cardNumber` declared by the subtype `CreditCardPayment` to be referenced in the rest of the query.

See <<hql-treat-type>> for more information about `treat()`.

[[hql-implicit-join]]
==== Implicit joins (path expressions)

It's not necessary to explicitly `join` every entity that occurs in a query.
Instead, entity associations may be _navigated_, just like in Java:

* if an attribute is of embedded type, or is a to-one association, it may be further navigated, but
* if an attribute is of basic type, is collection-valued, or is a to-many association, it is considered terminal, and may not be further navigated.

It's clear that:

* A path expression like `p.name` with only two elements just refers to state held directly by an entity with an alias `p` defined in `from` or `join`.
* But a longer path expression, for example, `ph.person.name`, might refer to state held by an associated entity.
  (Alternatively, it might refer to state held by an embedded class.)

In the second case, Hibernate with automatically add a join to the generated SQL if necessary.

[[hql-implicit-join-example]]
//.Simple implicit join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-implicit-join-example]
----
====

As in this example, implicit joins usually appear outside the `from` clause of the HQL query.
However, they always affect the `from` clause of the SQL query.

Note that:

* Implicit joins are always treated as inner joins.
* Multiple occurrences of the same implicit join always refer to the same SQL join.

[[hql-implicit-join-alias-example]]
//.Reused implicit join
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-implicit-join-alias-example]
----
====

[[hql-collection-valued-associations]]
==== Collection member references

References to collection-valued associations actually refer to the _elements_ of that collection.

[[hql-collection-valued-associations-example]]
//.Collection references example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-valued-associations]
----
====

In the example, the identification variable `ph` actually refers to the object model type `Phone`, which is the type of the elements of the `Person#phones` association.

But there _is_ a way to refer to the keys or indexes of a collection.

[[hql-collection-qualification]]
==== Collection elements, map keys, and list indexes

The following functions may be applied to a collection valued path expression to obtain a reference to a list index or map key.

|===
| Function | Applies to | Interpretation | Notes

| `value()` | Any collection | The collection element or map entry value
| Always optional, and useful only to explicitly indicate intent.
| `index()` | Any `List` with an index column | The index of the element in the list
| For backward compatibility, it's also an alternative to ``key()``, when applied to a map.
| `key()` | Any `Map` | The key of the entry in the list | If the key is of entity type, it may be further navigated.
| `entry()` | Any `Map` | The map entry, that is, the `Map.Entry` of key and value.
| Only legal as a terminal path, and only allowed in the `select` clause.
|===

NOTE: Of these, only `index()` is defined by the JPQL specification.

[[hql-collection-qualification-example]]
//.Qualified collection references example
====
[source, JAVA, indent=0]
----
include::{modeldir}/Phone.java[tags=hql-collection-qualification-example, indent=0]

include::{sourcedir}/HQLTest.java[tags=hql-collection-qualification-example, indent=0]
----
====

An element of an indexed collections (an array, list, or map) may even be identified using the index operator:

[[hql-collection-index-operator-example]]
//.Index operator examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-index-operator-example]
----
====

See <<hql-more-functions>> for additional collection-related functions.

[[hql-select-clause]]
=== The `select` clause

The `select` list identifies which objects and values to return as the query results.
If there are multiple expressions in the select list, then, by default, each query result is packaged as an array of type `Object[]`.

Simplifying slightly, the BNF for a select item is:

[[hql-select-item-bnf]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/select_item_bnf.txt[]
----
====

where `instantiatiationArgs` is essentially a nested select list.

Any of the expression types discussed in <<hql-expressions>> may occur in the select list, unless otherwise noted.

But there's one particular expression type that's only legal in the select clause: the `instantiation` rule in the BNF above.
Let's see what it does.

[[hql-select-new]]
==== `select new`

The `select new` construct packages the query results into a user-written Java class instead of an array.

[[hql-select-clause-dynamic-instantiation-example]]
//.Query results via `select new`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/CallStatistics.java[tags=hql-select-clause-dynamic-instantiation-example]

include::{sourcedir}/HQLTest.java[tags=hql-select-clause-dynamic-instantiation-example, indent=0]
----
====

The class must be specified by its fully qualified name in the query, and it must have a matching constructor.

[IMPORTANT]
====
This class does not need to be mapped or annotated in any way.

Even if the class _is_ an entity class, the resulting instances are _not_ managed entities associated with the session.
====

Alternatively, the query may specify that each result should be packaged as a list or map instead of as an array.
Then the query results are returned as a `List<List<Object>>` or `List<Map<String,Object>>` instead of as a `List<Object[]>`.

[[hql-select-clause-dynamic-list-instantiation-example]]
//.Query results as lists
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-clause-dynamic-list-instantiation-example]
----
====

[[hql-select-clause-dynamic-map-instantiation-example]]
//.Query results as maps
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-clause-dynamic-map-instantiation-example]
----
====

In the case of a map, the keys of the map are defined by the aliases given to the select expressions.
If no aliases are specified, the keys will be column indexes: 0, 1, 2, etc.

[[hql-distinct]]
==== `distinct`

The `distinct` keyword helps remove duplicate results from the query result list.
It's only effect is to add `distinct` to the generated SQL.

[[hql-distinct-projection-query-example]]
//.Using `distinct` to remove duplicate rows
====
[source, JAVA, indent=0]
----
include::{sourcedir}/SelectDistinctTest.java[tags=hql-distinct-projection-query-example]
----
====

[NOTE]
====
As of Hibernate 6, duplicate results arising from the use of `join fetch` are automatically removed by Hibernate in memory _after_ reading the database results and materializing entity instances as Java objects.
It's no longer necessary to remove duplicate results explicitly, and `distinct` should not be used in this case.
====

[[hql-aggregate-functions]]
==== Aggregate functions

It's common to have aggregate functions like `count()`, `sum()`, and `max()` in a select list.
Aggregate functions are special functions that reduce the size of the result set.

The standard aggregate functions defined in both ANSI SQL and JPQL are:

|===
| Aggregate function | Argument type | Result type

| `count()`, including `count(distinct)`, `count(all)`, and `count(*)` | Any | `Long`
| `avg()` | Any numeric type | `Double`
| `min()` | Any numeric type, or string | Same as the argument type
| `max()` | Any numeric type, or string | Same as the argument type
| `sum()` | Any numeric type | See table below
|===

In the case of `sum()`, the rules for assigning a result type are:
|===
| Argument type | Result type

| Any integral numeric type except `BigInteger` | `Long`
| Any floating point numeric type | `Double`
| `BigInteger` | `BigInteger`
| `BigDecimal` |  `BigDecimal`
|===

[[hql-aggregate-functions-example]]
//.Aggregate function examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-aggregate-functions-example]
----
====

HQL defines the two additional aggregate functions which accept a logical predicate as an argument, for example, `every(p.amount < 1000.0)`.

|===
| Aggregate function | Argument type | Result type

| `any()` | Logical predicate | `Boolean`
| `every()` | Logical predicate | `Boolean`
|===

Aggregate functions often appear in queries with a `group by` clause, as described <<hql-group-by,below>>.

[[hql-aggregate-functions-filter]]
==== `filter`

All aggregate functions support the inclusion of a _filter clause_, a sort of mini-`where`-clause applying to just one item of the select list:

[[hql-aggregate-functions-filter-example]]
//.Using filter with aggregate functions
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-aggregate-functions-simple-filter-example]
----

[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-aggregate-functions-filter-example]
----
====

[[hql-where-clause]]
=== The `where` clause

The `where` clause restricts the results returned from a select query or limits the scope of update and delete queries.

It contains a logical expression.

[[hql-group-by]]
=== The `group by` clause

The `group by` clause divides the result set into groups, so that a query with aggregate functions in the select list returns not a single result, but one result for each group.
The result set is grouped by the values of expressions that occur in the `group by` clause.

As an example, consider the following queries:

[[hql-group-by-example]]
//.Group by example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-group-by-example]
----
====

The first query retrieves the complete total of all orders.
The second retrieves the total for each customer, grouped after grouping the orders by customer.

[[hql-group-by-rollup-cube]]
==== `rollup` and `cube`

The special functions `rollup()` and `cube()` may be used in the `group by` clause, when supported by the database.
The semantics are identical to SQL.

These functions are especially useful for reporting:

* A `group by` clause with `rollup()` is used to produce subtotals and grand totals.
* A `group by` clause with `cube()` allows totals for every combination of columns.

[[hql-having]]
=== The `having` clause

In a grouped query, the `where` clause applies to the non-aggregated values (essentially it determines whether rows will make it into the aggregation).
The `having` clause also restricts results, but it operates on the aggregated values.

In an <<hql-group-by-example,example above>>, we retrieved `Call` duration totals for all persons.
If that ended up being too much data to deal with, we might want to restrict the results to focus only on customers with a summed total of more than 1000:

[[hql-group-by-having-example]]
//.Having example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-group-by-having-example]
----
====

The `having` clause follows the same rules as the `where` clause and is also made up of predicates.
`having` is applied after the groupings and aggregations have been done, while the `where` clause is applied before.

[[hql-set-operators]]
=== `union`, `intersect`, and `except`

Query results may be combined using the operators:

- `union` and `union all`,
- `intersect` and `intersect all`, and
- `except` and `except all`.

Just like in SQL, `all` suppresses the elimination of duplicate results.

[[hql-order-by]]
=== The `order by` clause

By default, the results of the query are returned in an arbitrary order.
The `order by` clause specifies a list of selected items used to order the results.
Each item may be:

* an attribute of an entity or embeddable class,
* a scalar expression involving arithmetic operators, function application, etc,
* an alias declared in the select list, or
* a literal integer indicating the ordinal position of an item in the select list.

[NOTE]
====
The JPQL specification requires that every expression in the `order by` clause must also occur in the `select` clause.
HQL does not enforce this restriction, but applications desiring database portability should be aware that some databases _do_.
====

The BNF for an `order by` item is:

[[hql-order-by-item-bnf]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/order_by_item_bnf.txt[]
----
====

Each item listed in the `order by` clause may explicitly specify a direction, either:

* `asc` for ascending order, or
* `desc` for descending order.

If no direction is explicitly specified, the results are returned in ascending order.

Of course, there is an ambiguity with respect to null values.
Therefore, the order of null values may also be explicitly specified:

* `nulls first` puts null values at the beginning of the result set, and
* `nulls last` puts them last.

[[hql-order-by-example]]
//.Order by example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-order-by-example]
----
====

[[hql-limit-offset]]
=== The `limit` and `offset` clauses

The `limit` and `offset` clauses are an alternative to the use of `setMaxResults()` and `setFirstResult()` respectively.

[TIP]
====
If the `limit` or `offset` is parameterized, it's much easier to use `setMaxResults()` or `setFirstResult()`.
====

The SQL syntax `fetch first ... rows only` and `fetch next ... rows only` is also allowed.

The BNF is a bit complicated:

[[hql-limit-offset-bnf]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/limit_offset_bnf.txt[]
----
====

In the next chapter we'll see a completely different way to write queries in Hibernate.
