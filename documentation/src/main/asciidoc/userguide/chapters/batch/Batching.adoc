[[batch]]
== Batching

First we need to decide what all to discuss here as that phrase has so
many connotations. Do we cover

* JDBC batch updates?
* Session w/ incremental flushing?
* StatelessSession?
* Java EE batching?
* Any/all of the above?
* Others?

[[batch-jdbcbatch]]
=== JDBC batching

JDBC offers support for batching together SQL statements that can be
represented as a single PreparedStatement. Implementation wise this
generally means that drivers will send the batched operation to the
server in one call, which can save on network calls to the database.
Hibernate can leverage JDBC batching. The following settings control
this behavior.

* `hibernate.jdbc.batch_size` - Controls the maximum number of
statements Hibernate will batch together before asking the driver to
execute the batch. Zero or a negative number disables this feature.

* `hibernate.jdbc.batch_versioned_data` - Some JDBC drivers return
incorrect row counts when a batch is executed. If your JDBC driver falls
into this category this setting should be set to `false`. Otherwise it
is safe to enable this which will allow Hibernate to still batch the DML
for versioned entities and still use the returned row counts for
optimitic lock checks. Currently defaults to false to be safe.

* `hibernate.jdbc.batch.builder` - Names the implementation class used
to manage batching capabilities. It is almost never a good idea to
switch from Hibernate's default implementation. But if you wish to, this
setting would name the org.hibernate.engine.jdbc.batch.spi.BatchBuilder
implementation to use.

* `hibernate.order_update` - Forces Hibernate to order SQL updates by
the entity type and the primary key value of the items being updated.
This allows for more batching to be used. It will also result in fewer
transaction deadlocks in highly concurrent systems. Comes with a
performance hit, so benchmark before and after to see if this actually
helps or hurts your application.

* `hibernate.order_inserts` - Forces Hibernate to order inserts to allow
for more batching to be used. Comes with a performance hit, so benchmark
before and after to see if this actually helps or hurts your
application.


