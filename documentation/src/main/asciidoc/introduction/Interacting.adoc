[[interacting]]
== Interacting with the database

To interact with the database, that is, to execute queries, or to insert, update, or delete data, we need an instance of one of the following objects:

- a JPA `EntityManager`,
- a Hibernate `Session`, or
- a Hibernate `StatelessSession`.

The `Session` interface extends `EntityManager`, and so the only difference between the two interfaces is that `Session` offers a few more operations.

[TIP]
.The `Session` hiding inside an `EntityManager`
====
Actually, in Hibernate, every `EntityManager` is a `Session`, and you can narrow it like this:

[source,java]
----
Session session = entityManager.unwrap(Session.class);
----
====

An instance of `Session` (or of `EntityManager`) is a _stateful session_.
It mediates the interaction between your program and the database via a operations on a _persistence context_.

In this chapter, we're not going to talk much about `StatelessSession`.
We'll come back to <<stateless-sessions,this very useful API>> when we talk about performance.
What you need to know for now is that a stateless session doesn't have a persistence context.

[TIP]
.Some people prefer `StatelessSession`
====
Still, we should let you know that some people prefer to use `StatelessSession` everywhere.
It's a simpler programming model, and lets the developer interact with the database more _directly_.

Stateful sessions certainly have their advantages, but they're more difficult to reason about, and when something goes wrong, the error messages can be more difficult to understand.
====

[[persistence-contexts]]
=== Persistence Contexts

A persistence context is a sort of cache; we sometimes call it the "first-level cache", to distinguish it from the <<second-level-cache,second-level cache>>.
For every entity instance read from the database within the scope of a persistence context, and for every new entity made persistent within the scope of the persistence context, the context holds a unique mapping from the identifier of the entity instance to the instance itself.

Thus, an entity instance may be in one of three states with respect to a given persistence context:

1. _transient_ — never persistent, and not associated with the persistence context,
2. _persistent_ — currently associated with the persistence context, or
3. _detached_ — previously persistent in another session, but not currently associated with _this_ persistence context.

At any given moment, an instance may be associated with at most one persistence context.

The lifetime of a persistence context usually corresponds to the lifetime of a transaction, though it's possible to have a persistence context that spans several database-level transactions that form a single logical unit of work.

There are several reasons we like persistence contexts.

1. They help avoid _data aliasing_: if we modify an entity in one section of code, then other code executing within the same persistence context will see our modification.
2. They enable _automatic dirty checking_: after modifying an entity, we don't need to perform any explicit operation to ask Hibernate to propagate that change back to the database.
   Instead, the change will be automatically synchronized with the database when the session is <<flush,flushed>>.
3. They can improve performance by avoiding a trip to the database when a given entity instance is requested repeatedly in a given unit of work.
4. They make it possible to _transparently batch_ together multiple database operations.

A persistence context also allows us to detect circularities when performing operations on graphs of entities.
(Even in a stateless session, we need some sort of temporary cache of the entity instances we've visited while executing a query.)

On the other hand, stateful sessions come with some very important restrictions, since:

- persistence contexts aren't threadsafe, and can't be shared across threads, and
- a persistence context can't be reused across unrelated transactions, since that would break the isolation and atomicity of the transactions.

Furthermore, a persistence context holds a hard references to all its entities, preventing them from being garbage collected.
Thus, the session must be discarded once a unit of work is complete.

[IMPORTANT]
.This is important
====
If you don't completely understand the previous passage, go back and re-read it until you do.
A great deal of human suffering has resulted from users mismanaging the lifecycle of the Hibernate `Session` or JPA `EntityManager`.
====

We'll conclude by noting that whether a persistence context helps or harms the performance of a given unit of work depends greatly on the nature of the unit of work.
For this reason Hibernate provides both stateful and stateless sessions.

[[creating-session]]
=== Creating a session

Sticking with standard JPA-defined APIs, we saw how to obtain an `EntityManagerFactory` in <<configuration-jpa>>.
It's quite unsurprising that we may use this object to create an `EntityManager`:

[source,java]
----
EntityManager em = emf.createEntityManager();
----

When we're finished with the `EntityManager`, we should explicitly clean it up:

[source,java]
----
em.close();
----

On the other hand, if we're starting from a `SessionFactory`, as described in <<configuration-api>>, we may use:

[source,java]
----
Session s = sf.openSession();
----

But we still need to clean up:

[source,java]
----
em.close();
----

[NOTE]
.Injecting the `EntityManager`
====
If you're writing code for some sort of container environment, you'll probably obtain the `EntityManager` by some sort of dependency injection.
For example, in Java (or Jakarta) EE you would write:

[source,java]
----
@PersistenceContext EntityManager em;
----

In Quarkus, injection is handled by CDI:

[source,java]
----
@Inject EntityManager em;
----
====

[[managing-transactions]]
=== Managing transactions

Using JPA-standard APIs, the `EntityTransaction` interface allows us to control database transactions.

[source,java]
----
EntityManager em = emf.createEntityManager();
EntityTransaction tx = s.getTransaction();
try {
    tx.beginTransaction();
    //do some work
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx.isActive()) tx.rollback();
    throw e;
}
finally {
    em.close();
}
----

Using Hibernate's native APIs we might write something really similar,
// [source,java]
// ----
// Session s = sf.openSession();
// Transaction tx = null;
// try {
//     tx = s.beginTransaction();
//     //do some work
//     ...
//     tx.commit();
// }
// catch (Exception e) {
//     if (tx!=null) tx.rollback();
//     throw e;
// }
// finally {
//     s.close();
// }
// ----
but since this sort of code is extremely tedious, we have a much nicer option:

[source,java]
----
sf.inTransaction(s -> {
    //do the work
    ...
});
----

[NOTE]
.Container-managed transactions
====
In a container environment, the container itself is usually responsible for managing transactions.
In Java EE or Quarkus, you'll probably indicate the boundaries of the transaction using the `@Transactional` annotation.
====

=== Operations on the persistence context

Of course, the main reason we need an `EntityManager` is to do stuff to the database.
The following operations let us interact with the persistence context:

.Important methods of the `EntityManager`
[cols="2,5"]
|===
| Method name and parameters | Effect

| `find(Class,Object)` and `find(Class,Object,LockModeType)`
| Obtain a persistent object given its type and its id
| `persist(Object)`
| Make a transient object persistent and schedule a SQL `insert` statement for later execution
| `remove(Object)`
| Make a persistent object transient and schedule a SQL `delete` statement for later execution
| `merge(Object)`
| Copy the state of a given detached object to a corresponding managed persistent instance and return
the persistent object
| `refresh(Object)` and `refresh(Object,LockModeType)`
| Refresh the persistent state of an object using a new SQL `select` to retrieve the current state from the
database
| `lock(Object, LockModeType)`
| Obtain a <<optimistic-and-pessimistic-locking,pessimistic lock>> on a persistent object
| `flush()`
| Detect changes made to persistent objects association with the session and synchronize the database state with the state of the session by executing SQL `insert`, `update`, and `delete` statements
| `detach(Object)`
| Disassociate a persistent object from a session without
affecting the database
| `getReference(Class,id)` or
`getReference(Object)`
| Obtain a reference to a persistent object without actually loading its state from the database
|===

Notice that some of these operations have no immediate effect on the database, and simply schedule a command for later execution.

Any of these operations might throw an exception, and it's important that we know what to do when that happens.

[[session-exception-handling]]
=== Session and exception handling

If an exception occurs while interacting with the database, there's no good way to resynchronize the state of the current persistence context with the state held in database tables.

Therefore, a session is considered to be unusable after any of its methods throws an exception.

[IMPORTANT]
.The persistence context is fragile
====
If you receive an exception from Hibernate, you should immediately close and discard the current session. Open a new session if you need to, but throw the bad one away first.
====

[[cascade]]
=== Cascading persistence operations

[[flush]]
=== Flushing the session

From time to time, a _flush_ operation is triggered, and the session synchronizes dirty state held in memory—that is, modifications to the state of entities associated with the persistence context—with persistent state held in the database. Of course, it does this by executing SQL `INSERT`, `UPDATE`, and `DELETE` statements.

By default, a flush is triggered when:

- the current transaction commits, for example, when `Transacion.commit()` is called,
- before execution of a query whose result would be affected by the synchronization of dirty state held in memory, or
- when the program directly calls `flush()`.

[NOTE]
.SQL execution happens asynchronously
====
Notice that SQL statements are not usually executed synchronously by methods of the `Session` interface like `persist()` and `remove()`. If synchronous execution of SQL is desired, the `StatelessSession` allows this.
====

This behavior can be controlled by explicitly setting the flush mode.
For example, to disable flushes that occur before query execution, call:

[source,java]
----
em.setFlushMode(FlushModeType.COMMIT);
----

Hibernate allows greater control over the flush mode than JPA:

[source,java]
----
s.setHibernateFlushMode(FlushMode.MANUAL);
----

Since flushing is a somewhat expensive operation (the session must dirty-check every entity in the persistence context), setting the flush mode to `COMMIT` can occasionally be a useful optimization.

[[queries]]
=== Queries

:hql: https://docs.jboss.org/hibernate/orm/6.2/userguide/html_single/Hibernate_User_Guide.html#query-language

Hibernate features three complementary ways to write queries:

- the _Hibernate Query Language_, an extremely powerful superset of JPQL, which abstracts most of the features of modern SQL queries,
- the JPA _criteria query_ API, along with extensions, allowing almost any HQL query to be constructed programmatically via a typesafe API, and, of course
- for when all else fails, _native SQL_ queries.

[[hql-queries]]
=== HQL queries

The query language is discussed in great detail below in <<query-language>>.

Here we want to see how to execute a query via the `Session` or `EntityManager` API.
The method we call depends on what kind of query it is:

- _selection queries_ return a result list, but do not modify the data, but
- _mutation queries_ modify data, and return the number of modified rows.

Selection queries usually start with the keyword `select` or `from`, whereas mutation queries begin with the keyword `insert`, `update`, or `delete`.

.Executing HQL
|===
| Kind of query | `Session` method | `EntityManager` method | `Query` execution method

| Selection query | `createSelectionQuery(String,Class)` | `createQuery(String,Class)` | `getResultList()`, `getSingleResult()`, or `getSingleResultOrNull()`
| Mutation query | `createMutationQuery(String)` | `createQuery(String,Class)` | `executeUpdate()`
|===

So for the `Session` API we would write:

[source,java]
----
List<Book> matchingBooks =
        s.createSelectionQuery("from Book where title like :titleSearchPattern", Book.class)
         .setParameter("titleSearchPattern", titleSearchPattern)
         .getResultList();
----

Or, if we're sticking to the JPA-standard APIs:

[source,java]
----
List<Book> matchingBooks =
        s.createQuery("from Book where title like :titleSearchPattern", Book.class)
         .setParameter("titleSearchPattern", titleSearchPattern)
         .getResultList();
----

The only difference between `createSelectionQuery()` and `createQuery()` is that `createSelectionQuery()` throw an exception if passed a mutation query.

In the query above, `:titleSearchPattern` is called a _named parameter_.
We may also identify parameters by a number.
These are called _ordinal parameters_.

[source,java]
----
List<Book> matchingBooks =
        s.createSelectionQuery("from Book where title like ?1", Book.class)
         .setParameter(1, titleSearchPattern)
         .getResultList();
----

When a query has multiple parameters, named parameters tend to be easier to read, even if slightly more verbose.

[IMPORTANT]
.Using parameters to avoid injection attacks
====
_Never_ concatenate user input with HQL and pass the concatenated string to `createSelectionQuery()`.
This would open up the possibility for an attacker to execute arbitrary code on your database server.
====

If we're expecting a query to return a single result, we can use `getSingleResult()`.

[source,java]
----
Book book =
        s.createSelectionQuery("from Book where isbn = ?1", Book.class)
         .setParameter(1, isbn)
         .getSingleResult();
----

Or, if we're expecting it to return at most one result, we can use `getSingleResultOrNull()`.

[source,java]
----
Book bookOrNull =
        s.createSelectionQuery("from Book where isbn = ?1", Book.class)
         .setParameter(1, isbn)
         .getSingleResult();
----

Occasionally we need to build a query at runtime, from a set of optional conditions.
For this, JPA offers an API which allows programmatic construction of a query.

[NOTE]
.HQL is implemented in terms of criteria queries
====
Actually, in Hibernate 6, every HQL query is compiled to a criteria query before being translated to SQL.
This ensures that the semantics of HQL and criteria queries are identical.
====

[[criteria-queries]]
=== Criteria queries

Imagine we're implementing some sort of search screen, where the user of our system is offered several different ways to constrain the query result set.
For example, we might let them search for books by title and/or the author name.
Of course, we could construct a HQL query by string concatenation, but this is a bit fragile, so it's quite nice to have an alternative.

First we need an object for building criteria queries.
Using the JPA-standard APIs, this would be a `CriteriaBuilder`, and we get it from the `EntityManagerFactory`:

[source,java]
----
CriteriaBuilder cb = emf.getCriteriaBuilder();
----

But if we have a `SessionFactory`, we get something much better, a `HibernateCriteriaBuilder`:

[source,java]
----
HibernateCriteriaBuilder cb = sf.getCriteriaBuilder();
----

The `HibernateCriteriaBuilder` extends `CriteriaBuilder` and adds many operations that JPQL doesn't have.

[TIP]
.Getting a `HibernateCriteriaBuilder` in JPA
====
If you're using `EntityManagerFactory`, don't despair, you have two perfectly good ways to obtain the `HibernateCriteriaBuilder` associated with that factory.
Either:

[source,java]
----
HibernateCriteriaBuilder cb = emf.unwrap(SessionFactory.class).getCriteriaBuilder();
----

Or simply:

[source,java]
----
HibernateCriteriaBuilder cb = (HibernateCriteriaBuilder) emf.getCriteriaBuilder();
----
====

We're ready to create a criteria query.

[source,java]
----
CriteriaQuery<Book> query = cb.createQuery(Book.class);
Root<Book> book = query.from(Book.class);
Predicate where = conjunction();
if (titlePattern != null) {
    where = cb.and(where, cb.like(book.get(Book_.title), titlePattern));
}
if (namePattern != null) {
    Join<Book,Author> author = book.join(Book_.author);
    where = cb.and(where, cb.like(author.get(Author_.name), namePattern));
}
query.select(book).where(where)
    .orderBy(cb.asc(book.get(Book_.title)));
----

:generator: https://hibernate.org/orm/tooling/
:generator-guide: https://docs.jboss.org/hibernate/orm/6.2/userguide/html_single/Hibernate_User_Guide.html#tooling-modelgen

Here, the classes `Book_` and `Author_` are classes generated by Hibernate's {generator}[JPA Metamodel Generator], which is documented in the {generator-guide}[User Guide].

[NOTE]
.Injection attacks and criteria queries
====
Notice that we did not bother treating `titlePattern` and `namePattern` as parameters.
That's safe because, _by default_, Hibernate automatically and transparently handles any literal string passed to the `CriteriaBuilder` as a JDBC parameter.

But this behavior is controlled by the configuration setting `hibernate.criteria.value_handling_mode`.
If you change the default behavior, and set the property to `INLINE` instead of `BIND`, you _must_ pass user-input via a JPA `ParameterExpression`.
====

Execution of a criteria query works almost exactly like execution of HQL.

.Executing criteria queries
|===
| Kind of query | `Session` method | `EntityManager` method | `Query` execution method

| Selection query | `createSelectionQuery(CriteriaQuery)` | `createQuery(CriteriaQuery)` | `getResultList()`, `getSingleResult()`, or `getSingleResultOrNull()`
| Mutation query | `createMutationQuery(CriteriaUpdate)` or `createMutationQuery(CriteriaDelte)` | `createQuery(CriteriaUpdate)` or `createQuery(CriteriaDelte)` | `executeUpdate()`
|===

For example:

[source,java]
----
List<Book> matchingBooks =
        s.createSelectionQuery(query)
         .getResultList();
----

When all else fails, and sometimes even before that, we're left with the option of writing a query in SQL.

[[native-queries]]
=== Native SQL queries

