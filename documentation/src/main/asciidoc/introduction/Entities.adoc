[[entities]]
== Entities

An _entity_ is a Java class which represents data in a relational database table.
We say that the entity _maps_ or _maps to_ the table.

NOTE: Much less commonly, an entity might aggregate data from multiple tables, but we'll get to that later.

An entity has _attributes_&mdash;properties or fields&mdash;which map to columns of the table.
In particular, every entity must have an _identifier_ or _id_, which maps to the primary key of the table.
The id allows us to uniquely associate a row of the table with an instance of the Java class, at least within a given _persistence context_.

TIP: We'll explore the idea of a persistence context later. For now, just think of it as a one-to-one mapping between ids and entity instances.

An instance of a Java class cannot outlive the virtual machine to which it belongs.
But we may think of an entity instance as having a lifecycle which transcends a particular instantiation in memory.
By providing its id to Hibernate, we may re-materialize the instance in a new persistence context, as long as the associated row is present in the database.
Therefore, the operations `persist()` and `remove()` may be thought of as demarcating the beginning and end of the lifecycle of an entity.

An entity usually has associations to other entities.
Typically, an association between two entities maps to a foreign key in one of the database tables.
A group of mutually associated entities is often called a _domain model_, though _data model_ is also a perfectly good term.

[[entity-clases]]
=== Entity classes

An entity must:

- be a non-`final` class,
- with a non-`private` constructor with no parameters.

On the other hand, the entity class may be either concrete or `abstract`, and it may have any number of additional constructors.

Every entity class must be annotated `@Entity`.

[source,java]
----
@Entity
class Book {
    Book() {}
    ...
}
----

Alternatively, the class may be identified as an entity type by providing an XML-based mapping for the class.

[TIP]
.Mapping entities using XML
====
When XML-based mappings are used, the `<entity>` element is used to declare an entity class:

[source,xml]
----
<entity-mappings>
    <package>org.hibernate.example</package>

    <entity class="Book">
        <attributes> ... </attributes>
    </entity>

    ...
</entity-mappings>
----
We won't have much more to say about XML-based mappings in this Introduction, since it's not our preferred way to do things.
But since the `orm.xml` mapping file format defined by the JPA specification was modelled closely on the annotation-based mappings, it's usually easy to go back and forth between the two options.
====

Each entity class has a default _access type_, either:

- direct _field access_, or
- _property access_.

Hibernate automatically determines the access type from the location of attribute-level annotations.
Concretely:

- if a field is annotated `@Id`, field access is used, or
- if a getter method is annotated `@Id`, property access is used.

Back when Hibernate was just a baby, property access was quite popular in the Hibernate community.
Today, however, field access is _much_ more common.

[NOTE]
.Explicit access type
====
The default access type may be specified explicitly using the `@Access` annotation, but we strongly discourage this, since it's ugly and never necessary.
====

[IMPORTANT]
.Mapping annotations should be placed consistently
====
If the `@Id` annotation occurs on a field, the other mapping annotations should also be applied to field; or, if the `@Id` annotation occurs on a getter, the other mapping annotations should be applied to getters.

It is in principle possible to mix field and property access using explicit `@Access` annotations at the attribute level.
We don't recommend doing this.
====

Every entity must have an identifier attribute.

[identifier-attributes]
=== Identifier attributes

An identifier attribute is usually a field:

[source,java]
----
@Entity
class Book {
    Book() {}

    @Id
    Long id;
    
    ...
}
----

But it may be a property:

[source,java]
----
@Entity
class Book {
    Book() {}

    private Long id;
    
    @Id
    Long getId() { return id; }
    void setId(Long id) { this.id = id; }

    ...
}
----

An identifier attribute must be annotated `@Id` or `@EmbeddedId`.

Identifier values may be:

- assigned by the application, that is, by your Java code, or
- generated and assigned by Hibernate.

[generated-identifiers]
=== Generated identifiers

An identifier is often system-generated, in which case it should be annotated `@GeneratedValue`:

[source,java]
----
@Id @GeneratedValue
Long id;
----

[TIP]
.Using surrogate keys
====
System-generated identifiers, or _surrogate keys_ make it easier to evolve or refactor the relational data model.
If you have the freedom to define the relational schema, we recommend the use of surrogate keys.
On the other hand, if, as is more common, you're working with a pre-existing database schema, you might not have the option.
====

JPA defines the following strategies for generating ids, which are enumerated by `GenerationType`:

|===
| Strategy                  | Java type | Implementation

| `GenerationType.UUID`     | `UUID` or `String`  | A Java `UUID`.
| `GenerationType.IDENTITY` | `Long` or `Integer` | An identity or autoincrement column.
| `GenerationType.SEQUENCE` | `Long` or `Integer` | A database sequence.
| `GenerationType.TABLE`    | `Long` or `Integer` | A database table.
| `GenerationType.AUTO`     | `Long` or `Integer` | Selects `SEQUENCE` `TABLE`, or `UUID` based on the identifier type and capabilities of the database.
|===

For example, the following id maps to a SQL `identity`, `auto_increment`, or `bigserial` column:

[source,java]
----
@Id @GeneratedValue(strategy=IDENTITY)
Long id;
----

The `@SequenceGenerator` and `@TableGenerator` annotations allow further control over `SEQUENCE` and `TABLE` generation respectively.

Consider this sequence generator:

[source,java]
----
@SequenceGenerator(name="bookSeq", sequenceName="seq_book",
                   initialValue = 5, allocationSize=10)
----

Values are generated using a database sequence defined as follows:

[source,sql]
----
create sequence seq_book start with 5 increment by 10
----

[IMPORTANT]
.Check the `initialValue` and `allocationSize`
====
If you let Hibernate export your database schema, the sequence definition will have the right `start with` and `increment` values.
But if you're working with a database schema managed outside of Hibernate, makes sure the `initialValue` and `allocationSize` members of `@SequenceGenerator` match the `start with` and `increment` specified in the DDL.
====

Any identifier attribute may now make use of the generator named `bookSeq`:

[source,java]
----
@Id @GeneratedValue(strategy=SEQUENCE, generator="bookSeq")
Long id;
----

Actually, it's extremely common to place the `@SequenceGenerator` annotation on the `@Id` attribute that makes use of it:

[source,java]
----
@Id @GeneratedValue(strategy=SEQUENCE, generator="bookSeq")
@SequenceGenerator(name="bookSeq", sequenceName="seq_book",
                   initialValue = 5, allocationSize=10)
Long id;
----

[NOTE]
.JPA id generators may be shared between entities
====
A `@SequenceGenerator` or `@TableGenerator` must have a name, and may be shared between multiple id attributes.
This fits somewhat uncomfortably with the common practice of annotating the `@Id` attribute which makes use of the generator!
====

As you can see, JPA provides quite adequate support for the most common strategies for system-generated ids.
However, the annotations themselves are a little more intrusive than they should be, and there's no well-defined way to extend this framework to support custom strategies for id generation.
Nor may `@GeneratedValue` be used on a property not annotated `@Id`.
Since custom id generation is a rather common requirement, Hibernate provides a very carefully-designed framework for user-defined ``Generator``s.

[TIP]
.Defining your own id generators
====
JPA doesn't define a standard way to extend the set of id generation strategies, but Hibernate does:

- the `Generator` hierarchy of interfaces in the package `org.hibernate.generator` lets you define new generators, and
- the `@IdGeneratorType` meta-annotation from the package `org.hibernate.annotations` lets you write an annotation which associates a `Generator` type with identifier attributes.

Furthermore, the `@ValueGenerationType` meta-annotation lets you write an annotation which associates a `Generator` type with a non-`@Id` attribute.

These APIs are new in Hibernate 6, and supersede the classic `IdentifierGenerator` interface from older versions of Hibernate.
You can find out more from the Javadoc for `@IdGeneratorType` and for `org.hibernate.generator`.
====

Not every id maps to a (system-generated) surrogate key.
Primary keys which are meaningful to the user of the system are called _natural keys_.
Of particular interest are natural keys which comprise more than one database column, and such natural keys are called _composite keys_.

[composite-identifiers]
=== Composite identifiers

If your database uses composite keys, you'll need more than one identifier attribute.
There are two ways to map composite keys in JPA:

- using an `@IdClass`, or
- using an `@EmbeddedId`.

Perhaps the most immediately-natural way to represent this in an entity class is with multiple fields annotated `@Id`, for example:

[source,java]
----
@Entity
@IdClass(BookId.class)
class Book {
    Book() {}

    @Id
    String isbn;

    @Id
    int printing;

    ...
}
----

But this approach comes with a problem: what object can we use to identify a `Book` and pass to methods like `find()` which accept an identifier?

The solution is to write a separate class with fields that match the identifier attributes of the entity.
The `@IdClass` annotation of the `Book` entity identifies the id class to use for that entity:

[source,java]
----
class BookId {
    
    String isbn;
    int printing;

    BookId() {}

    BookId(String isbn, int printing) {
        this.isbn = isbn;
        this.printing = printing;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof BookId) {
            BookId bookId = (BookId) other;
            return bookId.isbn.equals(isbn)
                && bookId.printing == printing;
        }
        else {
            return false;
        }
    }
    
    @Override
    public int hashCode() {
        return isbn.hashCode();
    }
}
----

IMPORTANT: Every id class should override `equals()` and `hashCode()`.

This is not our preferred approach.
Instead, we recommend that the `BookId` class be declared as an `@Embeddable` type:

[source,java]
----
@Embeddable
class BookId {
    
    String isbn;

    int printing;

    BookId() {}

    BookId(String isbn, int printing) {
        this.isbn = isbn;
        this.printing = printing;
    }

    ...
}
----

And now the entity class may reuse this definition using `@EmbeddedId`:

[source,java]
----
@Entity
class Book {
    Book() {}

    @EmbeddedId
    BookId bookId;

    ...
}
----

This second approach eliminates some duplicated code.

Either way, we may now use `BookId` to obtain instances of `Book`:

[source,java]
----
Book book = session.find(Book.class, new BookId(isbn, printing));
----