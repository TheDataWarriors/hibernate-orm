[[entities]]
== Entities

An _entity_ is a Java class which represents data in a relational database table.
We say that the entity _maps_ or _maps to_ the table.

NOTE: Much less commonly, an entity might aggregate data from multiple tables, but we'll get to that later.

An entity has _attributes_&mdash;properties or fields&mdash;which map to columns of the table.
In particular, every entity must have an _identifier_ or _id_, which maps to the primary key of the table.
The id allows us to uniquely associate a row of the table with an instance of the Java class, at least within a given _persistence context_.

TIP: We'll explore the idea of a persistence context later. For now, just think of it as a one-to-one mapping between ids and entity instances.

An instance of a Java class cannot outlive the virtual machine to which it belongs.
But we may think of an entity instance having a lifecycle which transcends a particular instantiation in memory.
By providing its id to Hibernate, we may re-materialize the instance in a new persistence context, as long as the associated row is present in the database.
Therefore, the operations `persist()` and `remove()` may be thought of as demarcating the beginning and end of the lifecycle of an entity, at least with respect to persistence.

Thus, an id represents the _persistent identity_ of an entity, an identity that outlives a particular instantiation in memory.
And this is an important difference between entity class itself and the values of its attributes&mdash;the entity has a persistent identity, and a well-defined lifecycle with respect to persistence, whereas a `String` or `List` representing one of its attribute values doesn't.

An entity usually has associations to other entities.
Typically, an association between two entities maps to a foreign key in one of the database tables.
A group of mutually associated entities is often called a _domain model_, though _data model_ is also a perfectly good term.

[[entity-clases]]
=== Entity classes

An entity must:

- be a non-`final` class,
- with a non-`private` constructor with no parameters.

On the other hand, the entity class may be either concrete or `abstract`, and it may have any number of additional constructors.

Every entity class must be annotated `@Entity`.

[source,java]
----
@Entity
class Book {
    Book() {}
    ...
}
----

Alternatively, the class may be identified as an entity type by providing an XML-based mapping for the class.

[TIP]
.Mapping entities using XML
====
When XML-based mappings are used, the `<entity>` element is used to declare an entity class:

[source,xml]
----
<entity-mappings>
    <package>org.hibernate.example</package>

    <entity class="Book">
        <attributes> ... </attributes>
    </entity>

    ...
</entity-mappings>
----
We won't have much more to say about XML-based mappings in this Introduction, since it's not our preferred way to do things.
But since the `orm.xml` mapping file format defined by the JPA specification was modelled closely on the annotation-based mappings, it's usually easy to go back and forth between the two options.
====

Each entity class has a default _access type_, either:

- direct _field access_, or
- _property access_.

Hibernate automatically determines the access type from the location of attribute-level annotations.
Concretely:

- if a field is annotated `@Id`, field access is used, or
- if a getter method is annotated `@Id`, property access is used.

Back when Hibernate was just a baby, property access was quite popular in the Hibernate community.
Today, however, field access is _much_ more common.

[NOTE]
.Explicit access type
====
The default access type may be specified explicitly using the `@Access` annotation, but we strongly discourage this, since it's ugly and never necessary.
====

[IMPORTANT]
.Mapping annotations should be placed consistently
====
If the `@Id` annotation occurs on a field, the other mapping annotations should also be applied to field; or, if the `@Id` annotation occurs on a getter, the other mapping annotations should be applied to getters.

It is in principle possible to mix field and property access using explicit `@Access` annotations at the attribute level.
We don't recommend doing this.
====

Every entity must have an identifier attribute.

[[identifier-attributes]]
=== Identifier attributes

An identifier attribute is usually a field:

[source,java]
----
@Entity
class Book {
    Book() {}

    @Id
    Long id;
    
    ...
}
----

But it may be a property:

[source,java]
----
@Entity
class Book {
    Book() {}

    private Long id;
    
    @Id
    Long getId() { return id; }
    void setId(Long id) { this.id = id; }

    ...
}
----

An identifier attribute must be annotated `@Id` or `@EmbeddedId`.

Identifier values may be:

- assigned by the application, that is, by your Java code, or
- generated and assigned by Hibernate.

We'll discuss the second option first.

[[generated-identifiers]]
=== Generated identifiers

An identifier is often system-generated, in which case it should be annotated `@GeneratedValue`:

[source,java]
----
@Id @GeneratedValue
Long id;
----

[TIP]
.Using surrogate keys
====
System-generated identifiers, or _surrogate keys_ make it easier to evolve or refactor the relational data model.
If you have the freedom to define the relational schema, we recommend the use of surrogate keys.
On the other hand, if, as is more common, you're working with a pre-existing database schema, you might not have the option.
====

JPA defines the following strategies for generating ids, which are enumerated by `GenerationType`:

|===
| Strategy                  | Java type | Implementation

| `GenerationType.UUID`     | `UUID` or `String`  | A Java `UUID`.
| `GenerationType.IDENTITY` | `Long` or `Integer` | An identity or autoincrement column.
| `GenerationType.SEQUENCE` | `Long` or `Integer` | A database sequence.
| `GenerationType.TABLE`    | `Long` or `Integer` | A database table.
| `GenerationType.AUTO`     | `Long` or `Integer` | Selects `SEQUENCE` `TABLE`, or `UUID` based on the identifier type and capabilities of the database.
|===

For example, the following id maps to a SQL `identity`, `auto_increment`, or `bigserial` column:

[source,java]
----
@Id @GeneratedValue(strategy=IDENTITY)
Long id;
----

The `@SequenceGenerator` and `@TableGenerator` annotations allow further control over `SEQUENCE` and `TABLE` generation respectively.

Consider this sequence generator:

[source,java]
----
@SequenceGenerator(name="bookSeq", sequenceName="seq_book",
                   initialValue = 5, allocationSize=10)
----

Values are generated using a database sequence defined as follows:

[source,sql]
----
create sequence seq_book start with 5 increment by 10
----

[IMPORTANT]
.Check the `initialValue` and `allocationSize`
====
If you let Hibernate export your database schema, the sequence definition will have the right `start with` and `increment` values.
But if you're working with a database schema managed outside of Hibernate, make sure the `initialValue` and `allocationSize` members of `@SequenceGenerator` match the `start with` and `increment` specified in the DDL.
====

Any identifier attribute may now make use of the generator named `bookSeq`:

[source,java]
----
@Id @GeneratedValue(strategy=SEQUENCE, generator="bookSeq")
Long id;
----

Actually, it's extremely common to place the `@SequenceGenerator` annotation on the `@Id` attribute that makes use of it:

[source,java]
----
@Id @GeneratedValue(strategy=SEQUENCE, generator="bookSeq")
@SequenceGenerator(name="bookSeq", sequenceName="seq_book",
                   initialValue = 5, allocationSize=10)
Long id;
----

[NOTE]
.JPA id generators may be shared between entities
====
A `@SequenceGenerator` or `@TableGenerator` must have a name, and may be shared between multiple id attributes.
This fits somewhat uncomfortably with the common practice of annotating the `@Id` attribute which makes use of the generator!
====

As you can see, JPA provides quite adequate support for the most common strategies for system-generated ids.
However, the annotations themselves are a little more intrusive than they should be, and there's no well-defined way to extend this framework to support custom strategies for id generation.
Nor may `@GeneratedValue` be used on a property not annotated `@Id`.
Since custom id generation is a rather common requirement, Hibernate provides a very carefully-designed framework for user-defined ``Generator``s.

[[user-defined-generators]]
=== User-defined generators

JPA doesn't define a standard way to extend the set of id generation strategies, but Hibernate does:

- the `Generator` hierarchy of interfaces in the package `org.hibernate.generator` lets you define new generators, and
- the `@IdGeneratorType` meta-annotation from the package `org.hibernate.annotations` lets you write an annotation which associates a `Generator` type with identifier attributes.

Furthermore, the `@ValueGenerationType` meta-annotation lets you write an annotation which associates a `Generator` type with a non-`@Id` attribute.

[NOTE]
.The older APIs are still available in Hibernate 6
====
These APIs are new in Hibernate 6, and supersede the classic `IdentifierGenerator` interface and `@GenericGenerator` annotation from older versions of Hibernate.
However, the older APIs are still available and custom ``IdentifierGenerator``s written for older versions of Hibernate continue to work in Hibernate 6.
====

You can find out more from the Javadoc for `@IdGeneratorType` and for `org.hibernate.generator`.

[[natural-identifiers]]
=== Natural identifiers

Not every id maps to a (system-generated) surrogate key.
Primary keys which are meaningful to the user of the system are called _natural keys_.

When the primary key of a table is a natural key, we don't annotate the identifier attribute `@GeneratedValue`, and it's the responsibility of the application code to assign a value to the identifier attribute.

Of particular interest are natural keys which comprise more than one database column, and such natural keys are called _composite keys_.

[[composite-identifiers]]
=== Composite identifiers

If your database uses composite keys, you'll need more than one identifier attribute.
There are two ways to map composite keys in JPA:

- using an `@IdClass`, or
- using an `@EmbeddedId`.

Perhaps the most immediately-natural way to represent this in an entity class is with multiple fields annotated `@Id`, for example:

[source,java]
----
@Entity
@IdClass(BookId.class)
class Book {
    Book() {}

    @Id
    String isbn;

    @Id
    int printing;

    ...
}
----

But this approach comes with a problem: what object can we use to identify a `Book` and pass to methods like `find()` which accept an identifier?

The solution is to write a separate class with fields that match the identifier attributes of the entity.
The `@IdClass` annotation of the `Book` entity identifies the id class to use for that entity:

[source,java]
----
class BookId {
    
    String isbn;
    int printing;

    BookId() {}

    BookId(String isbn, int printing) {
        this.isbn = isbn;
        this.printing = printing;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof BookId) {
            BookId bookId = (BookId) other;
            return bookId.isbn.equals(isbn)
                && bookId.printing == printing;
        }
        else {
            return false;
        }
    }
    
    @Override
    public int hashCode() {
        return isbn.hashCode();
    }
}
----

IMPORTANT: Every id class should override `equals()` and `hashCode()`.

This is not our preferred approach.
Instead, we recommend that the `BookId` class be declared as an `@Embeddable` type:

[source,java]
----
@Embeddable
class BookId {
    
    String isbn;

    int printing;

    BookId() {}

    BookId(String isbn, int printing) {
        this.isbn = isbn;
        this.printing = printing;
    }

    ...
}
----

We'll learn more about <<embeddable-objects>> below.

Now the entity class may reuse this definition using `@EmbeddedId`:

[source,java]
----
@Entity
class Book {
    Book() {}

    @EmbeddedId
    BookId bookId;

    ...
}
----

This second approach eliminates some duplicated code.

Either way, we may now use `BookId` to obtain instances of `Book`:

[source,java]
----
Book book = session.find(Book.class, new BookId(isbn, printing));
----

[[basic-attributes]]
=== Basic attributes

A _basic_ attribute of an entity is a field or property which maps to a single column of the associated database table.
The JPA specification defines a quite limited set of basic types:

|====
| Classification | Package | Types

| Primitive types | | `boolean`, `int`, `double`, etc
| Primitive wrappers | `java.lang` | `Boolean`, `Integer`, `Double`, etc
| Strings | `java.lang` | `String`
| Arbitrary-precision numeric types | `java.math` | `BigInteger`, `BigDecimal`
| Date/time types | `java.time` | `LocalDate`, `LocalTime`, `LocalDateTime`, `OffsetDateTime`, `Instant`
| Deprecated date/time types 💀 | `java.util` | `Date`, `Calendar`
| Deprecated JDBC date/time types 💀 | `java.sql` | `Date`, `Time`, `Timestamp`
| Binary and character arrays | | `byte[]`, `char[]`
| UUIDs | `java.util` | `UUID`
| Enumerated types | | Any `enum`
| Serializable types | | Any type which implements `java.io.Serializable`
|====

[IMPORTANT]
.Please don't use `Date`!
====
We're begging you to use types from the `java.time` package instead of anything which inherits `java.util.Date`.
====

[CAUTION]
.Serialization is usually a bad idea
====
Serializing a Java object and storing its binary representation in the database is usually wrong.
As we'll soon see in <<embeddable-objects>>, Hibernate has much better ways to handle complex Java objects.
====

The `@Basic` annotation explicitly specifies that an attribute is basic, but it's often not needed, since attributes are assumed basic by default.
On the other hand, if an attribute cannot be null, use of `@Basic(optional=false)` is highly recommended.

[source,java]
----
@Basic(optional=false) String firstName;
@Basic(optional=false) String lastName;
String middleName; // may be null
----

[TIP]
.Should I use `optional=false` or `nullable=false` in JPA?
====
There are two ways to mark a mapped column `not null` in JPA:

- using `@Basic(optional=false)`, or
- using `@Column(nullable=false)`.

You might wonder what the difference is.

Well, it's perhaps not obvious to a casual user of the JPA annotations, but they actually come in two "layers":

- annotations like `@Entity`, `@Id`, and `@Basic` belong to the _logical_ layer&mdash;they specify the semantics of your Java domain model, whereas
- annotations like `@Table` and `@Column` belong to the _mapping_ layer&mdash;they specify how elements of the domain model map to objects in the relational database.

Information may be inferred from the logical layer down to the mapping layer, but is never inferred in the opposite direction.

Now, the `@Column` annotation belongs to the _mapping_ layer, and so its `nullable` member only affects schema generation (resulting in a `not null` constraint in the generated DDL).
The `@Basic` annotation belongs to the logical layer, and so an attribute marked `optional=false` is checked by Hibernate before it even writes an entity to the database.
Note that:

- `optional=false` implies `nullable=false`, but
- `nullable=false` _does not_ imply `optional=false`.

Therefore, we recommend `@Basic(optional=false)` in preference to `@Column(nullable=false)` in most circumstances.
====

This limited set of pre-defined basic attribute types can be extended by supplying a _converter_.

[[converters]]
=== Converters

A JPA `AttributeConverter` is responsible for:

- converting a given Java type to one of the types listed above, and/or
- perform any other sort of pre- and post-processing you might need to perform on a basic attribute value before writing and reading it to or from the database.

Converters substantially widen the set of attribute types that can be handled by JPA.

There are two ways to apply a converter:

- the `@Convert` annotation applies an `AttributeConverter` to a particular entity attribute, or
- the `@Converter` annotation registers an `AttributeConverter` for automatic application to all attributes of a given type.

For example, the following converter will be automatically applied to any attribute of type `BitSet`, and takes care of persisting the `BitSet` to a column of type `varbinary`:

[source,java]
----
@Converter(autoApply = true)
public static class BitSetConverter implements AttributeConverter<BitSet,byte[]> {
    @Override
    public byte[] convertToDatabaseColumn(BitSet bitSet) {
        return bitSet.toByteArray();
    }

    @Override
    public BitSet convertToEntityAttribute(byte[] bytes) {
        return BitSet.valueOf(bytes);
    }
}
----

On the other hand, if we _don't_ set `autoapply=true`, then we must explicitly apply the converter using the `@Convert` annotation:

[source,java]
----
@Convert(converter = BitSetConverter.class)
@Basic(optional = false)
BitSet bitset;
----

All this is nice, but it probably won't surprise you that Hibernate goes beyond what is required by JPA.

=== Compositional basic types

Hibernate considers a "basic type" to be formed by the marriage of two objects:

- a `JavaType`, which models the semantics of a certain Java class, and
- a `JdbcType`, representing a SQL type which is understood by JDBC.

An instance of `org.hibernate.type.descriptor.java.JavaType` represents a particular Java class.
It is able to:

- compare instances of the class to determine if an attribute of that class type is dirty (modified),
- produce a useful hash code for an instance of the class,
- coerce values to other types, and, in particular,
- convert an instance of the class to one of several other equivalent Java representations at the request of its partner `JdbcType`.

For example, `IntegerJavaType` knows how to convert an `Integer` or `int` value to the types `Long`, `BigInteger`, and `String`, among others.

We may explicitly specify a Java type using the `@JavaType` annotation, but for the built-in ``JavaType``s this is never necessary.

[source,java]
----
@JavaType(LongJavaType.class) // not needed, this is the default JavaType for long
long currentTimeMillis;
----

For a user-written `JavaType`, the annotation is more useful:

[source,java]
----
@JavaType(BitSetJavaType.class)
BitSet bitSet;
----

Alternatively, the `@JavaTypeRegistration` annotation may be used to register `BitSetJavaType` as the default `JavaType` for `BitSet`.

A `org.hibernate.type.descriptor.jdbc.JdbcType` is able to read and write a single Java type from and to JDBC.

For example, `VarcharJdbcType` takes care of:

- writing Java strings to JDBC ``PreparedStatement``s by calling `setString()`, and
- reading Java strings from JDBC ``ResultSet``s using `getString()`.

By pairing `LongJavaType` with `VarcharJdbcType` in holy matrimony, we produce a basic type which maps ``Long``s and primitive ``longs``s to the SQL type `VARCHAR`.

We may explicitly specify a JDBC type using the `@JdbcType` annotation.

[source,java]
----
@JdbcType(VarcharJdbcType.class)
long currentTimeMillis;
----

Alternatively, we may specify a JDBC type code:

[source,java]
----
@JdbcTypeCode(Types.VARCHAR)
long currentTimeMillis;
----

The `@JdbcTypeRegistration` annotation may be used to register a user-written `JdbcType` as the default for a given SQL type code.

[NOTE]
.JDBC types and JDBC type codes
====
The types defined by the JDBC specification are enumerated by the integer type codes in the class `java.sql.Types`.
Each JDBC type is an abstraction of a commonly-available type in SQL.
For example, `Types.VARCHAR` represents the SQL type `VARCHAR` (or `VARCHAR2` on Oracle).

Since Hibernate understand more SQL types than JDBC, there's an extended list of integer type codes in the class `org.hibernate.type.SqlTypes`.
====

If a given `JavaType` does not know how to convert its instances to the type required by its partner `JdbcType`, we must help it out by providing a JPA `AttributeConverter` to perform the conversion.

For example, to form a basic type using `LongJavaType` and `TimestampJdbcType`, we would provide an `AttributeConverter<Long,Timestamp>`.

[source,java]
----
@JdbcType(TimestampJdbcType.class)
@Convert(converter = LongToTimestampConverter.class)
long currentTimeMillis;
----

Let's abandon our analogy right here, before we start calling this basic type a "throuple".

[[embeddable-objects]]
=== Embeddable objects

An embeddable object is a Java class whose state maps to multiple columns of a table, but which does not itself have a persistent identity.
That is, it's a class with mapped attributes, but no `@Id` attribute.

An embeddable object can only be made persistent by assigning it to the attribute of an entity.
Since the embeddable object does not have its own persistent identity, its lifecycle with respect to persistence is completely determined by the lifecycle of the entity to which it belongs.

An embeddable class must be annotated `@Embeddable` instead of `@Entity`.

[source,java]
----
@Embeddable
class Name {
    
    @Basic(optional=false)
    String firstName;

    @Basic(optional=false)
    String lastName;
    
    String middleName;
    
    Name() {}

    Name(String firstName, String middleName, String lastName) {
        this.firstName = firstName;
        this.middleName = middleName;
        this.lastName = lastName;
    }
    
    ...
}
----

An embeddable class must satisfy the same requirements that entity classes satisfy, with the exception that an embeddable class has no `@Id` attribute.
In particular, it must have a constructor with no parameters.

Alternatively, and embeddable type may be defined as a Java record type:

[source,java]
----
@Embeddable
record Name(String firstName, String middleName, String lastName) {}
----

In this case, the requirement for a constructor with no parameters is relaxed.

We may now use our `Name` class (or record) as the type of an entity attribute:

[source,java]
----
@Entity
class Author {
    Author() {}
    
    @Id @GeneratedValue
    Long id;
    
    Name name;
    
    ...
}
----

[TIP]
.The `@Embedded` annotation is not required
====
JPA provides an `@Embedded` annotation to identify an attribute of an entity that refers to an embeddable type.
This annotation is completely optional, and so we don't usually use it.
====

An attribute of embeddable type represents a relationship between a Java object with a persistent identity, and a Java object with no persistent identity.
You can think of it as a whole-part relationship.
The embeddable object belongs to the entity, and can't be shared with other entity instances.

Now we'll discuss a different kind of relationship: a relationship between Java objects that each have their persistent identity and persistence lifecycle.

[[associations]]
=== Associations

An _association_ is a relationship between entities.
We usually classify associations based on their _multiplicity_.
If `E` and `F` are both entity classes, then:

- a _one to one_ association relates at most one unique instance `E` with at most one unique instance of `F`,
- a _many to one_ association relates zero or more instances of `E` with a unique instance of `F`, and
- a _many to many_ association relates zero or more instances of `E` with zero or more instance of `F`.

An association between entity classes may be either:

- _unidirectional_, navigable from `E` to `F` but not from `F` to `E`, or
- _bidirectional_, and navigable in either direction.

Let's begin with the most common association multiplicity.

[[many-to-one-unidirectional]]
=== Many to one

A many to one association is the most basic sort of association we can imagine.
It maps completely naturally to a foreign key in the database.

The `@ManyToOne` annotation marks the "one" side of the association, and so a unidirectional many to one association looks like this:

[source,java]
----
class Book {
    ...
    @ManyToOne
    Publisher publisher;
    ...
}
----

To make this association bidirectional, we need to add a collection-valued attribute to the `Publisher` class, and annotate it `@OneToMany`, using the `mappedBy` member to refer back to `Book.publisher`.

[source,java]
----
class Publisher {
    ...
    @OneToMany(mappedBy="publisher")
    Set<Book> books;
    ...
}
----

The `Publisher.books` field is called the _unowned_ side of the association.

[WARNING]
.To modify a bidirectional association, you must change the _owning side_!
====
Changes made to the unowned side of an association are never synchronized to the database.
If we desire to change an association in the database, we must change it from the owning side.
Here, we must set `Book.publisher`.

In fact, it's often necessary to change _both sides_ of a bidirectional association.
For example, if the collection `Publisher.books` was stored in the second-level cache, we must also modify the collection, to ensure that the second-level cache remains synchronized with the database.

That said, it's not a hard requirement to update the unowned side, at least if you're sure you know what you're doing.
====

[TIP]
.Unidirectional `@OneToMany`?
====
In principle Hibernate _does_ allow you to have a unidirectional one to many, that is, a `@OneToMany` with no matching `@ManyToOne` on the other side.
In practice, this mapping is unnatural, and does not work very well.
Avoid it.
====

Here we've used `Set` as the type of the collection, but Hibernate also allows the use of `List` or `Collection` here, with almost no difference in semantics.
In particular, the `List` may not contain duplicate elements, and its order will not be persistent.

[source,java]
----
@OneToMany(mappedBy="publisher")
Collection<Book> books;
----

[NOTE]
.`Set`, `List`, or `Collection`?
====
A one to many association mapped to a foreign key can never contain duplicate elements, so `Set` seems like the most semantically correct Java collection type to use here, and so that's the conventional practice in the Hibernate community.

The catch associated with using a set is that we must carefully ensure that `Book` has a high-quality implementation of <<equals-and-hash>>.
Now, that's not necessarily a bad thing, since a quality `equals()` is independently useful.

But what if we used `Collection` or `List` instead?
Then our code would be much less sensitive to how `equals()` and `hashCode()` were implemented.

In the past, we were perhaps too dogmatic in recommending the use of `Set`.
Now? I guess we're happy to let you guys decide.
In hindsight, we could have done more to make clear that this was always a viable option.
====



[[equals-and-hash]]
=== `equals()` and `hashCode()`

Entity classes should override `equals()` and `hashCode()`. People new to
Hibernate or JPA are often confused by exactly which fields should be
included in the `hashCode()`, so please keep the following principles in
mind:

- You should not include mutable fields in the hashcode, since that would
require rehashing any collection containing the entity whenever the field
is mutated.
- It's not completely wrong to include a generated identifier (surrogate
key) in the hashcode, but since the identifier is not generated until
the entity instance is made persistent, you must take great care to not
add it to any hashed collection before the identifier is generated. We
therefore advise against including any database-generated field in the
hashcode.

It's OK to include any immutable, non-generated field in the hashcode.

TIP: We therefore recommend identifying a _natural key_ for each entity,
that is, a combination of fields that uniquely identifies an instance of
the entity, from the perspective of the data model of the program. The
business key should correspond to a unique constraint on the database,
and to the fields which are included in `equals()` and `hashCode()`.

That said, an implementation of `equals()` and `hashCode()` based on the
generated identifier of the entity can work _if you're careful_.

IMPORTANT: If you can't identify a natural key, it might be a sign that
you need to think more carefully about some aspect of your data model.
If an entity doesn't have a meaningful unique key, then it's impossible
to say what event or object it represents in the "real world" outside
your program.

Note that even when you've identified a natural key, we still recommend
the use of a generated surrogate key in foreign keys, since this makes
your data model _much_ easier to change.