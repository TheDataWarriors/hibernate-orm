[[object-relational-mapping]]
== Object/relational mapping

Given a domain model&mdash;that is, a collection of entity classes decorated with all the fancy annotations we <<entities-summary,just met>> in the previous chapter&mdash;Hibernate will happily go away and infer a complete relational schema, and even <<automatic-schema-export,export it to your database>> if you ask politely.

The resulting schema will be entirely sane and reasonable, though if you look closely, you'll find some flaws.
For example, every `VARCHAR` column will have the same length, `VARCHAR(255)`.

But the process I just described&mdash;which we call _top down_ mapping&mdash;simply doesn't fit the most common scenario for the use of O/R mapping.
It's only rarely that the Java classes precede the relational schema.
Usually, _we already have a relational schema_, and we're constructing our domain model around the schema.
This is called _bottom up_ mapping.

[NOTE]
."Legacy" data
====
Developers often refer to a pre-existing relational database as "legacy" data.
That's perhaps a bad word to use, conjuring images of bad old "legacy apps" written in COBOL or something.
But it's not "legacy" data&mdash;it's just your data.
And it's valuable.
So learning to work with "legacy" data is important.
====

Especially when mapping bottom up, we often need to customize the inferred object/relational mappings.
This is a somewhat tedious topic, and so we don't want to spend too many words on it.
Instead, we'll quickly skim the most important mapping annotations.

[[mapping-inheritance]]
=== Mapping entity inheritance hierarchies

In <<entity-inheritance>> we saw that entity classes may exist within an inheritance hierarchy.
There's three basic strategies for mapping an entity hierarchy to relational tables.
Let's put them in a table, so we can more easily compare the points of difference between them.


|===
| Strategy | Mapping | Polymorphic queries | Constraints | Normalization | When to use it

| `SINGLE_TABLE`
| Map every class in the hierarchy to the same table, and uses the value of a _discriminator column_ to determine which concrete class each row represents.
| To retrieve instances of a given class, we only need to query the one table.
| Attributes declared by subclasses map to columns without `NOT NULL` constraints. üíÄ

  Any association may have a `FOREIGN KEY` constraint. ü§ì
| Subclass data is denormalized. üßê
| Works well when subclasses declare few or no additional attributes.
| `JOINED`
| Map every class in the hierarchy to a separate table, but each table only maps the attributes declared by the class itself.

  Optionally, a discriminator column may be used.
a| To retrieve instances of a given class, we must `JOIN` the table mapped by the class with:

  - all tables mapped by its superclasses and
  - all tables mapped by its subclasses.
| Any attribute may map to a column with a `NOT NULL` constraint. ü§ì

  Any association may have a `FOREIGN KEY` constraint. ü§ì
| The tables are normalized. ü§ì
| The best option when we care a lot about constraints and normalization.
| `TABLE_PER_CLASS`
| Map every concrete class in the hierarchy to a separate table, but denormalize all inherited attributes into the table.
| To retrieve instances of a given class, we must take a `UNION` over the table mapped by the class and the tables mapped by its subclasses.
| Associations targeting a superclass cannot have a corresponding `FOREIGN KEY` constraint in the database. üíÄüíÄ

  Any attribute may map to a column with a `NOT NULL` constraint. ü§ì
| Superclass data is denormalized. üßê
| Not very popular.

  From a certain point of view, competes with `@MappedSuperclass`.
|===

The three mapping strategies are enumerated by `InheritanceType`.
We specify an inheritance mapping strategy using the `@Inheritance` annotation.

For mappings with a _discriminator column_, we should:

- specify the discriminator column name and type by annotating the root entity `@DiscriminatorColumn`, and
- specify the values of this discriminator by annotating each entity in the hierarchy `@DiscriminatorValue`.

// [[single-table-inheritance]]
// === Single table inheritance

For single table inheritance we always need a discriminator:

[source,java]
----
@Entity
@DiscriminatorColumn(discriminatorType=CHAR, name="kind")
@DiscriminatorValue('P')
class Person { ... }

@Entity
@DiscriminatorValue('A')
class Author { ... }
----

We don't need to explicitly specify `@Inheritance(strategy=SINGLE_TABLE)`, since that's the default.

// [[multiple-table-inheritance]]
// === Multiple table inheritance

For `JOINED` inheritance we don't need a discriminator:

[source,java]
----
@Entity
@Inheritance(strategy=JOINED)
class Person { ... }

@Entity
class Author { ... }
----

[TIP]
.Discriminator columns for `JOINED` inheritance
====
However, we can add a discriminator column if we like, and in that case the generated SQL for polymorphic queries will be slightly simpler.
====

Similarly, for `TABLE_PER_CLASS` inheritance we have:

[source,java]
----
@Entity
@Inheritance(strategy=TABLE_PER_CLASS)
class Person { ... }

@Entity
class Author { ... }
----

[NOTE]
.Discriminator columns for `TABLE_PER_CLASS` inheritance
====
Hibernate doesn't allow discriminator columns for `TABLE_PER_CLASS` inheritance mappings, since they would make no sense, and offer no advantage.
====

Notice that in this last case, a polymorphic association like:

[source,java]
----
@ManyToOne Person person;
----

is a bad idea, since it's impossible to create a foreign key constraint that targets both mapped tables.

// [[mixing-inheritance]]
// === Mixed inheritance
//
// Hibernate doesn't support mixing ``InheritanceType``s within a single entity hierarchy.
// However, it's possible to emulate a mix of `SINGLE_TABLE` and `JOINED` inheritance using the `@SecondaryTable` annotation.

[[table-mappings]]
=== Mapping to tables

The following annotations specify exactly how elements of the domain model map to tables of the relational model:

|===
| Annotation | Purpose

| `@Table` | Map an entity class to its primary table
| `@SecondaryTable` | Define a secondary table for an entity class
| `@JoinTable` | Map a many-to-many association to its association table
| `@CollectionTable` | Map an `@ElementCollection` to its table
|===

By default, an entity maps to a single table, which may be specified using `@Table`:

[source,java]
----
@Entity
@Table(name="People")
class Person { ... }
----

However, the `@SecondaryTable` annotation allows us to spread its attributes across multiple _secondary tables_.

[source,java]
----
@Entity
@Table(name="Books")
@SecondaryTable(name="Editions")
class Book { ... }
----

[[column-mappings]]
=== Mapping to columns

These annotations specify how elements of the domain model map to columns of tables in the relational model:

|===
| Annotation | Purpose

| `@Column` | Map an attribute to a column
| `@JoinColumn` | Map an association to a foreign key column
| `@PrimaryKeyJoinColumn` | Map the primary key used to join a secondary table with its primary, or a subclass table in `JOINED` inheritance with its root class table
| `@OrderColumn` | Specifies a column that should be used to maintain the order of a `List`.
| `@MapKeyColumn` | Specified a column that should be used to persist the keys of a `Map`.
|===

