[[object-relational-mapping]]
== Object/relational mapping

Given a domain model‚Äîthat is, a collection of entity classes decorated with all the fancy annotations we <<entities-summary,just met>> in the previous chapter‚ÄîHibernate will happily go away and infer a complete relational schema, and even <<automatic-schema-export,export it to your database>> if you ask politely.

The resulting schema will be entirely sane and reasonable, though if you look closely, you'll find some flaws.
For example, every `VARCHAR` column will have the same length, `VARCHAR(255)`.

But the process I just described‚Äîwhich we call _top down_ mapping‚Äîsimply doesn't fit the most common scenario for the use of O/R mapping.
It's only rarely that the Java classes precede the relational schema.
Usually, _we already have a relational schema_, and we're constructing our domain model around the schema.
This is called _bottom up_ mapping.

[TIP]
// ."Legacy" data
====
Developers often refer to a pre-existing relational database as "legacy" data.
That's perhaps a bad word to use, conjuring images of bad old "legacy apps" written in COBOL or something.
But it's not "legacy" data‚Äîit's just your data.
And it's valuable.
So learning to work with "legacy" data is important.
====

Especially when mapping bottom up, we often need to customize the inferred object/relational mappings.
This is a somewhat tedious topic, and so we don't want to spend too many words on it.
Instead, we'll quickly skim the most important mapping annotations.

[[mapping-inheritance]]
=== Mapping entity inheritance hierarchies

In <<entity-inheritance>> we saw that entity classes may exist within an inheritance hierarchy.
There's three basic strategies for mapping an entity hierarchy to relational tables.
Let's put them in a table, so we can more easily compare the points of difference between them.

.Entity inheritance mapping strategies
|===
| Strategy | Mapping | Polymorphic queries | Constraints | Normalization | When to use it

| `SINGLE_TABLE`
| Map every class in the hierarchy to the same table, and uses the value of a _discriminator column_ to determine which concrete class each row represents.
| To retrieve instances of a given class, we only need to query the one table.
| Attributes declared by subclasses map to columns without `NOT NULL` constraints. üíÄ

  Any association may have a `FOREIGN KEY` constraint. ü§ì
| Subclass data is denormalized. üßê
| Works well when subclasses declare few or no additional attributes.
| `JOINED`
| Map every class in the hierarchy to a separate table, but each table only maps the attributes declared by the class itself.

  Optionally, a discriminator column may be used.
a| To retrieve instances of a given class, we must `JOIN` the table mapped by the class with:

  - all tables mapped by its superclasses and
  - all tables mapped by its subclasses.
| Any attribute may map to a column with a `NOT NULL` constraint. ü§ì

  Any association may have a `FOREIGN KEY` constraint. ü§ì
| The tables are normalized. ü§ì
| The best option when we care a lot about constraints and normalization.
| `TABLE_PER_CLASS`
| Map every concrete class in the hierarchy to a separate table, but denormalize all inherited attributes into the table.
| To retrieve instances of a given class, we must take a `UNION` over the table mapped by the class and the tables mapped by its subclasses.
| Associations targeting a superclass cannot have a corresponding `FOREIGN KEY` constraint in the database. üíÄüíÄ

  Any attribute may map to a column with a `NOT NULL` constraint. ü§ì
| Superclass data is denormalized. üßê
| Not very popular.

  From a certain point of view, competes with `@MappedSuperclass`.
|===

The three mapping strategies are enumerated by `InheritanceType`.
We specify an inheritance mapping strategy using the `@Inheritance` annotation.

For mappings with a _discriminator column_, we should:

- specify the discriminator column name and type by annotating the root entity `@DiscriminatorColumn`, and
- specify the values of this discriminator by annotating each entity in the hierarchy `@DiscriminatorValue`.

// [[single-table-inheritance]]
// === Single table inheritance

For single table inheritance we always need a discriminator:

[source,java]
----
@Entity
@DiscriminatorColumn(discriminatorType=CHAR, name="kind")
@DiscriminatorValue('P')
class Person { ... }

@Entity
@DiscriminatorValue('A')
class Author { ... }
----

We don't need to explicitly specify `@Inheritance(strategy=SINGLE_TABLE)`, since that's the default.

// [[multiple-table-inheritance]]
// === Multiple table inheritance

For `JOINED` inheritance we don't need a discriminator:

[source,java]
----
@Entity
@Inheritance(strategy=JOINED)
class Person { ... }

@Entity
class Author { ... }
----

[TIP]
// .Discriminator columns for `JOINED` inheritance
====
However, we can add a discriminator column if we like, and in that case the generated SQL for polymorphic queries will be slightly simpler.
====

Similarly, for `TABLE_PER_CLASS` inheritance we have:

[source,java]
----
@Entity
@Inheritance(strategy=TABLE_PER_CLASS)
class Person { ... }

@Entity
class Author { ... }
----

[NOTE]
// .Discriminator columns for `TABLE_PER_CLASS` inheritance
====
Hibernate doesn't allow discriminator columns for `TABLE_PER_CLASS` inheritance mappings, since they would make no sense, and offer no advantage.
====

Notice that in this last case, a polymorphic association like:

[source,java]
----
@ManyToOne Person person;
----

is a bad idea, since it's impossible to create a foreign key constraint that targets both mapped tables.

// [[mixing-inheritance]]
// === Mixed inheritance
//
// Hibernate doesn't support mixing ``InheritanceType``s within a single entity hierarchy.
// However, it's possible to emulate a mix of `SINGLE_TABLE` and `JOINED` inheritance using the `@SecondaryTable` annotation.

[[table-mappings]]
=== Mapping to tables

The following annotations specify exactly how elements of the domain model map to tables of the relational model:

.Annotations for mapping tables
[cols=",5"]
|===
| Annotation | Purpose

| `@Table` | Map an entity class to its primary table
| `@SecondaryTable` | Define a secondary table for an entity class
| `@JoinTable` | Map a many-to-many or many-to-one association to its association table
| `@CollectionTable` | Map an `@ElementCollection` to its table
|===

The first two annotations are used to map an entity to its _primary table_ and, optionally, one or more _secondary tables_.

[[entity-table-mappings]]
=== Mapping entities to tables

By default, an entity maps to a single table, which may be specified using `@Table`:

[source,java]
----
@Entity
@Table(name="People")
class Person { ... }
----

However, the `@SecondaryTable` annotation allows us to spread its attributes across multiple _secondary tables_.

[source,java]
----
@Entity
@Table(name="Books")
@SecondaryTable(name="Editions")
class Book { ... }
----

The `@Table` annotation can do more than just specify a name:

.`@Table` annotation members
[cols=",8"]
|===
| Annotation member | Purpose

| `name` | The name of the mapped table
| `schema` üíÄ | The schema to which the table belongs
| `catalog` üíÄ | The catalog to which the table belongs
| `uniqueConstraints` | One or more `@UniqueConstraint` annotations declaring multi-column unique constraints
| `indexes` | One or more `@Index` annotations each declaring an index
|===

[TIP]
// .If you don't need to, don't hardcode the schema and catalog
====
It only makes sense to explicitly specify the `schema` in annotations if the domain model is spread across multiple schemas.

Otherwise, it's a bad idea to hardcode the schema (or catalog) in a `@Table` annotation.
Instead:

- set the configuration property `hibernate.default_schema` (or `hibernate.default_catalog`), or
- simply specify the schema in the JDBC connection URL.
====

The `@SecondaryTable` annotation is even more interesting:

.`@SecondaryTable` annotation members
[cols=",8"]
|===
| Annotation member | Purpose

| `name` | The name of the mapped table
| `schema` üíÄ | The schema to which the table belongs
| `catalog` üíÄ | The catalog to which the table belongs
| `uniqueConstraints` | One or more `@UniqueConstraint` annotations declaring multi-column unique constraints
| `indexes` | One or more `@Index` annotations each declaring an index
| `pkJoinColumns` | One or more `@PrimaryKeyJoinColumn` annotations, specifying <<primary-key-column-mappings,primary key column mappings>>
| `foreignKey` | An `@ForeignKey` annotation specifying the name of the `FOREIGN KEY` constraint on the ``@PrimaryKeyJoinColumn``s
|===

[[join-table-mappings]]
=== Mapping associations to tables

The `@JoinTable` annotation specifies an _association table_, that is, a table holding foreign keys of both associated entities.
This annotation is usually used with `@ManyToMany` associations:

[source,java]
----
@Entity
class Book {
    ...
    @ManyToMany
    @JoinTable(name="BooksAuthors")
    Set<Author> authors;
    ...
}
----

But it's even possible to use it to map a `@ManyToOne` or `@OneToOne` association to an association table.

[source,java]
----
@Entity
class Book {
    ...
    @ManyToOne(fetch=LAZY)
    @JoinTable(name="BookPublisher")
    Publisher publisher;
    ...
}
----

Here, there should be a `UNIQUE` constraint on one of the columns of the association table.

[source,java]
----
@Entity
class Author {
    ...
    @OneToOne(optional=false, fetch=LAZY)
    @JoinTable(name="AuthorPerson")
    Person author;
    ...
}
----

Here, there should be a `UNIQUE` constraint on _both_ columns of the association table.

.`@JoinTable` annotation members
[cols=",8"]
|===
| Annotation member | Purpose

| `name` | The name of the mapped association table
| `schema` üíÄ | The schema to which the table belongs
| `catalog` üíÄ | The catalog to which the table belongs
| `uniqueConstraints` | One or more `@UniqueConstraint` annotations declaring multi-column unique constraints
| `indexes` | One or more `@Index` annotations each declaring an index
| `joinColumns` | One or more `@JoinColumn` annotations, specifying <<join-column-mappings,foreign key column mappings>> to the table of the owning side
| `inverseJoinColumns` | One or more `@JoinColumn` annotations, specifying <<join-column-mappings,foreign key column mappings>> to the table of the unowned side
| `foreignKey` | An `@ForeignKey` annotation specifying the name of the `FOREIGN KEY` constraint on the ``joinColumns``s
| `inverseForeignKey` | An `@ForeignKey` annotation specifying the name of the `FOREIGN KEY` constraint on the ``inverseJoinColumns``s
|===

To better understand these annotations, we must first discuss column mappings in general.

[[column-mappings]]
=== Mapping to columns

These annotations specify how elements of the domain model map to columns of tables in the relational model:

.Annotations for mapping columns
[cols=",5"]
|===
| Annotation | Purpose

| `@Column` | Map an attribute to a column
| `@JoinColumn` | Map an association to a foreign key column
| `@PrimaryKeyJoinColumn` | Map the primary key used to join a secondary table with its primary, or a subclass table in `JOINED` inheritance with its root class table
| `@OrderColumn` | Specifies a column that should be used to maintain the order of a `List`.
| `@MapKeyColumn` | Specified a column that should be used to persist the keys of a `Map`.
|===

We use the `@Column` annotation to map basic attributes.

[[regular-column-mappings]]
=== Mapping basic attributes to columns

The `@Column` annotation is not only useful for specifying the column name.

.`@Column` annotation members
[cols=",8"]
|===
| Annotation member | Purpose

| `name` | The name of the mapped column
| `table` | The name of the table to which this column belongs
| `length` | The length of a `VARCHAR`, `CHAR`, or `VARBINARY` column type
| `precision` | The decimal digits of precision of a `FLOAT`, `DECIMAL`, `NUMERIC`, or `TIME`, or `TIMESTAMP` column type
| `scale` | The scale of a `DECIMAL` or `NUMERIC` column type, the digits of precision that occur to the right of the decimal point
| `unique` | Whether the column has a `UNIQUE` constraint
| `nullable` | Whether the column has a `NOT NULL` constraint
| `insertable` | Whether the column should appear in generated SQL `INSERT` and `UPDATE` statements
| `updatable` | Whether the column should appear in generated SQL `INSERT` and `UPDATE` statements
| `columnDefinition` üíÄ| A DDL fragment that should be used to declare the column
|===

[TIP]
// .Use of `columnDefinition` results in unportable DDL
====
We no longer recommend the use of `columnDefinition` since it results in unportable DDL.
Hibernate has much better ways to customize the generated DDL using techniques that result in portable behavior across different databases.
====

Here we see four different ways to use the `@Column` annotation:

[source,java]
----
@Entity
@Table(name="Books")
@SecondaryTable(name="Editions")
class Book {
    @Id @GeneratedValue
    @Column(name="bookId") // customize column name
    Long id;

    @Column(length=100, nullable=false) // declare column as VARCHAR(100) NOT NULL
    String title;
    
    @Column(length=17, unique=true, nullable=false) // declare column as VARCHAR(17) NOT NULL UNIQUE
    String isbn;
    
    @Column(table="Editions", updatable=false) // column belongs to the secondary table, and is never updated
    int edition;
}
----

We don't use `@Column` to map associations.

[[join-column-mappings]]
=== Mapping associations to foreign key columns

The `@JoinColumn` annotation is used to customize a foreign key column.

.`@JoinColumn` annotation members
[cols=",8"]
|===
| Annotation member | Purpose

| `name` | The name of the mapped foreign key column
| `table` | The name of the table to which this column belongs
| `referencedColumnName` | The name of the column to which the mapped foreign key column refers
| `unique` | Whether the column has a `UNIQUE` constraint
| `nullable` | Whether the column has a `NOT NULL` constraint
| `insertable` | Whether the column should appear in generated SQL `INSERT` and `UPDATE` statements
| `updatable` | Whether the column should appear in generated SQL `INSERT` and `UPDATE` statements
| `columnDefinition` üíÄ| A DDL fragment that should be used to declare the column
| `foreignKey` | A `@ForeignKey` annotation specifying the name of the `FOREIGN KEY` constraint
|===

Here we see how to use `@JoinColumn` to define a `@ManyToOne` association which mapping a foreign key column which refers to a non-primary-key `UNIQUE` column of the referenced table.

[source,java]
----
@Entity
@Table(name="Items")
class Item {
    ...
    @ManyToOne(optional=false)  // implies nullable=false
    @JoinColumn(name = "bookIsbn", referencedColumnName = "isbn",  // a reference to a non-PK column
                foreignKey = @ForeignKey(name="ItemsToBooksBySsn")) // supply a name for the FOREIGN KEY constraint
    Book book;
    ...
}
----

[TIP]
// .Foreign key constraint names
====
Notice the use of `@ForeignKey` to customize the name of the foreign key constraint.
If you don't supply a name explicitly, Hibernate will generate a quite ugly name.
To be fair, this is perfectly fine if you're only using the generated DDL for testing.
====

For associations mapped to a `@JoinTable`, fetching the association requires two joins, and so we must declare the ``@JoinColumn``s inside the `@JoinTable` annotation:

[source,java]
----
@Entity
class Book {
    @Id @GeneratedValue
    Long id;

    @ManyToMany
    @JoinTable(joinColumns=@JoinColumn(name="bookId"),
               inverseJoinColumns=@joinColumn(name="authorId"))
    Set<Author> authors;

    ...
}
----

[[primary-key-column-mappings]]
=== Mapping primary key joins between tables

The `@PrimaryKeyJoinColumn` is a special-purpose annotation for mapping:

- the primary key column of a `@SecondaryTable`‚Äîwhich is also a foreign key referencing the primary table, or
- the primary key column of the primary table mapped by a subclass in a `JOINED` inheritance hierarchy‚Äîwhich is also a foreign key referencing the primary table mapped by the root entity.

.`@PrimaryKeyJoinColumn` annotation members
[cols=",8"]
|===
| Annotation member | Purpose

| `name` | The name of the mapped foreign key column
| `referencedColumnName` | The name of the column to which the mapped foreign key column refers
| `columnDefinition` üíÄ| A DDL fragment that should be used to declare the column
| `foreignKey` | A `@ForeignKey` annotation specifying the name of the `FOREIGN KEY` constraint
|===

When mapping a subclass table primary key, we place the `@PrimaryKeyJoinColumn` annotation on the entity class:

[source,java]
----
@Entity
@Table(name="People")
@Inheritance(strategy=JOINED)
class Person { ... }

@Entity
@Table(name="Authors")
@PrimaryKeyJoinColumn(name="personId") // the primary key of the Authors table
class Author { ... }
----

But to map a secondary table primary key, the `@PrimaryKeyJoinColumn` annotation must occur inside the `@SecondaryTable` annotation:

[source,java]
----
@Entity
@Table(name="Books")
@SecondaryTable(name="Editions",
                pkJoinColumns = @PrimaryKeyJoinColumn(name="bookId")) // the primary key of the Editions table
class Book {
    @Id @GeneratedValue
    @Column(name="bookId") // the name of the primary key of the Books table
    Long id;

    ...
}
----

[[column-lengths]]
=== Column lengths and adaptive column types

Hibernate automatically adjusts the column type used in generated DDL based on the column length specified by the `@Column` annotation.
So we don't usually need to explicitly specify that a column should be of type `TEXT` or `CLOB`‚Äîor worry about the parade of `TINYTEXT`, `MEDIUMTEXT`, `TEXT`, `LONGTEXT` types on MySQL‚Äîbecause Hibernate will automatically select one of those types if required to accommodate a string of the `length` we specify.

The constant values defined in the class `org.hibernate.Length` are very helpful here:

.Predefined column lengths
[cols=",,8"]
|===
| Constant | Value | Description

| `DEFAULT` | 255 | The default length of a `VARCHAR` or `VARBINARY` column when none is explicitly specified
| `LONG` | 32600 | The largest column length for a `VARCHAR` or `VARBINARY` that is allowed on every database Hibernate supports
| `LONG16` | 32767 | The maximum length that can be represented using 16 bits (but this length is too large for a `VARCHAR` or `VARBINARY` column on for some database)
| `LONG32` | 2147483647 | The maximum length for a Java string
|===

We can use these constants in the `@Column` annotation:

[source,java]
----
@Column(length=LONG)
String text;

@Column(length=LONG32)
byte[] binaryData;
----

This is usually all you need to do to make use of large object types in Hibernate.

[[lobs]]
=== LOBs

JPA provides a `@Lob` annotation which specifies that a field should be persisted as a `BLOB` or `CLOB`.

.Semantics of the `@Lob` annotation
****
What the spec actually says is that the field should be persisted

> as a large object to a database-supported large object type.

It's quite unclear what this means, and the spec goes on to say that

> the treatment of the `Lob` annotation is provider-dependent

which doesn't help much.
****

Hibernate interprets this annotation in what we think is the most reasonable way.
In Hibernate, an attribute annotated `@Lob` will be written to JDBC using the `setClob()` or `setBlob()` method of `PreparedStatement`, and will be read from JDBC using the `getClob()` or `getBlob()` method of `ResultSet`.

Now, the use of these JDBC methods is usually unnecessary!
JDBC drivers are perfectly capable of converting between `String` and `CLOB` or between `byte[]` and `BLOB`.
So unless you specifically need to use these JDBC LOB APIs, you _don't_ need the `@Lob` annotation.

Instead, as we just saw in <<column-lengths>>, all you need is to specify a large enough column `length` to accommodate the data you plan to write to that column.

[WARNING]
// .PostgreSQL `BYTEA` and `TEXT`
====
Unfortunately, the driver for PostgreSQL doesn't allow `BYTEA` or `TEXT` columns to be read via the JDBC LOB APIs.

This limitation of the Postgres driver has resulted in a whole cottage industry of bloggers and stackoverflow question-answerers recommending convoluted ways to hack the Hibernate `Dialect` for Postgres to allow an attribute annotated `@Lob` to be written using `setString()` and read using `getString()`.

But simply removing the `@Lob` annotation has exactly the same effect.
====

