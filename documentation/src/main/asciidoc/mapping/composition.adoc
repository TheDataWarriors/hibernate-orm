[[composition]]
== Compositions
:sourcedir: extras

* link:#access[???]
* link:#overrides[???]
* link:#naming[???]

Historically Hibernate called these components. JPA calls them
embeddables. Either way the concept is the same: a composition of
values. For example we might have a Name class that is a composition of
first-name and last-name, or an Address class that is a composition of
street, city, postal code, etc.

.Simple composition example
[source,java]
----
include::{sourcedir}/composition/Name.java[]
----

[source,java]
----
include::{sourcedir}/composition/Address.java[]
----

A composition is another form of value type. The lifecycle of a
composition is defined by the thing that contains it.

A composition inherits the attribute access of its parent. For details
on attribute access, see link:#access[???].

Compositions can be made up of basic values as well as associations,
with the caveat that compositions which are used as collection elements
cannot themselves define collections.

=== Component / Embedded

This is the form of composition you will see most often. Here an entity
or another composition is the container.

.Simple Embedded
[source,java]
----
include::{sourcedir}/composition/Person.java[]
----

[NOTE]
====
Notice that JPA defines 2 terms for composition: Embeddable and
Embedded. Embeddable is used to describe the composition class itself
(Name). Embedded is used to describe a usage of that composition
(Person.name).
====

The composition here is the Name type related to Person.name.

.Person table
[source,sql]
----
include::{sourcedir}/composition/Person1.sql[]
----

The composed values are mapped to the same table as the parent table.
Composition is part of good OO data modeling (idiomatic java). In fact
that table could also be mapped by the following entity instead.

.Alternative to composition
[source,java]
----
include::{sourcedir}/composition/Person_alt.java[]
----

The composition form is certainly more OO. And that becomes more evident
as we work with multiple compositions.

[[composition-multiple]]
=== Multiple compositions

.Multiple compositions
[source,java]
----
include::{sourcedir}/composition/Contact.java[]
----

It is certainly more convenient to work with the compositions. However,
an interesting thing happens in this particular example. By default,
this mapping actually will not work as-is. The problem is in how JPA
defines implicit naming rules for columns that are part of a
composition, which say that all of the Address compositions would map to
the same implicit column names.

This occurs any time we have multiple compositions based on the same
embeddable in a given parent. We have a few options to handle this
issue.

[[composition-multiple-jpa]]
==== JPA's AttributeOverride

The JPA-defined way to handle this situation is through the use of its
AttributeOverride annotation.

.JPA's AttributeOverride
[source,java]
----
include::{sourcedir}/composition/Contact-AttributeOverride.java[]
----

Now, essentially there are no implicit column names in the Address
compositions. We have explicitly named them.

[[composition-multiple-namingstrategy]]
==== ImplicitNamingStrategy

[NOTE]
====
This is a Hibernate specific feature. Users concerned with JPA provider
portability should instead prefer explicit column naming with
AttributeOverride as per link:#composition-multiple-jpa[JPA's AttributeOverride]
====

Hibernate naming strategies are covered in detail in link:#naming[???].
However, for the purposes of this discussion, Hibernate has the
capability to interpret implicit column names in a way that is safe for
use with multiple compositions.

.Enabling composition-safe implicit naming
[source,java]
----
include::{sourcedir}/composition/component-safe-implicit-naming.java[]
----

Now the "path" to attributes are used in the implicit column naming.

.Enabling composition-safe implicit naming
[source,sql]
----
include::{sourcedir}/composition/Contact-ImplicitNamingStrategy.sql[]
----

You could even develop your own to do special implicit naming.

[[composition-collections]]
=== Collections of compositions

Collections of compositions are specifically value collections (as
compositions are a value type). Value collections are covered in detail
in link:collection.adoc#collections-value[Collections of value types].

The one thing to add to the discussion of value collections in regards
to compositions is that the composition cannot, in turn, define
collections.

[[composition-mapkey]]
=== Compositions as Map key

Compositions can also be used as the key values for Maps. Mapping Maps
and their keys is convered in detail in link:collection.adoc#collections-map[Map - key].

Again, compositions used as a Map key cannot, in turn, define
collections.

[[composition-identifier]]
=== Compositions as identifiers

Compositions can also be used as entity identifiers. This usage is
covered in detail in link:#identifier-composite[Composite identifiers]

Again, compositions used as an entity identifier cannot, in turn, define
collections.