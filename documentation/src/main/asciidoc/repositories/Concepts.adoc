[[concepts]]
== Concepts

Jakarta Data and Jakarta Persistence both represent data in a typesafe way, using _entity classes_.
Since Hibernate's implementation of Jakarta Data is backed by access to a relational database, these entity classes are mapped using the annotations defined by Jakarta Persistence.

For example:

[source,java]
----
@Entity
public class Book {
    @Id
    String isbn;

    @Basic(optional = false)
    String title;

    LocalDate publicationDate;

    @Basic(optional = false)
    String text;

    @Enumerated(STRING)
    @Basic(optional = false)
    Type type = Type.Book;

    @ManyToOne(optional = false, fetch = LAZY)
    Publisher publisher;

    @ManyToMany(mappedBy = Author_.BOOKS)
    Set<Author> authors;

    ...
}

@Entity
public class Author {
    @Id
    String ssn;

    @Basic(optional = false)
    String name;

    Address address;

    @ManyToMany
    Set<Book> books;
}
----

[NOTE]
====
Jakarta Data also works with entities defined using similarly-named annotations defined by Jakarta NoSQL.
But in this document we’re using Hibernate Data Repositories, so all mapping annotations should be understood to be the ones defined in `jakarta.persistence` or `org.hibernate.annotations`.
====

Furthermore, queries may be expressed in HQL, Hibernate's superset of the Jakarta Persistence Query Language (JPQL).

[NOTE]
====
The Jakarta Data specification defines a simple subset of JPQL called, appropriately, JDQL.
JDQL is mostly relevant to non-relational datastores; an implementation of Jakarta Data backed by access to relational data is normally expected to support a much larger subset of JPQL.
Indeed, Hibernate Data Repositories supports a _superset_ of JPQL.
So, even though we put rather a large amount of effort into advocating, designing, and specifying JDQL, we won't talk much about it here.
====

This is where the similarity between Jakarta Persistence and Jakarta Data ends.
The following table contrasts the two programming models.

[cols="25,^~,^~"]
|===
| | Persistence | Data

| Stateful persistence context | ✔ | ✖
| Gateway | `EntityManager` interface  | User-written `@Repository` interface
| Persistence operations | Generic methods like `find()`, `persist()`, `merge()`, `remove()` | Typesafe user-written methods annotated `@Find`, `@Insert`, `@Update`, `@Save`, `@Delete`
| Validation of JPQL | Runtime | Compile time
|===

The biggest difference here that Jakarta Data does not feature stateful persistence contexts.
Among other consequences:

- entity instances are always detached, and so
- updates require an explicit operation.

A repository in Hibernate Data Repositories is backed by a `StatelessSession`, not by a Jakarta Persistence `EntityManager`.

[NOTE]
====
A future release of Jakarta Data will feature repositories backed by Jakarta Persistence stateful persistence contexts, but this functionality did not make the cut for Jakarta Data 1.0.
====

The second big difference is that instead of providing a generic interface like `EntityManager` that's capable of performing persistence operations for any entity class, Jakarta Data requires that each interaction with the database go via a user-written method specific to just one entity type. The method is marked with annotations allowing Hibernate to fill in the method implementation.

For example, whereas Jakarta Persistence defines the methods `find()` and `persist()` of `EntityManager`, in Jakarta Data the application programmer is required to write an interface like the following:

[source,java]
----
@Repository
interface Library {
    @Find
    Book book(String isbn);

    @Insert
    void add(Book book);
}
----

This is our first example of a repository.

=== Repository interfaces

A _repository interface_ is an interface written by you, the application programmer, and annotated `@Repository`.
The implementation of the repository interface is provided by a Jakarta Data provider, in our case, by Hibernate Data Repositories.

[NOTE]
====
The Jakarta Data specification does not say how this should work, but in Hibernate Data Repositories, the implementation is generated by an annotation processor.
In fact, you might already be using this annotation processor: it's just `HibernateProcessor` from the now-inaptly-named `hibernate-jpamodelgen` module.
====

[TIP]
====
That's right, this fancy thing I'm calling Hibernate Data Repositories is really just a new feature of Hibernate's venerable static metamodel generator.
If you're already using the JPA static metamodel in your project, you already have Jakarta Data at your fingertips.
If you don't, we'll see how to set it up in the next section.
====

Of course, a Jakarta Data provider can't generate an implementation of any arbitrary method.
Therefore, the methods of a repository interface must fall into one of the following categories:

- `default` methods,
- _lifecycle methods_ annotated `@Insert`, `@Update`, `@Delete`, or `@Save`,
- _automatic query methods_ annotated `@Find`,
- _annotated query methods_ annotated `@Query` or `@SQL`, and
- _resource accessor methods_.

[TIP]
====
For users migrating from Spring Data, Jakarta Data also provides a _Query by Method Name_ facility.
We don't recommend this approach for new code.
====

A `default` method is one you implement yourself, and there's nothing special about it.

[source,java]
----
@Repository
interface Library {
    default void hello() {
        System.out.println("Hello, World!");
    }
}
----

Let's see what the other kinds of method do.

=== Lifecycle methods

Jakarta Data 1.0 defines four built-in lifecycle annotations, which map perfectly to the basic operations of the Hibernate `StatelessSession`:

- `@Insert` maps to `insert()`,
- `@Update` maps to `update()`,
- `@Delete` maps to `delete()`, and
- `@Save` maps to `upsert()`.

A lifecycle method usually accepts an instance of an entity type, and is usually declared `void`.

[source,java]
----
@Insert
void add(Book book);
----

Alternatively, it may accept a list or array of entities.
(A variadic parameter is considered an array.)

[source,java]
----
@Insert
void add(Book... books);
----

[NOTE]
====
A future release of Jakarta Data might expand the list of built-in lifecycle annotations.
In particular, we're hoping to add `@Persist`, `@Merge`, `@Refresh`, `@Lock`, and `@Remove`, mapping to the fundamental operations of `EntityManager`.
====

Repositories wouldn't be useful at all if this was all they could do.
Jakarta Data really starts to shine when we start to use it to express queries.

=== Automatic query methods

An automatic query method is usually annotated `@Find`.
The simplest automatic query method is one which retrieves an entity instance by its unique identifier.

[source,java]
----
@Find
Book book(String isbn);
----

The name of the parameter identifies that this is a lookup by primary key (the `isbn` field is annotated `@Id` in `Book`) and so this method will be implemented to call the `get()` method of `StatelessSession`.

If there is no `Book` with the given `isbn`, the method throws `EmptyResultException`.
There's two ways around this if that's not what you want:

- declare the method to return `Optional`, or
- annotate the method `@jakarta.annotation.Nullable`.

The first option is blessed by the specification:

[source,java]
----
@Find
Optional<Book> book(String isbn);
----

The second option is an extension provided by Hibernate:

[source,java]
----
@Find @Nullable
Book book(String isbn);
----

An automatic query method might return multiple results.
In this case, the return type must be an array or list of the entity type.

[source,java]
----
@Find
List<Book> book(String title);
----

[TIP]
====
Usually, arguments to a parameter of an automatic query method must match _exactly_ with the field of an entity.
However, Hibernate provides the `@Pattern` annotation to allow for "fuzzy" matching using `like`.

[source,java]
----
@Find
List<Book> book(@Pattern String title);
----
====

Or course, an automatic query method might have multiple parameters.

[source,java]
----
@Find
List<Book> book(@Pattern String title, Year yearPublished);
----

In this case, _every_ argument must match the corresponding field of the entity.

The `@OrderBy` annotation allows results to be sorted.

[source,java]
----
@Find
@OrderBy("title")
@OrderBy("publisher.name")
List<Book> book(@Pattern String title, Year yearPublished);
----

This might not look very typesafe at first glance, but--amazingly--the content of the `@OrderBy` annotation is completely validated at compile time, as we will see below.

Automatic query methods are great and convenient for very simple queries.
For anything that's not extremely simple, we're much better off writing a query in JPQL.

=== Annotated query methods

An annotated query method is declared using:

- `@Query` from Jakarta Data, or
- `@HQL` or `@SQL` from `org.hibernate.annotations.processing`.

[NOTE]
====
There's no strong reason to use `@HQL` in preference to `@Query`.
This annotation exists because the functionality described here predates the existence of Jakarta Data.
====

Consider the following example:

[source,java]
----
@Query("where title like :pattern order by title, isbn")
List<Book> booksByTitle(String pattern);
----

You might notice that:

- The `from` clause is not required in JDQL, and is inferred from the return type of the repository method.
- Since Jakarta Persistence 3.2, neither the `select` cause nor entity aliases (identification variables) are required in JPQL, finally standardizing a very old feature of HQL.

This allows simple queries to be written in a very compact form.

Method parameters are automatically matched to ordinal or named parameters of the query.
In the previous example, `pattern` matches `:pattern`.
In the following variation, the first method parameter matches `?1`.

[source,java]
----
@Query("where title like ?1 order by title, isbn")
List<Book> booksByTitle(String pattern);
----

You might be imagining that the JPQL query specified within the `@Query` annotation cannot be validated at compile time, but this is not the case.
`HibernateProcessor` is not only capable of validating the _syntax_ of the query, but it even _typechecks_ the query completely.
This is much better than passing a string to the `createQuery()` method of `EntityManager`, and it's probably the top reason to use Jakarta Data with Hibernate.

A native SQL query may be specified using `@SQL`.

[source,java]
----
@SQL("select title from books where title like :pattern order by title, isbn")
List<String> booksByTitle(String pattern);
----