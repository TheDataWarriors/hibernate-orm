[[concepts]]
== Concepts

Jakarta Data and Jakarta Persistence both represent data in a typesafe way, using _entity classes_.
Since Hibernate's implementation of Jakarta Data is backed by access to a relational database, these entity classes are mapped using the annotations defined by Jakarta Persistence.

For example:

[source,java]
----
@Entity
public class Book {
@Id
String isbn;

    @Basic(optional = false)
    String title;

    LocalDate publicationDate;

    @Basic(optional = false)
    String text;

    @Enumerated(STRING)
    @Basic(optional = false)
    Type type = Type.Book;

    @ManyToOne(optional = false, fetch = LAZY)
    Publisher publisher;

    @ManyToMany(mappedBy = Author_.BOOKS)
    Set<Author> authors;

    ...
}

@Entity
public class Author {
    @Id
    String ssn;

    @Basic(optional = false)
    String name;

    Address address;

    @ManyToMany
    Set<Book> books;
}
----

[NOTE]
====
Jakarta Data also works with entities defined using similarly-named annotations defined by Jakarta NoSQL.
But in this document we’re using Hibernate Data Repositories, so all mapping annotations should be understood to be the ones defined in `jakarta.persistence` or `org.hibernate.annotations`.
====

This is where the similarity between Jakarta Persistence and Jakarta Data ends.
The following table contrasts the two programming models.

[cols="25,^~,^~"]
|===
| | Persistence | Data

| Stateful persistence context | ✔ | ✖
| Gateway | `EntityManager` interface  | User-written `@Repository` interface
| Persistence operations | Generic methods like `find()`, `persist()`, `merge()`, `remove()` | Typesafe user-written methods annotated `@Find`, `@Insert`, `@Update`, `@Save`, `@Delete`
| Validation of JPQL | Runtime | Compile time
|===

The biggest difference here that Jakarta Data does not feature stateful persistence contexts.
Among other consequences:

- entity instances are always detached,
- updates require an explicit operation.

A repository in Hibernate Data Repositories is backed by a `StatelessSession`, not by a Jakarta Persistence `EntityManager`.

[NOTE]
====
A future release of Jakarta Data will feature repositories backed by Jakarta Persistence stateful persistence contexts, but this functionality did not make the cut for Jakarta Data 1.0.
====

The second big difference is that instead of providing a generic interface like `EntityManager` that's capable of performing persistence operations for any entity class, Jakarta Data requires that each interaction with the database go via a user-written method specific to just one entity type. The method is marked with annotations allowing Hibernate to fill in the method implementation.

For example, whereas Jakarta Persistence defines the methods `find()` and `persist()` of `EntityManager`, in Jakarta Data the application programmer is required to write an interface like the following:

[source,java]
----
@Repository
interface Library {
    @Find
    Book book(String isbn);

    @Insert
    void add(Book book);
}
----

This is our first example of a repository.

=== Repository interfaces

A _repository interface_ is an interface written by you, the application programmer, and annotated `@Repository`.
The implementation of the repository interface is provided by a Jakarta Data provider, in our case, by Hibernate Data Repositories.

[NOTE]
====
The Jakarta Data specification does not say how this should work, but in Hibernate Data Repositories, the implementation is generated by an annotation processor.
In fact, you might already be using this annotation processor: its just `HibernateProcessor` from the now-inaptly-named `hibernate-jpamodelgen` module.
====

[TIP]
====
That's right, this fancy thing I'm calling Hibernate Data Repositories is really just a new feature of Hibernate's venerable static metamodel generator.
If you're already using the JPA static metamodel in your project, you already have Jakarta Data at your fingertips.
If you don't, we'll see how to set it up in the next section.
====

Of course, a Jakarta Data provider can't generate an implementation of any arbitrary method.
Therefore, the methods of a repository interface must fall into one of the following categories:

- `default` methods,
- _lifecycle methods_ annotated `@Insert`, `@Update`, `@Delete`, or `@Save`,
- _automatic query methods_ annotated `@Find`,
- _annotated query methods_ annotated `@Query` or `@SQL`, and
- _resource accessor methods_.

[TIP]
====
For users migrating from Spring Data, Jakarta Data also provides a _Query by Method Name_ facility.
We don't recommend this approach for new code.
====

A `default` method is one you implement yourself, and there's nothing special about it.

[source,java]
----
@Repository
interface Library {
    default void hello() {
        System.out.println("Hello, World!");
    }
}
----

Let's see what the other kinds of method do.

=== Lifecycle methods

Jakarta Data 1.0 defines four built-in lifecycle annotations, which map perfectly to the basic operations of the Hibernate `StatelessSession`:

- `@Insert` maps to `insert()`,
- `@Update` maps to `update()`,
- `@Delete` maps to `delete()`, and
- `@Save` maps to `upsert()`.

A lifecycle method usually accepts an instance of an entity type, and is usually declared `void`.

[source,java]
----
@Insert
void add(Book book);
----

Alternatively, it may accept a list or array of entities.
(A variadic parameter is considered an array.)

[source,java]
----
@Insert
void add(Book... books);
----

[NOTE]
====
A future release of Jakarta Data might expand the list of built-in lifecycle annotations.
In particular, we're hoping to add `@Persist`, `@Merge`, `@Refresh`, `@Lock`, and `@Remove`, mapping to the fundamental operations of `EntityManager`.
====

=== Automatic query methods